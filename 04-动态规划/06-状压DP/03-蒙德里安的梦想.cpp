/*----------------------------------------------------------------
 * 文件名称：蒙德里安的梦想.cpp
 * 创建日期：2021年11月01日 星期一 08时49分37秒 5 * 题 目：AcWing 0291 蒙德里安的梦想 6 * 算 法：状压DP
 * 描 述：求把 N * M 的棋盘分割成若干个 1 * 2 的长方形，有多少 8 * 种方案 9 *
 * 例如 N = 2, M = 3 有 3 种方案
 *
 * |--------|----| |----|--------| |----|----|----|
 * | | | | | | | | | |
 * |--------| | | |--------| | | | |
 * | | | | | | | | | |
 * |--------|----| |----|--------| |----|----|----|
 *
 ----------------------------------------------------------------*/
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int maxn = 12, maxm = 1 << maxn;
typedef long long ll;
int n, m;
// dp[i][j] 表示已经将前 i - 1 列放好，第 i - 1 列中横放的方块占据第 i 列的状态为 j 的方案数
ll dp[maxn][maxm];
vector<int> state[maxm];
bool used[maxm];
32
/*
 * 这里是第 i - 1 列 --| |-- 这里是第 i 列
 * V V
 * |---|---|---|---|-------|---|---|---|---|---|---|---|---|---|
 * | | | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | | |---|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | | |---|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | | |---|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | | |---|---|---|---|---|---|---|---|---|---|
 * | | | + | | | | | | | | | |
 * | |-------|---|---|---|---|---|---|---|---|---|
 * | | | | | | | | | | | |
 * |---|---|---|---|-------|---|---|---|---|---|---|---|---|---|
 *
 * 在这个图中，第 i 列可能部分位置被第 i - 1 列横放的方块占据
 * 对于第 i 列来说，被占据的位置用 1 表示，没被占据的位置用 0 表示
 * 则可以用一个二进制数表示这一列当前的状态，在这里是：1100100100001
 *
 * 这个状态成立的条件之一就是没被占据的空位置的长度都必须是偶数
 *
 */
int main() {
    while (scanf("%d %d", &n, &m) && (n || m)) {
        // 预处理当前状态 i 是否存在，也就是没有奇数长度的空位置
        for (int i = 0; i < 1 << n; ++ i) {
            int cnt = 0; // 这个空位的长度
            bool is_valid = true; // 判断是否合法，如果有奇数个零，表示不合法
            for (int j = 0; j < n; ++ j) {
                if (i >> j & 1) {
                    if (cnt & 1) {
                        is_valid = false;
                        break;
                    }
                    cnt = 0;
                }
                else {
                    cnt ++ ;
                }
            }
            if (cnt & 1) // 还要判断最后一个空的长度
                is_valid = false;
            used[i] = is_valid;
        }
        for (int i = 0; i < 1 << n; ++ i) {
            state[i].clear();
            for (int j = 0; j < 1 << n; ++ j)
                if ((i & j) == 0 && used[i | j])
                    // 对于前一列的状态 i 来说，当前列的状态 j 是满足的
                    // 对于当前列的状态 i 来说，前一列的状态 j 是满足的
                    state[i].push_back(j);
        }
        memset(dp, 0, sizeof dp);
        dp[0][0] = 1;
        for (int i = 1; i <= m; ++ i)
            for (int j = 0; j < 1 << n; ++ j) // i - 1 列横放的方块占据的第 i 列的状态为 j
                for (auto k : state[j]) // 第 i - 1 列是怎么放的
                    dp[i][j] += dp[i - 1][k];
        printf("%lld\n", dp[m][0]);
    }
    return 0;
}
