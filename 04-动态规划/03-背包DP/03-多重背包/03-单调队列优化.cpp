/*----------------------------------------------------------------
 *
 *   文件名称：03-单调队列优化.cpp
 *   创建日期：2021年04月07日 ---- 17时52分
 *   题    目：AcWing 0006 多重背包问题
 *   算    法：多重背包，单调队列优化
 *   描    述：执行单调队列的三个惯例操作
 *      1. 检查队头合法性
 *      2. 取队头为最优策略，更新
 *      3. 把新策略插入队尾，入队前检查队尾单调性，排除无用决策
 *
 ----------------------------------------------------------------*/

#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxn = 20005;
int N, V;
int dp[maxn], tmp[maxn];
int quu[maxn]; //队首元素是dp[j], dp[j-v], dp[j-2v], ... dp[j-(k-v)v)里最大的数

int main() {
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    scanf("%d %d", &N, &V);
    for (int i = 0; i < N; ++i) {
        int vo, va, a; //体积，价值，当前物品数量
        scanf("%d %d %d", &vo, &va, &a);
        memcpy(tmp, dp, sizeof(dp)); //tmp为dp[i-1], dp为dp[i]
        /*
         * 枚举余数即等价类
         * 背包体积，j < vo是因为vo可以由j = 0 + vo得到
         * 再下面一个for循环就是将每个等价类进行单调队列操作
         * 每个等价类有0, 0+1vo, 0+2vo, 0+3vo ...
         *             1, 1+1vo, 1+2vo, 1+3vo ...
         *             2, 2+1vo, 2+2vo, 2+3vo ...
         *             ...
         * 所有等价类中的数就是0 ~ V，也就是背包的第二维
         */
        for (int j = 0; j < vo; ++j) {
            int hh = 0, tt = -1;                //hh为队首 tt为队尾
            for (int k = j; k <= V; k += vo) {  //枚举同一等价类的背包体积
                dp[k] = tmp[k];                 //此句意义不大，确实意义不大
                //如果当前位置表示的背包体积>队首体积+当前物品总体积，很显然队首体积不合法了，出队
                if (hh <= tt && quu[hh] < k-a*vo)
                    ++hh;
                /*
                 * 使用tmp，决策上一件物品是队首体积时的最优解+队首体积到当前体积需要的当前物品总价值
                 *
                 *      |------- quu[hh]指向的位置，tmp[quu[hh]存储这里的最优解
                 *      v
                 * -------------------------------------------------------------------------
                 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
                 * -------------------------------------------------------------------------
                 * |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
                 * -------------------------------------------------------------------------
                 *      ^                                                     ^
                 *      |---  填充到当前体积需要的物品数(k-quu[hh])/vo*va  ---|
                 */
                if (hh <= tt)
                    dp[k] = max(dp[k], tmp[quu[hh]]+(k-quu[hh])/vo*va);
                /*
                 * tmp[quu[tt]]         放入上一件物品体积在队尾体积处时的最优解
                 * (quu[tt]-j)/vo*va    等价类的第一个体积到队尾体积全部填充当前物品所需要的总价值
                 * tmp[k]               放入上一件物品体积在当前体积处时的最优解
                 * (k-j)/vo*va          等价类的第一个体积到当前体积全部填充当前物品所需要的总价值
                 *
                 * 在动态转移方程里是tmp[quu[hh]] + (k-quu[h])/vo*va
                 * 也就是最近的k个物品的决策里的最大值
                 * 但为什么在这里就是tmp[quu[tt]] - (quu[tt]-j)/vo*va呢
                 *
                 * 前a-1个数在单调队列中的决策
                 * dp[k] = max(dp[k], dp[k-vo]+va, dp[k-2vo]+2va, dp[k-3vo]+3va, ...
                 * 在单调队列中无法实现，转化为
                 * dp[k]-(k-j)/vo*va, dp[k-vo]-(k-vo-j)/vo*va, dp[k-2vo]-(k-2vo-j)/vo*va, ...
                 * 会发现，上下两式各项都相差(k-j)/vo*va，所以可以转化
                 *
                 * 队列中肯定要放最大值，这里的最大值还要根据k的位置确定，因为在求dp[k]时，队首元素到
                 * 当前位置k所需要的(k-quu[hh])/vo*va是随着k的变化而变化的，所以队列中不能存储确定的值，只能存储位置
                 * 对于当前位置，队列中的元素到达当前位置的总价值是无法确定的，但是到达等价类的第一个位置的总价值是
                 * 确定的，而且等价类的第一个位置到当前位置的总价值也是确定的，所以单调队列中存储的本应是前a个位置到
                 * 达当前位置的总价值由大到小排序(部分不满足由大到小的位置出队)，然而到达当前位置的总价值无法确定，所以
                 * 转化为到达等价类第一个位置的总价值
                 */
                while (hh <= tt && tmp[quu[tt]] - (quu[tt]-j)/vo*va <= tmp[k] - (k-j)/vo*va)
                    --tt;
                //无论如何，将当前位置插入队列
                quu[++tt] = k;
            }
        }
    }
    printf("%d\n", dp[V]);
    return 0;
}
