/*----------------------------------------------------------------
 * 文件名称：03-单调队列优化.cpp
 * 创建日期：2021年04月07日 ---- 17时52分 
 * 创建日期：2021年10月18日 星期一 20时16分52秒 
 * 题 目：AcWing 0006 多重背包问题 
 * 算 法：多重背包，单调队列优化 
 * 描 述：执行单调队列的三个惯例操作 
 *
 * 1. 检查队头合法性
 * 2. 取队头为最优策略，更新
 * 3. 把新策略插入队尾，入队前检查队尾单调性，排除无用决策
 *
 * 0 < n < 1000
 * 0 < m < 20000
 * 0 < v, w, s < 20000
 *
 ----------------------------------------------------------------*/

#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxn = 2e4 + 5;
int n, m;
int dp[maxn], tmp[maxn];
int q[maxn];
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; ++ i) {
        int v, w, s; // 体积，价值，当前物品数量
        scanf("%d %d %d", &v, &w, &s);
        memcpy(tmp, dp, sizeof dp); // tmp 为 dp[i - 1]，dp 为 dp[i]，有滚动数组的味道了
        /*
         * 枚举余数即等价类
         * 背包体积，j < v 是因为 v 可以由 j = 0 + v 得到
         * 每个等价类有0, 0+1v, 0+2v, 0+3v ... -> 每个 for(j) 进行单调队列操作，为了找出这个等价类中最大的价值
         * 1, 1+1v, 1+2v, 1+3v ...
         * 2, 2+1v, 2+2v, 2+3v ...
         * ...
         * v-1, ...
         * 所有等价类中的数就是0 ~ m，也就是背包的第二维
         */
        for (int j = 0; j < v; ++ j) {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v) {
                // 如果当前位置表示的背包体积 > 队首体积 + 当前物品总体积，很显然队首体积不合法了，出队
                if (hh <= tt && q[hh] < k - s * v)
                    ++ hh;
                /*
                 * 使用tmp，决策上一件物品是队首体积时的最优解+队首体积到当前体积需要的当前物品总价值
                 *
                 * |------- q[hh]指向的位置，tmp[q[hh]] 存储这里的最优解（背包体积为 q[hh] 时，最大价值）
                 * v
                 * -------------------------------------------------------------------------
                 * | | | | | | | | | | | | | | | | | | | | | | | | |
                 * -------------------------------------------------------------------------
                 * | | | | | | | | | | | | | | | | | | | | | | | | |
                 * -------------------------------------------------------------------------
                 * ^ ^
                 * |--- 填充到当前体积需要的物品数(k - q[hh]) / v * w ---|
                 */
                if (hh <= tt)
                    dp[k] = max(dp[k], tmp[q[hh]] + (k - q[hh]) / v * w);
                /*
                 * tmp[q[tt]] 放入上一件物品体积在队尾体积处时的最大价值
                 * (q[tt] - j) / v * w 等价类的第一个体积到队尾体积全部填充当前物品所需要的总价值
                 * tmp[k] 放入上一件物品体积在当前体积处时的最大价值
                 * (k - j) / v * w 等价类的第一个体积到当前体积全部填充当前物品所需要的总价值
                 *
                 * 在动态转移方程里是tmp[q[hh]] + (k - q[hh]) / v * w
                 * 也就是最近的k个物品的决策里的最大值
                 * 但为什么在这里就是tmp[q[tt]] - (q[tt] - j) / v * w 呢
                 *
                 * 前 a-1 个数在单调队列中的决策
                 * dp[k] = max(dp[k], dp[k-v]+w, dp[k-2v]+2w, dp[k-3v]+3w, ...)
                 * 在单调队列中无法实现，转化为
                 * dp[k]-(k-j)/v*w, dp[k-v]-(k-v-j)/v*w, dp[k-2v]-(k-2v-j)/v*w, ...
                 * 会发现，上下两式各项都相差(k-j)/v*w，所以可以转化
                 *
                 * 队列中肯定要放最大值，这里的最大值还要根据k的位置确定，因为在求dp[k]时，队首元素到
                 * 当前位置k所需要的(k-q[hh])/v*w是随着k的变化而变化的，所以队列中不能存储确定的值，只能存储位置
                 * 对于当前位置，队列中的元素到达当前位置的总价值是无法确定的，但是到达等价类的第一个位置的总价值是
                 * 确定的，而且等价类的第一个位置到当前位置的总价值也是确定的，所以单调队列中存储的本应是前a个位置到
                 * 达当前位置的总价值由大到小排序(部分不满足由大到小的位置出队)，然而到达当前位置的总价值无法确定，所 以
                 * 转化为到达等价类第一个位置的总价值
                 */
                while (hh <= tt && tmp[q[tt]] - (q[tt] - j) / v * w <= tmp[k] - (k - j) / v * w)
                    -- tt;
                // 无论如何，将当前位置插入队列
                q[ ++ tt] = k;
            }
        }
    }
    printf("%d\n", dp[m]);
    return 0;
}
