/*----------------------------------------------------------------
 * 文件名称：整数划分-计数DP.cpp
 * 创建日期：2021年10月31日 星期日 16时08分19秒 
 * 题 目：AcWing 0900 整数划分 
 * 算 法：计数DP
 * 描 述：一个正整数 n 可以表示成若干个正整数之和，
 * 形如：n = n1 + n2 + ... + nk， 9 * 其中 n1 >= n2 >= ... >= nk,k >= 1
 * 我们将这样的一种表示称为正整数 n 的一种划分。
 * 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。
 *
 * dp[i][j]: 所有总和是 i，并且恰好表示成 j 个数的和的方案数量
 *
 * dp[i][j]: dp[i - 1][j - 1] + dp[i - j][j];
 *
 * 分为两种情况：
 * 1. 这 j 个数中最小值是 1，那么把这个 1 给去掉，就有 j - 1 个数
 * 的总和是 i - 1
 * 2. 这 j 个数中最小值不是 1，那么把这 j 个数都减 1，就还是 j 个
 * 数，总和变成了 i - j
 * 显然所有的数的组合都被这两种情况所涵盖，且不重合
 *
 * 就有：dp[i][j]: dp[i - 1][j - 1] + dp[i - j][j];
 *
 * 最后的结果是 dp[n][1] + dp[n][2] + ... + dp[n][n]
 *
 ----------------------------------------------------------------*/

#include <cstdio>
const int maxn = 1e3 + 5, MOD = 1e9 + 7;
int dp[maxn][maxn];
int main() {
    int n; scanf("%d", &n);
    dp[0][0] = 1; // 所有总和是 0，并且恰好表示成 0 个数的和的方案数量
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= i; ++ j)
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - j][j]) % MOD;
    int res = 0;
    for (int j = 1; j <= n; ++ j)
        res = (res + dp[n][j]) % MOD;
    printf("%d\n", res);
    return 0;
}
