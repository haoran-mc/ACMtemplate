/*----------------------------------------------------------------
 *
 *   文件名称：02-二进制状态压缩.cpp
 *   创建日期：2021年05月08日 ---- 22时44分
 *   题    目：CH 0103
 *   算    法：旅行商问题，哈密顿路径
 *   描    述：0~n-1这n个点，从点0开始行走到点n-1结束，每个点都要经过
 *          且每个点到另外一个点有权重，问最小的花费是多少
 *          发现：
 *          假设已经经过了0, 1, 2, 3这四个点，由于要从0开始，那么会有3! = 6种方式
 *          0 -> 1 -> 2 -> 3  18
 *          0 -> 2 -> 1 -> 3  20
 *          ...
 *          在上面的两种方案里，对于后面的点的选择，一定不会选择第二种路径
 *          因为我们只需要在经过相同的点且最后的位置相同的行走方式中找到
 *          权重和最小的那种方式就行了，不管在这些点中是如何行走的，不会影响到
 *          后面点的选择
 *          1. 哪些点被用过
 *          2. 现在停在哪些点上
 *
 *          dp[state][j] = dp[state_k][k] + weight[k][j];
 *          state_k是state去掉j的集合，state_k要包含点k
 *          状态压缩，用一个数二进制中哪些是1来表示这个点被经过
 *          0, 1, 4    ->    10011
 *
 ----------------------------------------------------------------*/

#include <cstdio>
#include <cstring>
const int maxn = 20;
#define _min(a, b) (a < b ? a : b)
/*
 * dp[i][j]中i的二进制为1的点已经被经过，当前处于点j
 * 如dp[7][1]中7的二进制为0111，则有点0、点1、点2都已经被经过，当前位于点1
 * 状态转移方程：dp[i][j] = min(dp[i][j], dp[i ^ (1<<j)][k] + weight[k][j]);
 * 既然状态为i的点都被经过，而当前位于点j，显然上一个状态是dp[i ^ (1<<j)][k] (k是状态i中非j的点)
 */
int dp[1 << maxn][maxn];
int weight[maxn][maxn];

int hamilton(int n) {
    memset(dp, 0x3f, sizeof(dp));
    dp[1][0] = 0; //起始点为0，所以点0到点0的距离是0
    for (int i = 1; i < (1 << n); ++i)
        for (int j = 0; j < n; ++j) //枚举当前所在的点
            if ((i >> j) & 1) //判断路径i中是否包括当前点j,如果包括当前点，则可以进行状态转移
                for (int k = 0; k < n; ++k) //要完成点k到点j的转移，所以要来枚举k
                    if (i - (1<<j) >> k & 1) //只有去除掉点j后路线中仍然包含点k才能说明路线是在点k的基础上向点j转移的
                        dp[i][j] = _min(dp[i][j], dp[i-(1<<j)][k] + weight[k][j]);
    return dp[(1 << n)-1][n-1]; //由于题目要求计算从点n到点n-1的路径长度，所以(1<<n)-1的二进制形式为111...111[共有(n-1)个1]
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            scanf("%d", &weight[i][j]);
    int res = hamilton(n);
    printf("%d\n", res);
    return 0;
}
