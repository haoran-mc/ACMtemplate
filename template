南昌大学 ACM 校队模板
2021 年 11 月 28 日
Author: 刘浩然
Email: haoran.mc@outlook.com
1
目录
1 语言基础 1
1.1 封装 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.1 头文件.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.2 复数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 STL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.1 STL.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 标准模板库 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3.1 string.h.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4 快读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4.1 快读快输.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4.2 普通读取.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.5 重载运算符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.5.1 重载运算符.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.6 已备函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6.1 二进制-拆为 2 的幂相加.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6.2 二进制-获取二进制表示中最高比重.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6.3 二进制-输出二进制表示.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.7 PY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.7.1 初始化列表.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.8 数学 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.8.1 math.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.9 语法基础 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.9.1 函数返回数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 基本算法 10
2.1 递归 and 分治 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1.1 递归实现指数型枚举 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1.1.1 递归-vector.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1.1.2 递归-used 数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.1.3 递归-状压.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.2 递归实现组合型枚举 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.1.2.1 简单递归-path 数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.1.2.2 递归 + 状压.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.1.2.3 非递归 + 手动写栈.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.1.3 递归实现排列型枚举 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.1.3.1 经典全排列.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.1.3.2 swap.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.1.3.3 递归全排列 + 状压.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2 贪心 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.2.1 区间合并 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.2.1.1 区间合并.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.2.2 均分纸牌 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2.2.1 均分纸牌.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2.3 糖果传递 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2.3.1 七夕祭.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2.3.2 糖果传递.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.2.4 区间贪心 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2.4.1 区间分组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2.4.2 区间覆盖.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.2.4.3 区间选点.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.2.4.4 最大不相交区间数量.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.2.5 哈夫曼编码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2.5.1 合并果子.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2.6 排序不等式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2.6.1 排队打水.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2.7 绝对值不等式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2.7.1 货仓选址.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2.8 推公式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2.8.1 刷杂技的牛.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.3 排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.3.1 选择排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.3.1.1 选择排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.3.2 冒泡排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.2.1 冒泡排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.3 插入排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.3.1 插入排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3.4 快速排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.3.4.1 双指针快排.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
Nanchang university ACM template 第 3 页
2.3.4.2 快速排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.3.4.3 第 k 个数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.3.5 归并排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.3.5.1 归并排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.3.5.2 逆序数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.3.6 堆排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.3.6.1 堆排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.4 前缀和 and 差分 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.4.1 一维前缀和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.4.2 一维差分.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.4.3 二维前缀和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
2.4.4 二维差分.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.4.5 异或前缀和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.5 二分 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.5.1 整数集合上的二分 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.5.1.1 数的范围.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.5.2 实数域上的二分 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.5.2.1 数的三次方根.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.5.3 二分答案转化为判定 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.5.3.1 根据厚度将书分组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.6 双指针 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.6.1 双指针.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3 搜索 36
3.1 深度优先搜索 (DFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.1.1 n-皇后问题 (1).cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.1.2 n-皇后问题 (2).cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.1.3 排列数字.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.1.4 搜索顺序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.1.4.1 马走日.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.1.5 连通性模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.1.5.1 红与黑.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.1.5.2 迷宫.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.2 宽度优先搜索 (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.2.1 八数码.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.2.2 双端队列宽搜 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.2.2.1 电路维修.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.2.3 多源 BFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.2.3.1 矩阵距离.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.2.4 最小步数模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
3.2.4.1 魔板.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
3.2.5 最短路模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.2.5.1 抓住那头牛.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.2.5.2 武士风度的牛.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
3.2.5.3 迷宫问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
3.2.6 洪泛法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.2.6.1 山峰和山谷.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.2.6.2 池塘计数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3.2.7 走迷宫.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.3 双向搜索 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.3.1 字串变换.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.4 A* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.4.1 八数码.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.4.2 第 k 短路.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4 动态规划 56
4.1 DP 基础 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
4.1.1 硬币问题 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
4.1.1.1 最少硬币问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
4.1.1.2 最少硬币组合.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
4.1.1.3 所有硬币组合-1.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.1.1.4 所有硬币组合-2.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.1.2 最长公共子序列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.1.2.1 最长公共子序列.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.1.3 最长递增子序列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.2 记忆化搜索 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.2.1 The-Triangle.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.2.2 滑雪.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.3 背包 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.3.1 01 背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Nanchang university ACM template 第 4 页
4.3.1.1 01 背包问题-一维.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.3.1.2 01 背包问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
4.3.1.3 Bone-Collector.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
4.3.2 完全背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.3.2.1 完全背包问题-一维.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.3.2.2 完全背包问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.3.3 多重背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.3.3.1 多重背包问题 I-朴素.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.3.3.2 多重背包问题 II-二进制分组优化.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.3.3.3 多重背包问题 III-单调队列优化.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.3.4 混合背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.3.4.1 混合背包问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.3.5 二维费用背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.3.5.1 二维费用的背包问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.3.6 分组背包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.3.6.1 分组背包问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.4 区间 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.4.1 回文串.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.4.2 石子合并.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.5 树形 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.5.1 Anniversary-Party.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.5.2 没有上司的舞会.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.6 状压 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.6.1 Corn-Fields.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.6.2 最短 Hamiton 路径.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.6.3 蒙德里安的梦想.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.7 数位 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.7.1 不要 4-递推.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.7.2 不要 4-记忆化.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.7.3 不要 4-递推.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
4.7.4 计数问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.8 计数 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.8.1 整数划分-完全背包.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.8.2 整数划分-计数 DP.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.9 线性 DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.9.1 数字三角形.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.9.2 最短编辑距离.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.9.3 最长上升子序列 I.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.9.4 最长上升子序列 II.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.9.5 最长公共子序列.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.9.6 编辑距离.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
5 字符串 84
5.1 字符串哈希 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
5.1.1 字符串哈希.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
5.1.2 拉链法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
5.2 字典树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
5.2.1 Trie 字符串统计.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
5.2.2 python-trie.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
5.2.3 最大异或对.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
5.3 前缀函数与 KMP 算法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
5.3.1 KMP-OI.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
5.3.2 KMP 字符串-idx-0.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
5.3.3 KMP 字符串-idx-1.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
5.3.4 KMP 字符串.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
5.4 z 函数 (扩展 KMP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
5.4.1 EKMP.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
5.5 AC 自动机 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
5.5.1 ACautomaton.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
5.5.2 Trie 图.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
5.5.3 搜索关键词.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
5.6 后缀数组 SA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
5.6.1 后缀数组的使用.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
5.6.2 sort 函数求 sa 数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
5.6.3 基数排序求 sa 数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
5.6.4 最长公共子串.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
5.7 Manacher . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
5.7.1 Manacher.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Nanchang university ACM template 第 5 页 6 数学问题 101
6.1 数学公式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
6.1.1 数学公式.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
6.2 位运算 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
6.2.1 lowbit.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
6.2.2 二进制状态压缩.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
6.2.3 整数除以 2.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
6.3 快速幂 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
6.3.1 快速幂.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
6.3.2 快速幂测试.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
6.3.3 矩阵快速幂.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
6.4 进制转换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
6.4.1 进制转换.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
6.4.2 进制转换.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
6.5 高精度计算 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
6.5.1 factN.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
6.5.2 二进制方法实现 64 位整数乘法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
6.5.3 暴躁 py.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
6.5.4 高精度乘法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
6.5.5 高精度减法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
6.5.6 高精度加法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
6.5.7 高精度除法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
6.6 数论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
6.6.1 素数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
6.6.1.1 埃氏筛法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
6.6.1.2 欧拉筛法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
6.6.1.3 试除法判定素数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
6.6.2 最大公约数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
6.6.2.1 最大公约数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
6.6.3 欧拉函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
6.6.3.1 欧拉函数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
6.6.3.2 筛法求欧拉函数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
6.6.4 类欧几里德算法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
6.6.4.1 扩展欧几里德算法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
6.6.5 乘法逆元 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.6.5.1 递推.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.6.5.2 终极递推.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.6.5.3 快速幂求逆元-费马小定理.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
6.6.5.4 扩展欧几里德算法求逆元.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
6.6.6 线性同余方程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
6.6.6.1 线性同余方程.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
6.6.7 中国剩余定理 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
6.6.7.1 表达整数的奇怪方式-模数不一定互质.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
6.6.7.2 表达整数的奇怪方式-模数互质.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
6.6.8 分解质因数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
6.6.8.1 分解质因数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
6.6.9 约数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
6.6.9.1 约数个数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
6.6.9.2 约数之和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
6.6.9.3 试除法求约数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
6.7 多项式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
6.7.1 快速傅里叶变换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
6.7.1.1 Cooley-Tukey.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
6.8 生成函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.8.1 普通生成函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.8.1.1 递归求整数划分.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
6.8.1.2 DP 求整数划分.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
6.8.1.3 生成函数求整数划分.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
6.8.2 指数生成函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
6.8.2.1 排列组合.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
6.9 线性代数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.9.1 高斯消元 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.9.1.1 高斯消元解异或线性方程组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.9.1.2 高斯消元解线性方程组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
6.10 组合数学 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.10.1 排列组合 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.10.1.1 求组合数 I.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.10.1.2 求组合数 II.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
6.10.1.3 求组合数 III.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
6.10.1.4 求组合数 IV.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Nanchang university ACM template 第 6 页
6.10.2 卡特兰数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.10.2.1 满足条件的 01 序列.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.10.3 斯特林数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.10.3.1 Stirling.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
6.10.4 康托展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6.10.4.1 八数码.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6.10.4.2 康托展开-vector.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
6.10.4.3 康托展开数组.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.10.5 容斥原理 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
6.10.5.1 能被整除的数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
6.11 斐波那契数列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
6.11.1 Fibonacci.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
6.11.2 Fibonacci.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
6.12 博弈论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
6.12.1 Bash-Game-sg.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
6.12.2 Nim-Game-sg.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
6.12.3 wythoff-Game.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
6.12.4 Nim 游戏.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
6.12.5 Nim 游戏.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
6.12.6 Nim 游戏.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
6.12.7 Nim 游戏-sg 函数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
7 数据结构 152
7.1 栈 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
7.1.1 模拟栈.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
7.1.2 表达式求值.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
7.2 队列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
7.2.1 模拟队列.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
7.3 链表 + 邻接表 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.3.1 双链表.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.3.2 邻接表.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.3.3 链式前向星.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
7.3.4 单链表.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.4 堆 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.4.1 二叉堆 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.4.1.1 对顶堆.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.4.1.2 模拟堆.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
7.5 并查集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
7.5.1 合并集合.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
7.5.2 食物链.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
7.6 数状数组 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
7.6.1 一个简单的整数问题.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
7.6.2 一个简单的整数问题 2.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
7.6.3 楼兰图腾.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
7.6.4 迷一样的牛.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
7.7 单调栈 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
7.7.1 直方图中最大矩形.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
7.8 单调队列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
7.8.1 最大子序列和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
7.8.2 滑动窗口.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
7.9 线段树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
7.9.1 模板 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
7.9.1.1 Segment-Tree(灯笼).cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
7.9.1.2 区间修改.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
7.9.1.3 单点修改.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
7.9.2 进阶 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7.9.2.1 区间乘-区间加.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7.9.2.2 区间最大公约数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
7.9.2.3 区间最大连续子段和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
7.9.3 扫描线 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
7.9.3.1 扫描线.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
7.10 二叉搜索树-平衡树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.10.1 二叉搜索树简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.10.2 Treap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.10.2.1 普通平衡树.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.11 可持久化数据结构 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.12 K-D-Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.12.1 K-D-Tree.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.12.2 K-D-Tree.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
Nanchang university ACM template 第 7 页 8 图论 184
8.1 图的存储 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
8.1.1 图论技巧.md . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
8.2 DFS(图论) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
8.2.1 树的重心.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
8.2.2 邻接矩阵.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
8.2.3 邻接表.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.2.4 链式前向星.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.3 BFS(图论) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.3.1 BFS-邻接矩阵.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.3.2 BFS-邻接表.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.3.3 BFS-链式前向星.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
8.4 拓扑排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
8.4.1 拓扑排序.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
8.5 最小生成树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.5.1 Prim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.5.1.1 Prim 算法求最小生成树.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.5.2 Kruskal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
8.5.2.1 Kruskal 算法求最小生成树.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
8.6 最短路 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.6.1 Dijstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.6.1.1 Dijkstra 求最短路 I.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.6.1.2 Dijkstra 求最短路 II.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
8.6.2 Bellman-Ford . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
8.6.2.1 有边数限制的最短路.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
8.6.3 SPFA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.6.3.1 spfa 判断负环.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.6.3.2 spfa 求最短路.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
8.6.4 Floyd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
8.6.4.1 Floyd 求最短路.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
8.7 连通性相关 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
8.7.1 强连通分量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
8.7.1.1 Kosaraju.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
8.7.1.2 Tarjan.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
8.7.2 双连通分量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
8.7.2.1 边双连通分量.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
8.7.3 割点和桥 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
8.7.3.1 判断是否是割点.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
8.8 二分图 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
8.8.1 二分图的最大匹配-匈牙利算法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
8.8.2 染色法判定二分图.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
8.9 网络流 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
8.9.1 最大流 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
8.9.1.1 Edmonds-Karp.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
8.9.2 费用流 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
8.9.2.1 最小费用最大流.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
9 杂项 207
9.1 离散化 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
9.1.1 离散化-区间和.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
9.2 数字和为 sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
9.2.1 01.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
9.3 随机化 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
9.3.1 模拟退火 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
9.3.1.1 模拟退火求函数值.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
9.3.2 mt19937.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
9.3.3 shuffle.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
9.3.4 随机字符串.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
9.3.5 随机数.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
9.3.6 随机选择算法.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
9.4 悬线法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
9.4.1 直方图中最大矩形.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
9.5 约瑟夫环 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
9.5.1 约瑟夫环.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
10 计算几何 213
10.1 模板 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
10.1.1 template.cpp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
Nanchang university ACM template 第 1 页 1 语言基础
1.1 封装
1.1.1 头文件.cpp
1 #include <bits/stdc++.h>
2 using namespace std;
3 typedef long long ll;
4 typedef unsigned long long ull;
5 typedef pair<int, int> PII;
6 typedef pair<int, PII> PIII;
7 #define bug printf("<‐‐>\n");
8 #define lowbit(x) ((x) & ‐(x)) // lowbit(ob0100) = 4 9 #define _max(a, b) (a > b ? a : b)
10 #define _min(a, b) (a < b ? a : b)
11 #define NEXTLINE puts("");
12 #define pb push_back
13 #define LINF LLONG_MAX
14 #define IOS ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
15 #define p(x) printf("‐‐ %d\n", (x));
16 #define x first
17 #define y second
18 // #define int long long
19 // const int maxp = 1010; //点的数量
20 // const int maxn = <++>;
21 const int INF = 0x3f3f3f3f;
22 const ll INF_LL = 0x3f3f3f3f3f3f3f3fLL;
23 // 上 右 下 左 上左 上右 下右 下左
24 const int dx[] = {‐1, 0, 1, 0, ‐1, ‐1, 1, 1};
25 const int dy[] = {0, 1, 0, ‐1, ‐1, 1, 1, ‐1};
26 const double PI = acos(‐1.0);
27 const double eps = 1e‐6;
28 const double gold = (1 + sqrt(5)) / 2; //黄金分割 = 1.61803398...
29 const int FACT[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
30 priority_queue<int, vector<int>, less<int>> he; /*默认是less，即数字大的优先级高*/
31 priority_queue<int, vector<int>, greater<int>> hE; /*默认是less，即数字大的优先级高*/
32
33 void clear(queue<int>& q) {
34 queue<int> empty;
35 swap(empty, q);
36 }
37
38 inline int sigma(char c) {return c ‐ 'a';};
39
40 inline int sgn(double x) { // 判断x是否等于0
41 if (fabs(x) < eps) return 0;
42 else return x < 0 ? ‐1 : 1;
43 }
44
45 inline int dcmp(double x, double y) { //比较两个浮点数：0 相等；‐1 小于；1 大于
46 if (fabs(x ‐ y) < eps) return 0;
47 else return x < y ? ‐1 : 1;
48 }
49
50 struct Point {
51 double x, y;
52 Point() {}
53 Point(double _x, double _y): x(_x), y(_y) {}
54 bool operator == (const Point _point) {return sgn(x ‐ _point.x) == 0 && sgn(y ‐ _point.y) == 0;}
55 };
56
57 inline double dis(Point p1, Point p2) {return hypot(p1.x‐p2.x, p1.y‐p2.y);}
58
59 template <typename T>
60 T Smax(T x) {return x;}
61 template<typename T, typename... Args>
62 T Smax(T a, Args... args) {
63 return _max(a, Smax(args...));
64 }
Nanchang university ACM template 第 2 页
65 template <typename T>
66 T Smin(T x) {return x;}
67 template<typename T, typename... Args>
68 T Smin(T a, Args... args) {
69 return _min(a, Smin(args...));
70 }
71
72 void solve() {
73 ;//<++>
74 }
75
76 int main() {
77 // signed main() {
78 #ifndef ONLINE_JUDGE
79 freopen("in.txt", "r", stdin);
80 // freopen("out.txt", "w", stdout);
81 #endif
82 // ios::sync_with_stdio(false);
83 // cin.tie(NULL), cout.tie(NULL);
84 solve();
85 return 0;
86 }
1.1.2 复数.cpp
1 #include <cstdio>
2 struct Complex {
3 double r, i; // 一定注意，使用%f输出 4 Complex() {}
5 Complex(double _r, double _i) : r (_r), i (_i) {}
6 inline void real(const double& x) {r = x;}
7 inline double real() {return r;}
8 inline Complex operator + (const Complex& rhs) const { 9 return Complex (r + rhs.r, i + rhs.i) ;
10 }
11 inline Complex operator ‐ (const Complex& rhs) const {
12 return Complex (r ‐ rhs.r, i ‐ rhs.i);
13 }
14 inline Complex operator * (const Complex& rhs) const {
15 return Complex (r*rhs.r ‐ i*rhs.i, r*rhs.i + i*rhs.r);
16 }
17 inline void operator /= (const double& x) {
18 r /= x, i /= x ;
19 }
20 inline void operator *= (const Complex& rhs) {
21 *this = Complex (r*rhs.r ‐ i*rhs.i, r*rhs.i + i*rhs.r);
22 }
23 inline void operator += (const Complex& rhs) {
24 r += rhs.r, i += rhs.i;
25 }
26 inline Complex conj() { // 共轭复数
27 return Complex (r, ‐i) ;
28 }
29 };
30
31 int main() {
32 Complex c;
33 c.real(10);
34 printf("%f %f\n", c.r, c.i);
35 printf("%f\n", c.real());
36 Complex c1(5, 4);
37 Complex c2(3, 2);
38
39 c1 += c2;
40 printf("%f %f\n", c1.r, c1.i);
41 return 0;
42 }
Nanchang university ACM template 第 3 页
1.2 STL
1.2.1 STL.md
1 # VECTOR
2 ## vector的定义
3 vector翻译为映射，可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器) 45 ```cpp
6 vector<T> vec1; /+创建了vec1+/
7 vector<T> vec2(vec1); /+创建的vec2中包含vec1中所有副本+/
8 vector<T> vec2 = vec1; /+创建的vec2中包含vec1中所有副本+/
9 vector<T> vec3(n, val); /+创建的vec3中包含了n个重复的元素，每个元素的值都是val+/
10 vector<T> vec4(n); /+创建的vec4中包含了n个重复地执行了值初始化的对象+/
11 vector<T> vec5{a, b, c ...}; /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
12 vector<T> vec5 = {a, b, c ...}; /+创建的vec5中包含了初始化个树的对象，每个元素被赋予相应的初始值+/
13 ```
14 ## 常用函数
15 ‐ begin
16 ‐ end
17 ‐ push_back O(1)
18 ‐ pop_back O(1)
19 ‐ size O(1)
20 ‐ clear O(N)
21 ‐ insert(it, x) O(N)
22 ‐ erase O(N)
23 ‐ rbegin
24 ‐ rend
25 ‐ front
26 ‐ back
27 ‐ vec2 = vec1
28 ## 去重
29 ```cpp
30 sort(ys.begin(), ys.end());
31 ys.erase(unique(ys.begin(), ye.end()), ys.end());
32 ```
33 # STRING
34 ## 字符串的输入输出
35 ‐ string的输入输出
36 + cin遇到空格或换行停止输入
37 + getline(cin, str)是iostream中一个独立的函数，遇到换行结束输入
38 + str.c_str将string类型转换为字符数组进行输出
39 + cin.get与cin.getline是cin的成员，不能完成string类型变量的输入
40 ## 常用函数
41 ‐ operator string字符串可以与ch字符之间进行operator运算
42 ‐ size O(1)
43 ‐ length O(1)
44 ‐ insert O(1)
45 + insert(pos, str)
46 + insert(str1_it, str2_begin, str2_end)
47 ‐ erase O(N)
48 + erase(it)
49 + erase(first, last)
50 + erase(pos, length)
51 ‐ clear O(1)
52 ‐ substr(pos, len) O(len)
53 ‐ string::npos 是一个常数，其本身的值为‐1，但由于是unsigned_int类型，因此实际上也可以认为是unsigned_int类型的最大值
54 + string::npos用以作为find函数失配时的返回值
55 ‐ find O(nm)
56 + str1.find(str2)
57 + str1.find(str2, pos)
58 + 查询不到返回string::npos
59 ‐ replace O(str1.length())
60 + str1.replace(pos, len, str2)，把str从pos位开始，长度为len的子串替换为str2
61 + str1.replace(it_begin, it_end, str2)，把str的迭代器[it_begin, it_end)范围内的子串替换为str2
62 # SET
63 ## 常用函数
64 ‐ count 判断元素是否在集合set中，存在返回1个，不存在返回0个
65 ‐ insert O(logN)
66 ‐ find O(logN) 没找到返回st.end()
Nanchang university ACM template 第 4 页
67 ‐ erase
68 + st.erase(it) O(1)
69 + st.erase(val) O(logN)
70 + st.erase(first, last) O(last ‐ first)
71 ‐ size O(1)
72 ‐ clear O(N)
73 ‐ lower_bound :: st.lower_bound(key)，返回set中第一个大于等于key的迭代器指针
74 ‐ upper_bound :: st.upper_bound(key)，返回set中第一个大于key的迭代器指针
75 ## 注意！
76 ‐ set容器只能通过迭代器访问
77 ```cpp
78 for (std::set<int>::iterator it = st.begin(); it != st.end(); ++ it)
79 printf("%d\n", *it);
80 ```
81 # MAP
82 ## 常用函数
83 ‐ begin
84 ‐ end
85 ‐ find O(logN) 没有找到返回mp.end()
86 ‐ mp.insert(make_pair(1, 2))
87 ‐ erase
88 + mp.erase(it) O(1)
89 + mp.erase(key) O(logN)
90 + mp.erase(first, last) O(last ‐ first)
91 ‐ size O(1)
92 ‐ clear O(N)
93 ‐ empty
94 ‐ lower_bound map :: mp.lower_bound(key)，返回map中第一个大于等于key的迭代器指针
95 ‐ upper_bound map :: mp.upper_bound(key)，返回map中第一个大于key的迭代器指针
96 ## 注意！
97 ‐ 字符串到整型的映射，必须使用string而不能使用char数组
98 ‐ map使用erase函数时需要预先将迭代器后移
99 ‐ map新建一个的初始值为0
100 # QUEUE
101 ## 常用函数
102 ‐ quu.count(1) 在队列中找1的个数
103 ‐ push O(1)
104 ‐ front O(1)
105 ‐ back O(1)
106 ‐ pop O(1)
107 ‐ empty O(1)
108 ‐ size O(1)
109 ## queue清空
110 ### 直接用空的队列对象赋值
111 queue<int> q1;
112 q1 = queue<int>();
113 ### 遍历出队列
114 ```cpp
115 while (!Q.empty()) Q.pop();
116 ```
117 ### 使用swap
118 这种是最高效的，定义clear，保持STL容器的标准
119
120 ```cpp
121 void clear(queue<int>& q) {
122 queue<int> empty;
123 swap(empty, q);
124 }
125 ```
126 ## 注意！
127 ‐ 使用front和pop函数之前必须使用empty函数判断队列是否为空，否则可能因为队空出现错误
128 # PRIORITY_QUEUE
129 ## 默认设置
130 ‐ 默认设置数字的大的是优先级高
131 ‐ 与queue不同的是，priority_queue没有front与back函数，只能使用top函数取队顶
132 ‐ 使用top函数前必须要用empty函数判断优先队列是否为空
133 ## 常用函数
134 ‐ push
135 ‐ top
136 ‐ pop
Nanchang university ACM template 第 5 页
137 ‐ empty
138 ‐ size
139 ## 优先级的设置
140 ```cpp
141 priority_queue<int> pqu;
142 priority_queue<int, vector<int>, less<int>> heap; /*默认是less，大根堆*/
143 priority_queue<int, vector<int>, greater<int>> heap;
144 ```
145 # STACK
146 ## 常用函数
147 ‐ push
148 ‐ top
149 ‐ pop
150 ‐ empty
151 ‐ size
152 # PAIR
153 ## pair容器内元素的访问
154 ‐ pr.first
155 ‐ pr.second
156 ## pair常用函数
157 ‐ mp.insert(make_pair("ABCD", 5));
158 # ALGORITHM
159 ‐ sort
160 ‐ max & min min(x, y) 参数必须是两个，比较三个数，min(x, min(y, z))
161 ‐ reverse(it, it + i) 将数组指针或容器的迭代器在[it, it + i)范围内的元素进行反转
162 ‐ swap(x, y) 交换x, y
163 ‐ abs(x) 返回x的绝对值，x必须是整数，浮点型的绝对值应使用math头文件下的fabs
164 ‐ next_permutation() 给出一个序列在全排列中的下一个序列，在已经到达全排列的最后一个时会返回false
165 ‐ fill 和memset不同，fill()可以把数组或容器中的某一段区间赋为某个相同的值，可以是数组类型对应范围中的任意值
166 ‐ lower_bound :: lower_bound(vec.begin(), vec.end(), val)，第一个大于等于val的值
167 ‐ upper_bound :: upper_bound(vec.begin(), vec.end(), val)，第一个大于val的值
1.3 标准模板库
1.3.1 string.h.md
1 # memset
2 # memcpy
3 # strcat
4 # strcmp
5 # strlen
6 len = strlen(str);
78 # strupr
9 # strlwr
10 # strcpy
1.4 快读
1.4.1 快读快输.cpp
1 #include <cstdio>
2 #include <ctime>
3 inline int read() {
4 int x = 0; bool flag = 1; char ch = getchar();
5 while ((ch<'0' || ch>'9') && ch == '‐') 6 flag = 0, ch = getchar();
7 while (ch >= '0' && ch <= '9') 8 x = (x << 1) + (x << 3) + ch ‐ '0', ch = getchar();
9 return flag ? x : ~(x‐1);
10 }
11
12 inline void write(int x) {
13 if (x<0)
14 x = ~(x‐1), putchar('‐');
15 else if
16 (x > 9) write(x/10);
17 putchar(x%10+'0');
Nanchang university ACM template 第 6 页
18 }
19
20 /*
21 *inline int rwrite(int x)
22 *{
23 * if(x<0) {putchar('‐'); x=~(x‐1);}
24 * int s[20],top=0;
25 * while(x) {s[++top]=x%10; x/=10;}
26 * if(!top) s[++top]=0;
27 * while(top) putchar(s[top‐‐]+'0');
28 *}
29 */
30
31 int main() {
32 clock_t start;
33 clock_t end;
34 start = clock();
35
36 freopen("in.txt", "r", stdin);
37 freopen("out.txt", "w", stdout);
38 int num;
39 for (int i = 0; i < 1e7; ++i) {
40 num = read();
41 write(num);
42 putchar('\n');
43 }
44
45 end = clock();
46 printf("time = %f\n", (double)(end ‐ start) / CLOCKS_PER_SEC);
47 return 0;
48 }
1.4.2 普通读取.cpp
1 #include <cstdio>
2 #include <ctime>
3 int main() {
4 clock_t start;
5 clock_t end;
6 start = clock();
78 freopen("in.txt", "r", stdin);
9 freopen("out.txt", "w", stdout);
10 int num;
11 for (int i = 0; i < 1e7; ++i) {
12 scanf("%d", &num);
13 printf("%d\n", num);
14 }
15
16 end = clock();
17 printf("time = %f\n", (double)(end ‐ start) / CLOCKS_PER_SEC);
18 return 0;
19 }
1.5 重载运算符
1.5.1 重载运算符.cpp
1 #include <cstdio>
2 #include <algorithm>
3 #include <vector>
4 using namespace std;
5 typedef long long ll;
6 int n;
7 ll cnt;
89 struct Node {
Nanchang university ACM template 第 7 页
10 int k, l, r;
11 bool operator < (const Node& w) const {
12 if (k != w.k)
13 return k < w.k;
14 else if (l != w.l)
15 return l < w.l;
16 else
17 return r < w.r;
18 }
19 };
20
21 vector<Node> cols, rows;
22
23 void merge(vector<Node>& segs) {
24 sort(segs.begin(), segs.end());
25 vector<Node> res;
26 int st = ‐2e9, ed = st, k = ‐2e9;
27 for (auto seg : segs) {
28 if (seg.k == k) {
29 if (ed < seg.l) {
30 if (st != ‐2e9) {
31 res.push_back({k, st, ed});
32 cnt += ed ‐ st + 1;
33 }
34 st = seg.l, ed = seg.r;
35 }
36 else
37 ed = max(ed, seg.r);
38 }
39 else {
40 if (st != ‐2e9) {
41 res.push_back({k, st, ed});
42 cnt += ed ‐ st + 1;;
43 }
44 k = seg.k, st = seg.l, ed = seg.r;
45 }
46 }
47
48 if (st != ‐2e9) {
49 res.push_back({k, st, ed});
50 cnt += ed ‐ st + 1;;
51 }
52 segs = res;
53 }
54
55 int main() {
56 scanf("%d", &n);
57 for (int i = 0; i < n; i++) {
58 int x1, y1, x2, y2;
59 scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
60 if (x1 == x2)
61 cols.push_back({x1, min(y1, y2), max(y1, y2)});
62 else
63 rows.push_back({y1, min(x1, x2), max(x1, x2)});
64 }
65
66 merge(rows), merge(cols);
67
68 for (auto row : rows)
69 for (auto col : cols)
70 if (row.k >= col.l && row.k <= col.r && row.r >= col.k && row.l <= col.k)
71 ‐‐cnt;
72
73 printf("%lld\n", cnt);
74 return 0;
75 }
Nanchang university ACM template 第 8 页
1.6 已备函数
1.6.1 二进制-拆为 2 的幂相加.cpp
1 // 创建日期：2021年11月13日 星期六 19时31分00秒 2 #include <cstdio>
3 #include <vector>
4 #define NEXTLINE puts("");
5 using namespace std;
67 // 15 拆成 1 + 2 + 4 + 8 8 vector<int> dividenumtopower2(int num) {
9 vector<int> vec;
10 int b = 1;
11 while (num) {
12 if (num & b) {
13 vec.push_back(b);
14 num ‐= b;
15 }
16 b <<= 1;
17 }
18 return vec;
19 }
20
21 int main() {
22 for (int i = 1; i < 20; ++ i) {
23 vector<int> vec = dividenumtopower2(i);
24 printf("%d:", i);
25 for (auto i : vec)
26 printf(" %d", i);
27 NEXTLINE;
28 }
29 return 0;
30 }
1.6.2 二进制-获取二进制表示中最高比重.cpp
1 // 创建日期：2021年11月13日 星期六 18时35分45秒 2 #include <cstdio>
3 #include <vector>
4 #define lowbit(x) ((x) & ‐(x)) // lowbit(ob0100) = 4 5 #define NEXTLINE puts("");
67 int getmaxproportion(int num) {
8 int b = 1, last = 0, pos = 0;
9 while (num) {
10 if (num & b) {
11 last = b;
12 num ‐= b;
13 }
14 b <<= 1;
15 pos ++ ;
16 }
17 return pos;
18 }
19
20 void outputbinary(int num) {
21 std::vector<int> vec;
22 while (num) {
23 vec.push_back(num % 2);
24 num /= 2;
25 }
26 for (int i = (int)vec.size() ‐ 1; i >= 0; ‐‐ i)
27 printf("%d", vec[i]);
28 NEXTLINE;
29 }
30
31 int main() {
32 for (int i = 1; i < 20; ++ i) {
Nanchang university ACM template 第 9 页
33 printf("%2d %d ", i, getmaxproportion(i));
34 outputbinary(i);
35 }
36 return 0;
37 }
1.6.3 二进制-输出二进制表示.cpp
1 // 创建日期：2021年11月01日 星期一 09时11分42秒 2 #include <cstdio>
3 #include <vector>
4 #define NEXTLINE puts("");
56 void outputbinary(int num) {
7 std::vector<int> vec;
8 while (num) {
9 vec.push_back(num % 2);
10 num /= 2;
11 }
12 for (int i = (int)vec.size() ‐ 1; i >= 0; ‐‐ i)
13 printf("%d", vec[i]);
14 NEXTLINE;
15 }
16
17 int main() {
18 for (int i = 1; i < 20; ++ i)
19 outputbinary(i);
20 return 0;
21 }
1.7 PY
1.7.1 初始化列表.md
1 # 一维
23 ```python
4 list1 = range(10)
5 # list1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
67 list2 = [0] * 5
8 # list2 = [0, 0, 0, 0, 0]
9
10 list3 = [1 for i in range(5)]
11 # list3 = [1, 1, 1, 1, 1]
12 ```
13
14 # 二维
15
16 ```python
17 multilist1 = [[0 for col in range(5)] for row in range(6)]
18 # multilist1 = [
19 # [0, 0, 0, 0, 0],
20 # [0, 0, 0, 0, 0],
21 # [0, 0, 0, 0, 0],
22 # [0, 0, 0, 0, 0],
23 # [0, 0, 0, 0, 0],
24 # [0, 0, 0, 0, 0]
25 # ]
26
27 multilist2 = [[0] * 5 for row in range(6)]
28 # multilist2 = [
29 # [0, 0, 0, 0, 0],
30 # [0, 0, 0, 0, 0],
31 # [0, 0, 0, 0, 0],
32 # [0, 0, 0, 0, 0],
33 # [0, 0, 0, 0, 0],
Nanchang university ACM template 第 10 页
34 # [0, 0, 0, 0, 0]
35 # ]
36 ```
1.8 数学
1.8.1 math.md
1 1. 坐标旋转
2 x' = x * cos(t) ‐ y * sin(t); 3 y' = x * sin(t) + y * cos(t);
1.9 语法基础
1.9.1 函数返回数组.cpp
1 #include <stdio.h>
2 #include <stdlib.h>
3 #include <time.h>
45 /* 要生成和返回随机数的函数 */
6 int * getRandom( ) {
7 static int r[10];
89 for (int i = 0; i < 10; ++ i) {
10 r[i] = rand();
11 printf( "r[%d] = %d\n", i, r[i]);
12
13 }
14 return r;
15 }
16
17 int main () {
18 int *p;
19 p = getRandom();
20
21 for (int i = 0; i < 10; i++ )
22 printf( "*(p + %d) : %d\n", i, *(p + i));
23 return 0;
24 }2 基本算法
2.1 递归 and 分治
2.1.1 递归实现指数型枚举
2.1.1.1 递归-vector.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年05月11日 ‐‐‐‐ 15时10分 5 * 题 目：AcWing 92 递归实现指数型枚举 6 * 算 法：递归 7 * 描 述：从 [1, n]这n（n < 20）个整数中随机选取任意多个 8 * 输出所有可能的选择方案，每个方案的数按升序输出 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <vector>
14 using namespace std;
15 int n;
16 vector<int> vec;
17
18 void DFS(int x) {
Nanchang university ACM template 第 11 页
19 if (x == n + 1) {
20 for (auto i : vec)
21 printf("%d ", i);
22 puts("");
23 return;
24 }
25 DFS(x + 1); // 不选择 x
26 vec.push_back(x); // 选择 x
27 DFS(x + 1); // 选择 x
28 vec.pop_back(); // 回溯
29 }
30
31 int main() {
32 scanf("%d", &n);
33 DFS(1); // 决策数字1
34 return 0;
35 }
2.1.1.2 递归-used 数组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年05月11日 ‐‐‐‐ 15时10分 5 * 题 目：AcWing 92 递归实现指数型枚举 6 * 算 法：递归 7 * 描 述：从 [1, n]这n（n < 20）个整数中随机选取任意多个 8 * 输出所有可能的选择方案，每个方案的数按升序输出 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 const int maxn = 20;
14 int n;
15 bool used[maxn];
16
17 void DFS(int x) {
18 if (x == n + 1) {
19 for (int i = 1; i <= n; ++ i)
20 if (used[i])
21 printf("%d ", i);
22 puts("");
23 return;
24 }
25 DFS(x + 1);
26 used[x] = true;
27 DFS(x + 1);
28 used[x] = false;
29 }
30
31 int main() {
32 scanf("%d", &n);
33 DFS(1);
34 return 0;
35 }
2.1.1.3 递归-状压.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年05月11日 ‐‐‐‐ 15时10分 5 * 题 目：AcWing 92 递归实现指数型枚举 6 * 算 法：递归 7 * 描 述：从1~n这n(n < 20)个整数中随机选取任意多个，输出所有可能的选择方案 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
Nanchang university ACM template 第 12 页
11 #include <cstdio>
12 int n;
13
14 void DFS(int u, int state) {
15 if (u == n) {
16 for (int i = 0; i < n; ++ i)
17 if (state >> i & 1)
18 printf("%d ", i + 1);
19 puts("");
20 return;
21 }
22 DFS(u + 1, state); // 不选
23 DFS(u + 1, state | 1 << u); // 选
24 }
25
26 int main() {
27 scanf("%d", &n);
28 DFS(0, 0);
29 return 0;
30 }
2.1.2 递归实现组合型枚举
2.1.2.1 简单递归-path 数组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年05月11日 星期二 21时00分48秒 5 * 题 目：AcWing 93 递归组合型枚举 6 * 算 法：递归，二进制状态压缩 7 * 描 述：从 [1, n] 这 n 个整数中选择 m 个，输出所有可能的方案数 8 * 对于不同的方案，字典序小的方案先输出 9 * 对于每个方案，升序输出
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 const int maxn = 30;
15 int n, m;
16 int path[maxn];
17
18 // start 表示接下来从哪里开始搜索
19 // cnt 表示已经选择了几个数
20 void DFS(int start, int cnt) {
21 if (cnt == m + 1) {
22 for (int i = 1; i <= m; ++ i)
23 printf("%d ", path[i]);
24 puts("");
25 }
26 else {
27 for (int i = start; i <= n; ++ i) {
28 path[cnt] = i;
29 DFS(i + 1, cnt + 1);
30 }
31 }
32 }
33
34 int main() {
35 scanf("%d %d", &n, &m);
36 DFS(1, 1);
37 return 0;
38 }
2.1.2.2 递归 + 状压.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
Nanchang university ACM template 第 13 页 4 * 创建日期：2021年05月11日 星期二 21时00分48秒 5 * 题 目：AcWing 93 递归组合型枚举 6 * 算 法：递归，二进制状态压缩 7 * 描 述：从 [1, n] 这 n 个整数中选择 m 个，输出所有可能的方案数 8 * 对于不同的方案，字典序小的方案先输出 9 * 对于每个方案，升序输出
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 int n, m;
15
16 void DFS(int start, int cnt, int state) {
17 if (n ‐ start + cnt < m) // 剪枝
18 return;
19 if (cnt == m) {
20 for (int i = 0; i < n; ++ i)
21 if (state >> i & 1)
22 printf("%d ", i + 1);
23 puts("");
24 return;
25 }
26
27 // 下面两句反过来试试？
28 DFS(start + 1, cnt + 1, state | 1 << start);
29 DFS(start + 1, cnt, state);
30 }
31
32 int main() {
33 scanf("%d %d", &n, &m);
34 DFS(0, 0, 0);
35 return 0;
36 }
2.1.2.3 非递归 + 手动写栈.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02.cpp
4 * 创建日期：2021年05月11日 星期二 21时42分25秒 5 * 题 目：AcWing 93 递归组合型枚举 6 * 算 法：非递归，二进制状态压缩 7 * 描 述：不使用递归 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <stack>
13 using namespace std;
14 int n, m;
15
16 struct State {
17 int pos;
18 int start, cnt, state;
19 };
20
21 void DFS(int start, int cnt, int state) {
22 // 0:
23 if (n ‐ start + cnt < m)
24 return;
25 if (cnt == m) {
26 for (int i = 0; i < n; ++ i)
27 if (state >> i & 1)
28 printf("%d ", i + 1);
29 puts("");
30 return;
31 }
32 DFS(start + 1, cnt + 1, state | 1 << start);
33 // 1:
Nanchang university ACM template 第 14 页
34 DFS(start + 1, cnt, state);
35 // 2:
36 }
37
38 int main() {
39 scanf("%d %d", &n, &m);
40 stack<State> stk;
41 stk.push({0, 0, 0, 0});
42 while (stk.size()) {
43 auto sta = stk.top(); stk.pop();
44 if (sta.pos == 0) {
45 if (n ‐ sta.start + sta.cnt < m)
46 continue;
47 if (sta.cnt == m) {
48 for (int i = 0; i < n; ++ i)
49 if (sta.state >> i & 1)
50 printf("%d ", i + 1);
51 puts("");
52 continue;
53 }
54 sta.pos = 1; stk.push(sta);
55 stk.push({0, sta.start + 1, sta.cnt + 1, sta.state | 1 << sta.start});
56 }
57 else if (sta.pos == 1) {
58 sta.pos = 2; stk.push(sta);
59 stk.push({0, sta.start + 1, sta.cnt, sta.state});
60 }
61 else if (sta.pos == 2) {
62 continue;
63 }
64 }
65 return 0;
66 }
2.1.3 递归实现排列型枚举
2.1.3.1 经典全排列.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐全排列.cpp
4 * 创建日期：2021年05月12日 星期三 13时44分31秒 5 * 题 目：AcWing 0094 递归实现排列型枚举 6 * 算 法：递归 7 * 描 述：输出 [1, n] 这 n 个数所有可能的排列，不同排列按字典序 8 * 较小的先输出 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 const int maxn = 10;
14 int n, site[maxn], ha[maxn];
15
16 void DFS(int idx) {
17 if (idx == n + 1) {
18 for (int i = 1; i <= n; ++ i)
19 printf("%d ", site[i]);
20 puts("");
21 return;
22 }
23 for (int i = 1; i <= n; ++ i) {
24 if (!ha[i]) {
25 site[idx] = i;
26 ha[i] = true;
27 DFS(idx + 1);
28 ha[i] = false;
29 }
30 }
31 }
32
Nanchang university ACM template 第 15 页
33 int main() {
34 scanf("%d", &n);
35 DFS(1);
36 return 0;
37 }
2.1.3.2 swap.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐全排列.cpp
4 * 创建日期：2021年05月12日 星期三 13时44分31秒 5 * 题 目：AcWing 0094 递归实现排列型枚举 6 * 算 法：递归 7 * 描 述：输出 [1, n] 这 n 个数所有可能的排列，不同排列按字典序 8 * 较小的先输出 9 *
10 * 不是很理解
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <algorithm>
16 using namespace std;
17 const int maxn = 10;
18 int n, cnt, arr[maxn];
19
20 void DFS(int idx) {
21 if (idx == n) {
22 for (int i = 0; i < n; ++ i)
23 printf("%d ", arr[i]);
24 puts("");
25 return;
26 }
27 for (int i = idx; i < n; ++ i) {
28 swap(arr[i], arr[idx]);
29 DFS(idx + 1);
30 swap(arr[i], arr[idx]);
31 }
32 }
33
34 int main() {
35 scanf("%d", &n);
36 for (int i = 0; i < n; ++ i)
37 arr[i] = i + 1;
38 DFS(0);
39 return 0;
40 }
2.1.3.3 递归全排列 + 状压.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐全排列.cpp
4 * 创建日期：2021年05月12日 星期三 13时44分31秒 5 * 题 目：AcWing 0094 递归实现排列型枚举 6 * 算 法：递归 7 * 描 述：输出 [1, n] 这 n 个数所有可能的排列，不同排列按字典序 8 * 较小的先输出 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <vector>
14 using namespace std;
15 int n;
16 vector<int> vec;
17
Nanchang university ACM template 第 16 页
18 void DFS(int idx, int state) {
19 if (idx == n) {
20 for (auto i : vec)
21 printf("%d ", i);
22 puts("");
23 return;
24 }
25 for (int i = 0; i < n; ++ i)
26 if (!(state >> i & 1)) {
27 vec.push_back(i + 1);
28 DFS(idx + 1, state | 1 << i);
29 vec.pop_back();
30 }
31 }
32
33 int main() {
34 scanf("%d", &n);
35 DFS(0, 0);
36 return 0;
37 }
2.2 贪心
2.2.1 区间合并
2.2.1.1 区间合并.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐lhr.cpp
4 * 创建日期：2021年10月27日 星期三 22时32分21秒 5 * 题 目：AcWing 0803 区间合并 6 * 算 法：区间合并 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <vector>
13 #include <utility>
14 #include <algorithm>
15 using namespace std;
16 typedef pair<int, int> PII;
17 #define bug printf("<‐‐>\n");
18 const int INF = 0x3f3f3f3f;
19 vector<PII> segs; // pair在C++中优先以左端点排序
20 // segment, section, sequence
21 // const int maxn = 1e5 + 5;
22
23 // 将含有交集的区间合并[1, 5] [4, 8] ‐‐> [1, 8]
24 void merge(vector<PII> &segs) {
25 // for循环无法将最后一个区间添加到结果容器中
26 // 加上这一句，就可以使最后一个区间添加到结果容器中
27 segs.push_back({INF, INF});
28 vector<PII> res;
29 sort(segs.begin(), segs.end());
30 int st = segs[0].first,
31 ed = segs[0].second;
32 for (auto seg : segs) {
33 // printf("%d %d\n", seg.first, seg.second);
34 if (ed >= seg.first)
35 ed = max(ed, seg.second);
36 else {
37 res.push_back({st, ed});
38 st = seg.first,
39 ed = seg.second;
40 }
41 }
42 segs = res;
43 }
Nanchang university ACM template 第 17 页
44
45 int main() {
46 #ifndef ONLINE_JUDGE
47 freopen("in.txt", "r", stdin);
48 #endif
49 int n;
50 scanf("%d", &n);
51 for (int i = 0; i < n; ++i) {
52 int l, r;
53 scanf("%d %d", &l, &r);
54 segs.push_back({l, r});
55 }
56 merge(segs);
57 printf("%d\n", (int)segs.size());
58 /*
59 * for (auto seg : segs)
60 * printf("%d %d\n", seg.first, seg.second);
61 */
62 return 0;
63 }
2.2.2 均分纸牌
2.2.2.1 均分纸牌.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年06月02日 星期三 10时16分59秒 5 * 题 目：AcWing 1536 均分纸牌 6 * 算 法：<++>
7 * 描 述：人都给我看傻了，太顶了 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 100 + 5;
13 int card[maxn];
14 int n, sum, res;
15
16 int main() {
17 scanf("%d", &n);
18 for(int i = 0; i < n; i++) {
19 scanf("%d", &card[i]);
20 sum += card[i];
21 }
22
23 int avg = sum / n;
24
25 for (int i = 0; i < n; i++)
26 if (card[i] != avg)
27 card[i + 1] += card[i] ‐ avg,
28 res++;
29
30 printf("%d\n", res);
31 return 0;
32 }
2.2.3 糖果传递
2.2.3.1 七夕祭.cpp
1 #include <cstdio>
2 #include <algorithm>
3 using namespace std;
4 const int maxn = 1e5 + 5;
5 typedef long long ll;
6 int x[maxn], y[maxn];
7
Nanchang university ACM template 第 18 页 8 //下标从1开始 9 ll solve(int I[], int n) {
10 ll avg = 0;
11 for (int i = 1; i <= n; ++i)
12 avg += I[i];
13 avg /= n;
14
15 int x[maxn];
16 x[1] = 0;
17 for (int i = 2; i <= n; ++i)
18 x[i] = x[i‐1] + avg ‐ I[i];
19
20 sort(x + 1, x + n + 1);
21 ll x1 = x[n / 2]; //中位数
22 ll res = 0;
23 for (int i = 1; i <= n; ++i)
24 res += abs(x[i] ‐ x1);
25 return res;
26 }
27
28 int main() {
29 int n, m, t;
30 scanf("%d %d %d", &n, &m, &t);
31 ll sumx = 0, sumy = 0;
32 while (t‐‐) {
33 int ix, iy;
34 scanf("%d %d", &ix, &iy);
35 x[ix]++, y[iy]++;
36 sumx++, sumy++;
37 }
38 if (sumx % n && !(sumy % m))
39 printf("column %lld\n", solve(y, m));
40 else if (!(sumx % n) && sumy % m)
41 printf("row %lld\n", solve(x, n));
42 else if (!(sumx % n) && !(sumy % m))
43 printf("both %lld\n", solve(x, n) + solve(y, m));
44 else
45 printf("impossible\n");
46 return 0;
47 }
2.2.3.2 糖果传递.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02.cpp
4 * 创建日期：2021年06月02日 星期三 17时14分12秒 5 * 题 目：AcWing 0122 糖果传递 6 * 算 法：推公式 7 * 描 述：自己推了一遍，这个题目很好的，建议搞懂 8 * a1 ‐‐x1‐> a2 ‐‐x2‐> a3 ‐‐x3‐> a4 ... an
9 * ^ |
10 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐xn‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
11 *
12 * 公式：x1 = x1
13 * x2 = abs(x1 ‐ (avg ‐ a2))
14 * x3 = abs(x1 ‐ (2* avg ‐ (a2 + a3))
15 * x4 = abs(x1 ‐ (3* avg ‐ (a2 + a3 + a4))
16 * x5 = abs(x1 ‐ (4* avg ‐ (a2 + a3 + a4 + a5))
17 * ......
18 *
19 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
20
21 #include <cstdio>
22 #include <algorithm>
23 using namespace std;
24 const int maxn = 1e6 + 5;
25 typedef long long ll;
26 int n;
Nanchang university ACM template 第 19 页
27 ll I[maxn], x[maxn];
28
29 int main() {
30 scanf("%d", &n);
31 ll sum = 0;
32 for (int i = 1; i <= n; ++i) {
33 scanf("%lld", &I[i]);
34 sum += I[i];
35 }
36 int avg = sum / n;
37 x[1] = 0;
38 for (int i = 2; i <= n; ++i)
39 x[i] = x[i‐1] + avg ‐ I[i];
40
41 sort(x + 1, x + n + 1);
42 ll x1 = x[n / 2];
43 ll res = 0;
44 for (int i = 1; i <= n; ++i)
45 res += abs(x[i] ‐ x1);
46 printf("%lld\n", res);
47 return 0;
48 }
2.2.4 区间贪心
2.2.4.1 区间分组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间分组.cpp
4 * 创建日期：2021年11月02日 星期二 22时09分42秒 5 * 题 目：AcWing 0906 区间分组 6 * 算 法：区间贪心 7 * 描 述：给定 n 个区间，请你将这些区间分成若干组，使得每组内部 8 * 的区间两两之间（包括端点）没有交集，并使得组数尽可能小 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 #include <queue>
15 using namespace std;
16 const int maxn = 1e5 + 5;
17
18 struct Range {
19 int l, r;
20 bool operator < (const Range R) const {
21 return l < R.l;
22 }
23 } range[maxn];
24
25 int main() {
26 int n; scanf("%d", &n);
27 for (int i = 0; i < n; ++ i)
28 scanf("%d %d", &range[i].l, &range[i].r);
29 sort(range, range + n);
30 // 小根堆，存放的是每组里最右端点
31 priority_queue<int, vector<int>, greater<int>> heap;
32 for (int i = 0; i < n; ++ i) {
33 if (heap.empty() || heap.top() >= range[i].l)
34 heap.push(range[i].r);
35 else {
36 // int t = heap.top();
37 heap.pop();
38 heap.push(range[i].r);
39 }
40 }
41 printf("%d\n", heap.size());
42 return 0;
43 }
Nanchang university ACM template 第 20 页
2.2.4.2 区间覆盖.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间覆盖.cpp
4 * 创建日期：2021年11月02日 星期二 20时32分26秒 5 * 题 目：AcWing 0907 区间覆盖 6 * 算 法：区间贪心 7 * 描 述：给定 n 个区间 [li, ri]，以及一个线段区间 [st, ed]，请你 8 * 选择尽量少的区间，将指定线段区间完全覆盖，输出最少区间数，如果 9 * 无法完全覆盖则输出 ‐1
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 1e5 + 5;
17 const int INF = 0x3f3f3f3f;
18
19 struct Range {
20 int l, r;
21 bool operator < (const Range &R) const {
22 return l < R.l;
23 }
24 } range[maxn];
25
26 int main() {
27 int st, ed;
28 scanf("%d %d", &st, &ed);
29 int n; scanf("%d", &n);
30 for (int i = 0; i < n; ++ i)
31 scanf("%d %d", &range[i].l, &range[i].r);
32 sort(range, range + n);
33 int res = 0;
34 bool success = false;
35 for (int i = 0; i < n; ++ i) {
36 int j = i, r = ‐INF;
37 // 左端点小于 st，右端点最大是 r
38 while (j < n && range[j].l <= st) {
39 r = max(r, range[j].r);
40 j ++ ;
41 }
42 if (r < st)
43 break;
44 res ++ ;
45 if (r >= ed) {
46 success = true;
47 break;
48 }
49 st = r;
50 i = j ‐ 1;
51 }
52 if (!success)
53 res = ‐1;
54 printf("%d\n", res);
55 return 0;
56 }
2.2.4.3 区间选点.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间选点.cpp
4 * 创建日期：2021年11月02日 星期二 14时16分53秒 5 * 题 目：AcWing 0905 区间选点
Nanchang university ACM template 第 21 页 6 * 算 法：贪心 区间问题 7 * 描 述：给定 n 个区间 li, ri，请你在数轴上选择尽量少的点，使得 8 * 每个区间内至少包含一个选出的点，输出选择的点的最小数量。
9 * 位于区间端点上的点也算作区间内。
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 /**
14 * |‐‐‐‐‐‐‐‐‐‐‐| |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
15 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐x‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐x‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐>
16 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐| |‐‐‐‐‐‐‐‐|
17 * |‐‐‐‐‐‐|
18 */
19
20 #include <cstdio>
21 #include <algorithm>
22 using namespace std;
23 int n;
24 const int maxn = 1e5 + 5;
25 const int INF = 0x3f3f3f3f;
26
27 struct Range {
28 int l, r;
29 bool operator < (const Range &R) const {
30 return r < R.r;
31 }
32 } range[maxn];
33
34 int main() {
35 scanf("%d", &n);
36 for (int i = 0; i < n; ++ i) {
37 int l, r;
38 scanf("%d %d", &l, &r);
39 range[i] = {l, r};
40 }
41 sort(range, range + n);
42 int res = 0, ed = ‐INF;
43 for (int i = 0; i < n; ++ i)
44 if (range[i].l > ed) {
45 res ++ ;
46 ed = range[i].r;
47 }
48 printf("%d\n", res);
49 return 0;
50 }
2.2.4.4 最大不相交区间数量.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最大不相交区间数量.cpp
4 * 创建日期：2021年11月02日 星期二 19时46分23秒 5 * 题 目：AcWing 0908 最大不相交区间数量 6 * 算 法：区间贪心 7 * 描 述：给定 n 个区间 li, ri，请你在数轴上选择若干个区间，
8 * 使得选中的区间之间互不相交（包括端点）。输出可选区间的最大数量。
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1e5 + 5;
16 const int INF = 0x3f3f3f3f;
17
18 struct Range {
19 int l, r;
20 bool operator < (const Range & R) const {
21 return r < R.r;
Nanchang university ACM template 第 22 页
22 }
23 } range[maxn];
24
25 int main() {
26 int n; scanf("%d", &n);
27 for (int i = 0; i < n; ++ i)
28 scanf("%d %d", &range[i].l, &range[i].r);
29 sort(range, range + n);
30 int res = 0, ed = ‐INF;
31 for (int i = 0; i < n; ++ i)
32 if (range[i].l > ed) {
33 res ++ ;
34 ed = range[i].r;
35 }
36 printf("%d\n", res);
37 return 0;
38 }
2.2.5 哈夫曼编码
2.2.5.1 合并果子.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：合并果子.cpp
4 * 创建日期：2021年11月02日 星期二 22时37分15秒 5 * 题 目：AcWing 00148 合并果子 6 * 算 法：哈夫曼编码 7 * 描 述：把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和 8 * 输出最小消耗的体力。
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <queue>
14 using namespace std;
15
16 int main() {
17 int n; scanf("%d", &n);
18 priority_queue<int, vector<int>, greater<int>> heap;
19 for (int i = 0; i < n; ++ i) {
20 int weight; scanf("%d", &weight);
21 heap.push(weight);
22 }
23 int res = 0;
24 while (heap.size() > 1) {
25 int a = heap.top(); heap.pop();
26 int b = heap.top(); heap.pop();
27 res += a + b;
28 heap.push(a + b);
29 }
30 printf("%d\n", res);
31 return 0;
32 }
2.2.6 排序不等式
2.2.6.1 排队打水.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：排队打水.cpp
4 * 创建日期：2021年11月02日 星期二 23时49分52秒 5 * 题 目：AcWing 0913 排队打水 6 * 算 法：排序不等式 7 * 描 述：有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶 8 * 所需时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间 9 * 之和最小
10 *
Nanchang university ACM template 第 23 页
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <algorithm>
15 using namespace std;
16 typedef long long ll;
17 const int maxn = 1e5 + 5;
18 int t[maxn];
19
20 int main() {
21 int n; scanf("%d", &n);
22 for (int i = 0; i < n; ++ i)
23 scanf("%d", &t[i]);
24 sort(t, t + n);
25 ll res = 0;
26 for (int i = 0; i < n; ++ i)
27 res += t[i] * (n ‐ i ‐ 1);
28 printf("%lld\n", res);
29 return 0;
30 }
2.2.7 绝对值不等式
2.2.7.1 货仓选址.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：货仓选址.cpp
4 * 创建日期：2021年11月03日 星期三 20时29分32秒 5 * 题 目：AcWing 0104 货仓选址 6 * 算 法：贪心 7 * 描 述：在一条数轴上有 n 家商店，它们的坐标是 ai
8 * 现在需要在数轴上建立一家货仓，货仓建在哪里可以使得货仓到每家 9 * 商店的距离之和最小
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 1e5 + 5;
17 int a[maxn];
18
19 int main() {
20 int n; scanf("%d", &n);
21 for (int i = 0; i < n; ++ i)
22 scanf("%d", &a[i]);
23 sort(a, a + n);
24 int res = 0;
25 for (int i = 0; i < n; ++ i)
26 res += abs(a[i] ‐ a[n / 2]);
27 printf("%d\n", res);
28 return 0;
29 }
2.2.8 推公式
2.2.8.1 刷杂技的牛.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：刷杂技的牛.cpp
4 * 创建日期：2021年11月03日 星期三 20时33分53秒 5 * 题 目：AcWing 0125 刷杂技的牛 6 * 算 法：贪心 7 * 描 述：奶牛学习叠罗汉 8 * 这 n 头奶牛中的每一头都有着自己的重量 wi 以及自己的强壮程度 si。 9 * 这头牛的头上所有牛的总重量（不包括它自己）减去它的身体强壮程度
10 * 的值称为该牛的风险值，风险值越大，这只牛撑不住的可能性越高。
Nanchang university ACM template 第 24 页
11 * 你的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。
12 *
13 * 按 wi + si 从小到大排序
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <algorithm>
19 #include <utility>
20 using namespace std;
21 typedef pair<int, int> PII;
22 const int maxn = 5e4 + 5;
23 const int INF = 0x3f3f3f3f;
24 PII cows[maxn];
25
26 int main() {
27 int n; scanf("%d", &n);
28 for (int i = 0; i < n; ++ i) {
29 int w, s;
30 scanf("%d %d", &w, &s);
31 cows[i] = {w + s, w};
32 }
33 sort(cows, cows + n);
34 int sum = 0, res = ‐INF;
35 for (int i = 0; i < n; ++ i) {
36 int w = cows[i].second,
37 s = cows[i].first ‐ cows[i].second;
38 res = max(res, sum ‐ s);
39 sum += w;
40 }
41 printf("%d\n", res);
42 return 0;
43 }
2.3 排序
2.3.1 选择排序
2.3.1.1 选择排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：selectSort.cpp
4 * 创建日期：2021年08月08日 星期日 23时51分34秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <stdio.h>
12 int num[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
13 int n = 10;
14
15 void selectSort() {
16 int mini, idx;
17 bool flag;
18
19 for (int i = 0; i < n; i++) {
20 flag = false;
21 mini = num[i];
22 idx = i;
23 for (int j = i; j < n; j++)
24 if (num[j] < mini) {
25 flag = true;
26 mini = num[j];
27 idx = j;
28 }
29 if (flag) {
30 num[i] += num[idx];
Nanchang university ACM template 第 25 页
31 num[idx] = num[i] ‐ num[idx];
32 num[i] ‐= num[idx];
33 }
34 }
35 }
36
37 int main() {
38 selectSort();
39 for (int i = 0; i < 10; i++)
40 printf("%d ", num[i]);
41
42 printf("\n");
43 return 0;
44 }
2.3.2 冒泡排序
2.3.2.1 冒泡排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：bubbleSort.cpp
4 * 创建日期：2021年08月08日 星期日 23时51分18秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <stdio.h>
12 int n = 10;
13 int num[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
14
15 void bubbleSort() {
16 for (int i = 0; i < n‐1; ++i)
17 for (int j = n‐1; j > i; ‐‐j)
18 if (num[j] < num[j‐1]) {
19 num[j] += num[j‐1];
20 num[j‐1] = num[j] ‐ num[j‐1];
21 num[j] ‐= num[j‐1];
22 }
23 }
24
25 int main() {
26 bubbleSort();
27 for (int i = 0; i < 10; ++i)
28 printf("%d ", num[i]);
29 printf("\n");
30 return 0;
31 }
2.3.3 插入排序
2.3.3.1 插入排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：insertSort.cpp
4 * 创建日期：2021年08月08日 星期日 23时51分03秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：第i个数往前比较，如果num[i]比num[j]小，就num[j] = num[j ‐ 1]
8 * 因为要给num[i]腾出一个空 9 *
10 * |‐‐‐‐‐‐|
11 * V |
12 * 1 2 3 4 6 7 8 5 9
13 *
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
Nanchang university ACM template 第 26 页
15
16 #include <stdio.h>
17
18 void insertSort(int num[], int n) {
19 // 前i ‐ 1个数已经排好(不是1234这种，是1357这种)，看第i个数插在哪
20 for (int i = 1; i < n; ++ i) {
21 int insertNum = num[i];
22 int j;
23 for (j = i; j >= 1 && insertNum < num[j ‐ 1]; ‐‐ j)
24 num[j] = num[j ‐ 1];
25 num[j] = insertNum;
26 }
27 }
28
29 int main() {
30 int num[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
31 int n = 10;
32 insertSort(num, n);
33 for (int i = 0; i < n; ++ i)
34 printf("%d ", num[i]);
35 printf("\n");
36 return 0;
37 }
2.3.4 快速排序
2.3.4.1 双指针快排.cpp
1 #include <cstdio>
2 #include <cstdlib>
3 #include <ctime>
4 #include <cmath>
5 #include <algorithm>
6 using namespace std;
7 int num[] = {5, 4, 7, 9, 0, 2, 1, 3, 8, 6};
89 int partition(int left, int right) {
10 int random = (int)round(1.0 * rand() / RAND_MAX * (right ‐ left) + left);
11 swap(num[random], num[left]);
12
13 int temp = num[left];
14
15 while (left < right) {
16 while (left < right && num[right] > temp)
17 right‐‐;
18
19 num[left] = num[right];
20
21 while (left < right && num[left] <= temp)
22 left++;
23
24 num[right] = num[left];
25 }
26 num[left] = temp;
27 return left;
28 }
29
30 void quickSort(int left, int right) {
31 if (left < right) {
32 int mark = partition(left, right);
33 quickSort(left, mark ‐ 1);
34 quickSort(mark + 1, right);
35 }
36 }
37
38 int main() {
39 quickSort(0, 9);
40
41 for (int i = 0; i < 10; i++)
42 printf("%d ", num[i]);
Nanchang university ACM template 第 27 页
43 printf("\n");
44
45 return 0;
46 }
2.3.4.2 快速排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：quickSort
4 * 创建日期：2021年05月30日 星期日 00时53分58秒 5 * 题 目：AcWing 0785 快速排序 6 * 算 法：快速排序 7 * 描 述：去看笔记‐首元素做基准 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using namespace std;
14 #define NEXTLINE puts("");
15 int n = 10;
16 int num[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
17
18 void quickSort(int l, int r) {
19 if (l >= r) return;
20
21 int i = l ‐ 1, j = r + 1, x = num[(l + r) >> 1];
22 while (i < j) {
23 do i ++ ; while (num[i] < x);
24 do j ‐‐ ; while (num[j] > x);
25 if (i < j) swap(num[i], num[j]);
26 }
27 quickSort(l, j);
28 quickSort(j + 1, r);
29 }
30
31 int main() {
32 quickSort(0, 9);
33 for (int i = 0; i < n; ++i)
34 printf("%d ", num[i]);
35 NEXTLINE;
36 return 0;
37 }
2.3.4.3 第 k 个数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：05‐第k个数.cpp
4 * 创建日期：2021年08月08日 星期日 23时35分55秒 5 * 题 目：AcWing 0786 第k个数 6 * 算 法：<++>
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <iostream>
12 using namespace std;
13 const int maxn = 1000010;
14 int num[maxn];
15
16 // 从0开始，左闭右闭
17 int quickSort(int l, int r, int k) {
18 if (l >= r) return num[l];
19
20 int i = l ‐ 1, j = r + 1, x = num[l + r >> 1];
21 while (i < j) {
Nanchang university ACM template 第 28 页
22 do i ++ ; while (num[i] < x);
23 do j ‐‐ ; while (num[j] > x);
24 if (i < j) swap(num[i], num[j]);
25 }
26
27 if (j ‐ l + 1 >= k)
28 return quickSort(l, j, k);
29 else
30 return quickSort(j + 1, r, k ‐ (j ‐ l + 1));
31 }
32
33 int main() {
34 int n, k;
35 scanf("%d%d", &n, &k);
36 for (int i = 0; i < n; i ++ )
37 scanf("%d", &num[i]);
38 printf("%d\n", quickSort(0, n‐1, k));
39 return 0;
40 }
2.3.5 归并排序
2.3.5.1 归并排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：mergeSort.cpp
4 * 创建日期：2021年08月08日 星期日 23时51分53秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #define NEXTLINE puts("");
13 int n = 10;
14 int num[] = {6, 3, 8, 9, 4, 1, 5, 0, 2, 7};
15 int tmp[10];
16
17 void mergeSort(int l, int r) {
18 if (l >= r) return;
19
20 int mid = l + r >> 1;
21 mergeSort(l, mid);
22 mergeSort(mid + 1, r);
23
24 // v v
25 // ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
26 int k = 0, i = l, j = mid + 1;
27 while (i <= mid && j <= r)
28 if (num[i] <= num[j])
29 tmp[k++] = num[i++];
30 else
31 tmp[k++] = num[j++];
32
33 while (i <= mid)
34 tmp[k++] = num[i++];
35 while (j <= r)
36 tmp[k++] = num[j++];
37
38 for (i = l, j = 0; i <= r; i++, j++)
39 num[i] = tmp[j];
40 }
41
42 int main() {
43 mergeSort(0, n‐1);
44 for (int i = 0; i < n; ++i)
45 printf("%d ", num[i]);
46 NEXTLINE;
Nanchang university ACM template 第 29 页
47 return 0;
48 }
2.3.5.2 逆序数.cpp
1 #include <cstdio>
2 #define NEXTLINE puts("");
3 const int maxn = 1e5 + 5;
4 int n;
5 int num[maxn];
6 int tmp[maxn];
7 long long inverse;
89 /*
10 * 左半边内部的逆序对数量：merge_sort(L, mid)
11 * 左半边内部的逆序对数量：merge_sort(mid + 1, R)
12 */
13 void mergeSort(int l, int r) {
14 if (l >= r) return;
15
16 int mid = (l + r) >> 1;
17 mergeSort(l, mid);
18 mergeSort(mid + 1, r);
19
20 // v v
21 // ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
22 int k = 0, i = l, j = mid + 1;
23 while (i <= mid && j <= r)
24 if (num[i] <= num[j])
25 tmp[k++] = num[i++];
26 else {
27 tmp[k++] = num[j++];
28 /*
29 * ‐‐‐‐‐‐‐‐i‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
30 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐j‐‐‐‐‐‐‐‐
31 * num[i] > num[j]
32 * 必有num[i+1], num[i+2], ... num[mid] > num[j]
33 * 这些对都是逆序对
34 */
35 inverse += (long long)(mid ‐ i + 1); //只是在归并排序上添加这句
36 }
37
38 while (i <= mid)
39 tmp[k++] = num[i++];
40 while (j <= r)
41 tmp[k++] = num[j++];
42
43 for (i = l, j = 0; i <= r; i++, j++)
44 num[i] = tmp[j];
45 }
46
47 int main() {
48 scanf("%d", &n);
49 for (int i = 0; i < n; ++i)
50 scanf("%d", &num[i]);
51 mergeSort(0, n‐1);
52 /*
53 * for (int i = 0; i < n; ++i)
54 * printf("%d ", num[i]);
55 * NEXTLINE;
56 */
57 printf("%lld\n", inverse);
58 return 0;
59 }
2.3.6 堆排序
2.3.6.1 堆排序.cpp
Nanchang university ACM template 第 30 页 1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：heapSort.cpp
4 * 创建日期：2021年08月08日 星期日 23时42分11秒 5 * 题 目：AcWing 0838 堆排序 6 * 算 法：堆 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 int main() {
13 return 0;
14 }
2.4 前缀和 and 差分
2.4.1 一维前缀和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：一维前缀和.cpp
4 * 创建日期：2021年05月31日 星期一 01时14分51秒 5 * 题 目：AcWing 0795 前缀和 6 * 算 法：前缀和 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 1e5 + 5;
13 int sequ[maxn];
14 int preS[maxn];
15
16 int main() {
17 int n, m;
18 scanf("%d %d", &n, &m);
19 // 前缀和的题目从下标1开始读
20 for (int i = 1; i <= n; ++i)
21 scanf("%d", &sequ[i]);
22 for (int i = 1; i <= n; ++i)
23 preS[i] = preS[i‐1] + sequ[i];
24 while (m‐‐) {
25 int l, r;
26 scanf("%d %d", &l, &r);
27 printf("%d\n", preS[r] ‐ preS[l ‐ 1]);
28 }
29 return 0;
30 }
2.4.2 一维差分.cpp
1 #include <cstdio>
2 #define NEXTLINE puts("");
3 const int maxn = 1e5 + 5;
4 int sequ[maxn];
5 int diff[maxn];
67 int main() {
8 int n, m;
9 scanf("%d %d", &n, &m);
10 for (int i = 1; i <= n; ++i) {
11 scanf("%d", &sequ[i]);
12 diff[i] = sequ[i] ‐ sequ[i‐1];
13 }
14 while (m‐‐) {
15 int l, r, c;
Nanchang university ACM template 第 31 页
16 scanf("%d %d %d", &l, &r, &c);
17 diff[l] += c;
18 diff[r+1] ‐= c;
19 }
20 for (int i = 1; i <= n; ++i)
21 diff[i] += diff[i‐1];
22 for (int i = 1; i <= n; ++i)
23 printf("%d ", diff[i]);
24 NEXTLINE;
25 return 0;
26 }
2.4.3 二维前缀和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：二维前缀和.cpp
4 * 创建日期：2021年05月31日 星期一 11时08分42秒 5 * 题 目：AcWing 0796 子矩阵的和 6 * 算 法：<++>
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using namespace std;
14 const int maxn = 1005;
15 typedef long long ll;
16 int n, m, q;
17 int g[maxn][maxn];
18 ll preS[maxn][maxn];
19
20 int main() {
21 scanf("%d %d %d", &n, &m, &q);
22 for (int i = 1; i <= n; ++i)
23 for (int j = 1; j <= m; ++j) {
24 scanf("%d", &g[i][j]);
25 preS[i][j] = g[i][j] + preS[i‐1][j] + preS[i][j‐1] ‐ preS[i‐1][j‐1];
26 if (len(str) > 6):
27 continue
28 }
29 while (q‐‐) {
30 int x1, y1, x2, y2;
31 scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
32 int minx = min(x1, x2);
33 int miny = min(y1, y2);
34 int maxx = max(x1, x2);
35 int maxy = max(y1, y2);
36 ll res = preS[maxx][maxy] ‐ preS[maxx][miny‐1] ‐ preS[minx‐1][maxy] + preS[minx‐1][miny‐1];
37 printf("%lld\n", res);
38 }
39 return 0;
40 }
41
42
43 /*
44 * 1 7 2 4
45 * 1 4 2 7
46 * 2 7 1 4
47 * 2 4 1 7
48 * tmpx = min(x1, x2);
49 * tmpy = min(y1, y2);
50 *
51 * ‐‐‐‐‐‐o‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
52 * ‐‐‐o‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
53 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
54 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
55 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
Nanchang university ACM template 第 32 页
56 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
57 */
2.4.4 二维差分.cpp
1 #include <cstdio>
2 #define NEXTLINE puts("");
3 const int maxn = 1e3 + 5;
4 int g[maxn][maxn];
5 int diff[maxn][maxn];
6 int n, m, q;
78 void insert(int x1, int y1, int x2, int y2, int c) {
9 diff[x1][y1] += c;
10 diff[x2+1][y1] ‐= c;
11 diff[x1][y2+1] ‐= c;
12 diff[x2+1][y2+1] += c;
13 }
14
15 int main() {
16 scanf("%d %d %d", &n, &m, &q);
17 for (int i = 1; i <= n; ++i)
18 for (int j = 1; j <= m; ++j) {
19 scanf("%d", &g[i][j]);
20 insert(i, j, i, j, g[i][j]);
21 }
22 while (q‐‐) {
23 int x1, y1, x2, y2, c;
24 scanf("%d %d %d %d %d", &x1, &y1, &x2, &y2, &c);
25 insert(x1, y1, x2, y2, c);
26 }
27 for (int i = 1; i <= n; ++i) {
28 for (int j = 1; j <= m; ++j) {
29 diff[i][j] = diff[i][j] + diff[i‐1][j] + diff[i][j‐1] ‐ diff[i‐1][j‐1];
30 printf("%d ", diff[i][j]);
31 }
32 NEXTLINE;
33 }
34 return 0;
35 }
2.4.5 异或前缀和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Color‐Sequence.cpp
4 * 创建日期：2021年10月21日 星期四 09时52分03秒 5 * 题 目：2020 ICPC 江西省大学生程序设计竞赛 6 * 算 法：异或前缀和 7 * 描 述：给定一个颜色序列 8 * 求它有多少个颜色出现次数都是偶数的连续子序列。
9 * 颜色数量不超过 20 种
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <unordered_map>
15 using namespace std;
16 typedef long long ll;
17 const int maxn = 1e6 + 5;
18 int color[maxn], preS[maxn];
19 unordered_map<int, int> ha;
20
21 int main() {
22 int n; scanf("%d", &n);
23 for (int i = 1; i <= n; ++ i) {
24 scanf("%d", &color[i]);
Nanchang university ACM template 第 33 页
25 preS[i] = preS[i ‐ 1] ^ (1 << color[i]); // 异或前缀和
26 }
27 // 现在得到的 preS 数组中存储了一个数
28 // 如果这个数的第 i 位是 0，则表明颜色 i 出现了偶数次
29 ll res = 0;
30 ha[0] = 1; // 这种情况一定是偶数的
31 // 找同值前缀和
32 // 如果 preS[a] == preS[b]，则 str[a ~ b] 是偶数的
33 for (int i = 1; i <= n; ++ i) {
34 res += ha[preS[i]];
35 ++ ha[preS[i]];
36 }
37 printf("%lld\n", res);
38 return 0;
39 }
2.5 二分
2.5.1 整数集合上的二分
2.5.1.1 数的范围.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：lower‐upper‐bound.cpp
4 * 创建日期：2021年08月17日 星期二 13时44分44秒 5 * 题 目：AcWing 0789 数的范围 6 * 算 法：二分 7 * 描 述：对于每个查询，返回一个元素 k 的起始位置和终止位置(从0开始) 8 * 如果数组中不存在该元素，则返回 ‐1 ‐1。 9 * 也就是lowerBound和upperBound
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #define bug printf("<‐‐>\n");
15 const int maxn = 1e5 + 5;
16 int n, q;
17 int num[maxn];
18
19 /*
20 * 找到第一个大于等于val的数：
21 * [l, r] ‐‐> [l, mid], [mid + 1, r]
22 * 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
23 */
24 int lowerBound(int l, int r, int val) {
25 while (l < r) {
26 int mid = (l + r) >> 1;
27 if (num[mid] < val)
28 l = mid + 1;
29 else
30 r = mid;
31 }
32 if (num[l] != val)
33 return ‐1;
34 else
35 return l;
36 }
37
38 /*
39 * 找到第一个小于等于val的数：
40 * [l, r] ‐‐> [l, mid ‐ 1], [mid, r]
41 * 区间[l, r]被划分成[l, mid ‐ 1]和[mid, r]时使用：
42 */
43 int upperBound(int l, int r, int val) {
44 while (l < r) {
45 //这里要加一
46 int mid = (l + r + 1) >> 1;
47 if (num[mid] <= val)
48 l = mid;
Nanchang university ACM template 第 34 页
49 else
50 r = mid ‐ 1;
51 }
52 if (num[l] != val)
53 return ‐1;
54 else
55 return l;
56 }
57
58 int main() {
59 scanf("%d %d", &n, &Q);
60 for (int i = 0; i < n; ++i)
61 scanf("%d", &num[i]);
62 while (Q‐‐) {
63 int val;
64 scanf("%d", &val);
65 int lower = lowerBound(0, n‐1, val);
66 int upper = upperBound(0, n‐1, val);
67 printf("%d %d\n", lower, upper);
68 }
69 return 0;
70 }
2.5.2 实数域上的二分
2.5.2.1 数的三次方根.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐三次方根.cpp
4 * 创建日期：2021年08月17日 星期二 13时50分14秒 5 * 题 目：AcWing 0790 数的三次方根 6 * 算 法：二分 7 * 描 述：给定一个浮点数 n，求它的三次方根，保留6位小数 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const double eps = 1e‐8;
13
14 bool judge(double mid, double n) {
15 if (mid * mid * mid < n)
16 return true;
17 else
18 return false;
19 }
20
21 // 0.001
22 double bsearch_3(double n) {
23 double l = ‐10000, r = 10000;
24 while (r ‐ l > eps) {
25 double mid = (l + r) / 2;
26 if (judge(mid, n))
27 l = mid;
28 else
29 r = mid;
30 }
31 return r;
32 }
33
34 int main() {
35 double n;
36 scanf("%lf", &n);
37 double res = bsearch_3(n);
38 printf("%.6f\n", res);
39 return 0;
40 }
Nanchang university ACM template 第 35 页
2.5.3 二分答案转化为判定
2.5.3.1 根据厚度将书分组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐根据厚度将书分组.cpp
4 * 创建日期：2021年05月28日 星期五 22时43分04秒 5 * 题 目：<++>
6 * 算 法：二分 7 * 描 述：N本书排成一行，第i本厚度是book[i]，把它们分成连续的M组 8 * 使T(厚度最大的一组的厚度)最小，最小值是多少 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 int n = 9, m = 3;
14 int book[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
15
16 //将n本书分成若干组，每组最大厚度不超过size，分成的组数是否小于m
17 bool valid(int size) {
18 int thick = 0;
19 int group = 1; //初始值要为1
20 for (int i = 0; i < n; ++i) {
21 if (size ‐ thick >= book[i])
22 thick += book[i];
23 else {
24 group++;
25 thick = book[i];
26 }
27 }
28 return group <= m;
29 }
30
31 int main() {
32 int sum_thick = 0;
33 for (int i = 0; i < n; ++i)
34 sum_thick += book[i];
35
36 int l = 0, r = sum_thick;
37 while (l < r) {
38 int mid = (l + r) >> 1;
39 if (valid(mid))
40 r = mid;
41 else
42 l = mid + 1;
43 }
44 printf("%d\n", l);
45 return 0;
46 }
2.6 双指针
2.6.1 双指针.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐two‐pointers.cpp
4 * 创建日期：2021年06月05日 星期六 08时00分00秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：有双指针这个算法 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <stdio.h>
12 int main() {
13 int a[] = {0, 1, 2, 3, 4, 5, 6};
14 int M = 8;
15 int i = 1;
Nanchang university ACM template 第 36 页
16 int j = 6;
17 while (i < j) {
18 if (a[i] + a[j] == M)
19 printf("%d %d\n", i++, j‐‐);
20 else if (a[i] + a[j] < M)
21 i++;
22 else
23 j‐‐;
24 }
25 return 0;
26 }3 搜索
3.1 深度优先搜索 (DFS)
3.1.1 n-皇后问题 (1).cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月15日 星期日 12时03分56秒 5 * 题 目：AcWing 0843 n‐皇后问题 6 * 算 法：深度优先搜索 7 * 描 述：使用排列组合的方法解决 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 10;
13 #define NEXTLINE puts("");
14 int n, path[maxn];
15 char g[maxn][maxn];
16 bool col[maxn], dg[2 * maxn], udg[2 * maxn];
17
18 void DFS(int u) {
19 if (u == n) {
20 for (int i = 0; i < n; ++i)
21 printf("%s\n", g[i]);
22 NEXTLINE;
23 return ;
24 }
25 // 第u行第i列
26 for (int i = 0; i < n; ++i)
27 /**
28 * 可以看成一个坐标轴 y = u + i, y = n ‐ u + i;
29 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐>
30 * |
31 * |
32 * |
33 * |
34 * |
35 * |
36 * |
37 * V
38 *
39 */
40 if (!col[i] && !dg[u + i] && !udg[n ‐ u + i]) {
41 g[u][i] = 'Q';
42 col[i] = dg[u + i] = udg[n ‐ u + i] = true; // 列，正对角线，反对角线标记
43 DFS(u + 1);
44 col[i] = dg[u + i] = udg[n ‐ u + i] = false;
45 g[u][i] = '.';
46 }
47 }
48
49 int main() {
50 scanf("%d", &n);
51 for (int i = 0; i < n; ++i)
Nanchang university ACM template 第 37 页
52 for (int j = 0; j < n; ++j)
53 g[i][j] = '.';
54 DFS(0);
55 return 0;
56 }
3.1.2 n-皇后问题 (2).cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：n‐皇后问题(2).cpp
4 * 创建日期：2021年08月15日 星期日 13时18分42秒 5 * 题 目：AcWing 0843 n‐皇后问题 6 * 算 法：深度优先搜索 7 * 描 述：这一种更加的暴力 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 10;
13 #define NEXTLINE puts("");
14 int n;
15 char g[maxn][maxn];
16 bool row[maxn], col[maxn], dg[2 * maxn], udg[2 * maxn];
17
18 void DFS(int x, int y, int s) {
19 if (y == n)
20 y = 0, x ++ ;
21 if (x == n) {
22 if (s == n) {
23 for (int i = 0; i < n; ++i)
24 printf("%s\n", g[i]);
25 NEXTLINE;
26 }
27 return ;
28 }
29 // 不放皇后
30 DFS(x, y + 1, s);
31
32 // 放皇后
33 if (!row[x] && !col[y] && !dg[x + y] && !udg[n ‐ x + y]) {
34 g[x][y] = 'Q';
35 row[x] = col[y] = dg[x + y] = udg[n ‐ x + y] = true;
36 DFS(x, y + 1, s + 1);
37 row[x] = col[y] = dg[x + y] = udg[n ‐ x + y] = false;
38 g[x][y] = '.';
39 }
40 }
41
42 int main() {
43 scanf("%d", &n);
44 for (int i = 0; i < n; ++i)
45 for (int j = 0; j < n; ++j)
46 g[i][j] = '.';
47 DFS(0, 0, 0); // 从左上角开始搜，记录当前有多少个皇后
48 return 0;
49 }
3.1.3 排列数字.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月11日 星期三 11时14分32秒 5 * 题 目：AcWing 0842 排列数字 6 * 算 法：深度优先搜索 7 * 描 述：排列数字，将[1, n]的数字排列
Nanchang university ACM template 第 38 页 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 10;
13 #define NEXTLINE puts("");
14 int path[maxn];
15 bool used[maxn];
16 int n;
17
18 void DFS(int u) {
19 if (u == n) {
20 for (int i = 0; i < n; ++i)
21 printf("%d ", path[i]);
22 NEXTLINE
23 return;
24 }
25 for (int i = 1; i <= n; ++i)
26 if (!used[i]) {
27 path[u] = i;
28 used[i] = true;
29 DFS(u + 1);
30 used[i] = false;
31 }
32 }
33
34 int main() {
35 scanf("%d", &n);
36 DFS(0);
37 return 0;
38 }
3.1.4 搜索顺序
3.1.4.1 马走日.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：马走日.cpp
4 * 创建日期：2021年11月26日 星期五 19时55分53秒 5 * 题 目：AcWing 1116 马走日 6 * 算 法：深度优先搜索 7 * 描 述：在一个棋盘上，给出马的坐标，马可以有多少种途径遍历 8 * 棋盘上的 *所有点* 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 int n, m;
14 const int maxn = 10;
15 int g[maxn][maxn];
16 bool used[maxn][maxn];
17 int res;
18 const int dx[] = {‐1, ‐2, ‐2, ‐1, 1, 2, 2, 1};
19 const int dy[] = {‐2, ‐1, 1, 2, 2, 1, ‐1, ‐2};
20
21 void DFS(int x, int y, int cnt) {
22 if (cnt == n * m) {
23 res ++ ;
24 return;
25 }
26 used[x][y] = true;
27 for (int i = 0; i < 8; ++ i) {
28 int nx = x + dx[i],
29 ny = y + dy[i];
30 if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
31 if (used[nx][ny]) continue;
32 DFS(nx, ny, cnt + 1);
33 }
34 used[x][y] = false;
Nanchang university ACM template 第 39 页
35 }
36
37 int main() {
38 int t; scanf("%d", &t);
39 while (t ‐‐ ) {
40 int x, y;
41 scanf("%d %d %d %d", &n, &m, &x, &y);
42 res = 0;
43 DFS(x, y, 1);
44 printf("%d\n", res);
45 }
46 return 0;
47 }
3.1.5 连通性模型
3.1.5.1 红与黑.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：红与黑.cpp
4 * 创建日期：2021年11月26日 星期五 19时35分22秒 5 * 题 目：AcWing 1113 红与黑 6 * 算 法：深度优先搜索 洪泛法 7 * 描 述：把 @ 所在的 . 的区域大小输出 8 * 9 * ....#.
10 * .....#
11 * ......
12 * ......
13 * ......
14 * ......
15 * ......
16 * #@...#
17 * .#..#.
18 *
19 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
20
21 #include <cstdio>
22 const int maxn = 25;
23 int n, m;
24 char g[maxn][maxn];
25 int dx[] = {0, ‐1, 0, 1};
26 int dy[] = {‐1, 0, 1, 0};
27
28 int DFS(int x, int y) {
29 int res = 1;
30 g[x][y] = '#';
31 for (int i = 0; i < 4; ++ i) {
32 int nx = x + dx[i],
33 ny = y + dy[i];
34 if (nx >= 0 && nx < n && ny >= 0 && ny < m && g[nx][ny] == '.')
35 res += DFS(nx, ny);
36 }
37 return res;
38 }
39
40 int main() {
41 while (scanf("%d %d", &m, &n) && (n || m)) {
42 for (int i = 0; i < n; ++ i)
43 scanf("%s", g[i]);
44 int x, y;
45 for (int i = 0; i < n; ++ i)
46 for (int j = 0; j < m; ++ j)
47 if (g[i][j] == '@') {
48 x = i, y = j;
49 break;
50 }
51 printf("%d\n", DFS(x, y));
52 }
Nanchang university ACM template 第 40 页
53 return 0;
54 }
3.1.5.2 迷宫.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：迷宫.cpp
4 * 创建日期：2021年11月26日 星期五 18时38分26秒 5 * 题 目：AcWing 1112 迷宫 6 * 算 法：深度优先搜索 7 * 描 述：
8 * .....
9 * ###.#
10 * ..#..
11 * ###..
12 * ...#.
13 *
14 * 会给出 A 和 B 的坐标，问是否可以从 A 到 B
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
17
18 #include <cstdio>
19 #include <cstring>
20 const int maxn = 110;
21 int n, ax, ay, bx, by;
22 char g[maxn][maxn];
23 bool used[maxn][maxn];
24 const int dx[] = {0, ‐1, 0, 1};
25 const int dy[] = {‐1, 0, 1, 0};
26
27 bool DFS(int x, int y) {
28 if (g[x][y] == '#')
29 return false;
30 if (x == bx && y == by)
31 return true;
32 used[x][y] = true;
33 for (int i = 0; i < 4; ++ i) {
34 int nx = x + dx[i],
35 ny = y + dy[i];
36 if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
37 if (used[nx][ny]) continue;
38 if (g[nx][ny] == '#') continue;
39 if (DFS(nx, ny))
40 return true;
41 }
42 return false;
43 }
44
45 int main() {
46 int t; scanf("%d", &t);
47 while (t ‐‐ ) {
48 scanf("%d", &n);
49 for (int i = 0; i < n; ++ i)
50 scanf("%s", g[i]);
51 memset(used, 0, sizeof used);
52 scanf("%d %d %d %d", &ax, &ay, &bx, &by);
53 if (DFS(ax, ay))
54 puts("YES");
55 else
56 puts("NO");
57 }
58 return 0;
59 }
3.2 宽度优先搜索 (BFS)
3.2.1 八数码.cpp
Nanchang university ACM template 第 41 页 1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：八数码.cpp
4 * 创建日期：2021年11月26日 星期五 10时35分46秒 5 * 题 目：AcWing 0179 八数码问题 6 * 算 法：宽度优先搜索 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 #include <string>
14 #include <queue>
15 #include <unordered_map>
16 #include <iostream>
17 using namespace std;
18 const int dx[] = {0, ‐1, 0, 1};
19 const int dy[] = {‐1, 0, 1, 0};
20 const char op[] = "lurd";
21
22 string BFS(string start) {
23 string over = "12345678x";
24 queue<string> q;
25 unordered_map<string, pair<string, char>> pre;
26 unordered_map<string, bool> used;
27 q.push(start);
28 used[start] = true;
29 while (q.size()) {
30 string t = q.front(); q.pop();
31 if (t == over)
32 break;
33 int x, y;
34 for (int i = 0; i < t.size(); ++ i)
35 if (t[i] == 'x')
36 x = i / 3, y = i % 3;
37 string source = t;
38 for (int i = 0; i < 4; ++ i) {
39 int nx = x + dx[i],
40 ny = y + dy[i];
41 if (nx < 0 || nx >= 3 || ny < 0 || ny >= 3)
42 continue;
43 swap(t[x * 3 + y], t[nx * 3 + ny]);
44 if (!used[t]) {
45 used[t] = true;
46 q.push(t);
47 pre[t] = {source, op[i]};
48 }
49 swap(t[x * 3 + y], t[nx * 3 + ny]);
50 }
51 }
52 string res;
53 while (over != start) {
54 res += pre[over].second;
55 over = pre[over].first;
56 }
57 reverse(res.begin(), res.end());
58 return res;
59 }
60
61 int main() {
62 string g, seq, c;
63 while (cin >> c) {
64 g += c;
65 if (c != "x")
66 seq += c;
67 }
68 int cnt = 0;
69 for (int i = 0; i < seq.size(); ++ i)
Nanchang university ACM template 第 42 页
70 for (int j = i + 1; j < seq.size(); ++ j)
71 if (seq[i] > seq[j])
72 cnt ++ ;
73 if (cnt & 1)
74 cout << "unsolvable" << endl;
75 else
76 cout << BFS(g) << endl;
77 return 0;
78 }
3.2.2 双端队列宽搜
3.2.2.1 电路维修.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：电路维修.cpp
4 * 创建日期：2021年11月24日 星期三 21时23分48秒 5 * 题 目：AcWing 0175 电路维修 6 * 算 法：双端队列宽度优先搜索 7 * 描 述：
8 * \\/\\
9 * \\///
10 * /\\\\
11 *
12 * 对于上面这个电路，电从左上角进入，转动最少的电线能使电从右下角
13 * 离开
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <cstring>
19 #include <deque>
20 using namespace std;
21 const int maxn = 505;
22 int n, m;
23 char g[maxn][maxn];
24 typedef pair<int, int> PII;
25 int dist[maxn][maxn];
26 bool used[maxn][maxn];
27 const int dx[] = {‐1, ‐1, 1, 1}, dy[] = {‐1, 1, 1, ‐1};
28 const int ix[] = {‐1, ‐1, 0, 0}, iy[] = {‐1, 0, 0, ‐1};
29 #define x first
30 #define y second
31
32 int BFS() {
33 deque<PII> q;
34 memset(used, 0, sizeof used);
35 memset(dist, 0x3f, sizeof dist);
36 char cs[5] = "\\/\\/";
37 dist[0][0] = 0;
38 q.push_back({0, 0});
39 while (q.size()) {
40 auto t = q.front(); q.pop_front();
41 if (t.x == n && t.y == m)
42 return dist[t.x][t.y];
43 if (used[t.x][t.y])
44 continue;
45 used[t.x][t.y] = true;
46 for (int i = 0; i < 4; ++ i) {
47 int x = t.x + dx[i],
48 y = t.y + dy[i];
49 if (x < 0 || x > n || y < 0 || y > m) continue;
50 int ga = t.x + ix[i], gb = t.y + iy[i];
51 int w = (g[ga][gb] != cs[i]);
52 int d = dist[t.x][t.y] + w;
53 if (d <= dist[x][y]) {
54 dist[x][y] = d;
55 if (!w)
56 q.push_front({x, y});
Nanchang university ACM template 第 43 页
57 else
58 q.push_back({x, y});
59 }
60 }
61 }
62 return ‐1;
63 }
64
65 int main() {
66 int t; scanf("%d", &t);
67 while (t ‐‐ ) {
68 scanf("%d %d", &n, &m);
69 for (int i = 0; i < n; ++ i)
70 scanf("%s", g[i]);
71 if ((n + m) & 1)
72 puts("NO SOLUTION");
73 else
74 printf("%d\n", BFS());
75 }
76 return 0;
77 }
3.2.3 多源 BFS
3.2.3.1 矩阵距离.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：矩阵距离.cpp
4 * 创建日期：2021年11月24日 星期三 13时03分49秒 5 * 题 目：AcWing 0173 矩阵距离 6 * 算 法：多源BFS
7 * 描 述：输入一个01矩阵，输出每个0到达最近的1的曼哈顿距离 8 * 9 * 3 4
10 * 0001
11 * 0011
12 * 0110
13 *
14 * 3 2 1 0
15 * 2 1 0 0
16 * 1 0 0 1
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <cstring>
22 #include <queue>
23 using namespace std;
24 const int maxn = 1e3 + 5;
25 int n, m;
26 char g[maxn][maxn];
27 int dist[maxn][maxn];
28 typedef pair<int, int> PII;
29 #define NEXTLINE puts("");
30 const int dx[] = {0, ‐1, 0, 1};
31 const int dy[] = {‐1, 0, 1, 0};
32
33 void BFS() {
34 memset(dist, ‐1, sizeof dist);
35 queue<PII> q;
36 for (int i = 0; i < n; ++ i)
37 for (int j = 0; j < m; ++ j)
38 if (g[i][j] == '1') {
39 q.push({i, j});
40 dist[i][j] = 0;
41 }
42 while (q.size()) {
43 auto t = q.front();
44 q.pop();
Nanchang university ACM template 第 44 页
45 for (int i = 0; i < 4; ++ i) {
46 int x = t.first + dx[i],
47 y = t.second + dy[i];
48 if (0 <= x && x < n && 0 <= y && y < m && dist[x][y] == ‐1) {
49 dist[x][y] = dist[t.first][t.second] + 1;
50 q.push({x, y});
51 }
52 }
53 }
54 }
55
56 int main() {
57 scanf("%d %d", &n, &m);
58 for (int i = 0; i < n; ++ i)
59 scanf("%s", g[i]);
60 BFS();
61 for (int i = 0; i < n; ++ i) {
62 for (int j = 0; j < m; ++ j)
63 printf("%d ", dist[i][j]);
64 NEXTLINE;
65 }
66 return 0;
67 }
3.2.4 最小步数模型
3.2.4.1 魔板.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：魔板.cpp
4 * 创建日期：2021年11月24日 星期三 18时03分34秒 5 * 题 目：AcWing 1107 魔板 6 * 算 法：BFS最小步数模型 7 * 描 述：输入 2 * 4 的矩阵，求出经过最少的哪些操作可以使 8 * 初态矩阵 1 2 3 4 转化为输入的矩阵 9 * 8 7 6 5
10 * 矩阵的排列就是按上面初态矩阵的排列
11 * 比如输入 8 7 6 5 4 3 2 1
12 *
13 * 那么输入的矩阵就是：
14 * 8 7 6 5
15 * 1 2 3 4
16 *
17 * 可以的操作有：
18 * A：交换上下两行；
19 * B：将最右边的一列插入到最左边；
20 * C：魔板中央对的4个数作顺时针旋转。
21 *
22 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
23
24 #include <cstdio>
25 #include <unordered_map>
26 #include <string>
27 #include <queue>
28 #include <iostream>
29 #include <algorithm>
30 using namespace std;
31 int g[2][4];
32 unordered_map<string, int> dist;
33 unordered_map<string, pair<char, string>> pre;
34 queue<string> q;
35
36 void set(string str) {
37 for (int i = 0; i < 4; ++ i)
38 g[0][i] = str[i];
39 for (int i = 3, j = 4; i >= 0; ‐‐ i, ++ j)
40 g[1][i] = str[j];
41 }
42
Nanchang university ACM template 第 45 页
43 string get() {
44 string res;
45 for (int i = 0; i < 4; ++ i)
46 res += g[0][i];
47 for (int i = 3; i >= 0; ‐‐ i)
48 res += g[1][i];
49 return res;
50 }
51
52 string move0(string str) {
53 set(str);
54 for (int i = 0; i < 4; ++ i)
55 swap(g[0][i], g[1][i]);
56 return get();
57 }
58
59 string move1(string str) {
60 set(str);
61 char g03 = g[0][3], g13 = g[1][3];
62 for (int i = 3; i > 0; ‐‐ i) {
63 g[0][i] = g[0][i ‐ 1];
64 g[1][i] = g[1][i ‐ 1];
65 }
66 g[0][0] = g03;
67 g[1][0] = g13;
68 return get();
69 }
70
71 string move2(string str) {
72 set(str);
73 char g01 = g[0][1];
74 g[0][1] = g[1][1];
75 g[1][1] = g[1][2];
76 g[1][2] = g[0][2];
77 g[0][2] = g01;
78 return get();
79 }
80
81 void BFS(string start, string end) {
82 if (start == end)
83 return;
84 q.push(start);
85 dist[start] = 0;
86 while (q.size()) {
87 auto t = q.front(); q.pop();
88 string m[3];
89 m[0] = move0(t);
90 m[1] = move1(t);
91 m[2] = move2(t);
92
93 for (int i = 0; i < 3; ++ i) {
94 string str = m[i];
95 if (dist.count(str) == 0) {
96 dist[str] = dist[t] + 1;
97 pre[str] = {char(i + 'A'), t};
98 if (str == end)
99 break;
100 q.push(str);
101 }
102 }
103 }
104 }
105
106 int main() {
107 int x;
108 string start, end;
109 for (int i = 0; i < 8; ++ i) {
110 cin >> x;
111 end += char(x + '0');
112 }
Nanchang university ACM template 第 46 页
113 for (int i = 0; i < 8; ++ i)
114 start += char(i + '1');
115 BFS(start, end);
116 cout << dist[end] << endl;
117 string res;
118 while (end != start) {
119 res += pre[end].first;
120 end = pre[end].second;
121 }
122 reverse(res.begin(), res.end());
123 if (res.length() > 0)
124 cout << res << endl;
125 return 0;
126 }
3.2.5 最短路模型
3.2.5.1 抓住那头牛.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：抓住那头牛.cpp
4 * 创建日期：2021年11月23日 星期二 23时43分17秒 5 * 题 目：AcWing 1100 抓住那头牛 6 * 算 法：最短路模型 7 * 描 述：农夫位于坐标轴的点 N，牛位于 K 8 * 农夫有两种移动方式：
9 * 1. x ‐ 1，x + 1
10 * 2. 2 * x
11 * 每种移动都花费一分种
12 *
13 * 农夫最少要花多少时间抓住牛,牛不动
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <cstring>
19 const int maxn = 1e5 + 5;
20 int n, k, q[maxn];
21 bool used[maxn];
22 int dist[maxn];
23
24 int BFS() {
25 memset(dist, ‐1, sizeof dist);
26 dist[n] = 0;
27 int hh = 0, tt = ‐1;
28 q[ ++ tt] = n;
29 while (hh <= tt) {
30 int t = q[hh ++ ];
31 if (t == k)
32 return dist[k];
33 if (t + 1 < maxn && dist[t + 1] == ‐1) {
34 dist[t + 1] = dist[t] + 1;
35 q[ ++ tt] = t + 1;
36 }
37 if (t ‐ 1 >= 0 && dist[t ‐ 1] == ‐1) {
38 dist[t ‐ 1] = dist[t] + 1;
39 q[ ++ tt] = t ‐ 1;
40 }
41 if (t * 2 <= maxn && dist[t * 2] == ‐1) {
42 dist[t * 2] = dist[t] + 1;
43 q[ ++ tt] = t * 2;
44 }
45 }
46 return ‐1;
47 }
48
49 int main() {
50 scanf("%d %d", &n, &k);
51 printf("%d\n", BFS());
Nanchang university ACM template 第 47 页
52 return 0;
53 }
3.2.5.2 武士风度的牛.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：武士风度的牛.cpp
4 * 创建日期：2021年11月23日 星期二 22时19分20秒 5 * 题 目：AcWing 0188 武士风度的牛 6 * 算 法：最短路模型 7 * 描 述：马走日 8 * . . . . . . . . . . 9 * . . . . * . . . . .
10 * . . . . . . . . . .
11 * . . . * . * . . . .
12 * . . . . . . . * . .
13 * . . * . . * . . . H
14 * * . . . . . . . . .
15 * . . . * . . . * . .
16 * . K . . . . . . . .
17 * . . . * . . . . . *
18 * . . * . . . . * . .
19 *
20 * 从 K 到 H，* 是障碍，没有别马腿
21 *
22 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
23
24 #include <cstdio>
25 #include <cstring>
26 #include <utility>
27 #include <queue>
28 using namespace std;
29 typedef pair<int, int> PII;
30 const int maxn = 155;
31 int n, m;
32 char g[maxn][maxn];
33 int dist[maxn][maxn];
34 const int dx[] = {‐1, ‐2, ‐2, ‐1, 1, 2, 2, 1};
35 const int dy[] = {‐2, ‐1, 1, 2, 2, 1, ‐1, ‐2};
36 #define x first
37 #define y second
38
39 int BFS(PII start, PII end) {
40 queue<PII> q;
41 memset(dist, ‐1, sizeof dist);
42 dist[start.x][start.y] = 0;
43 q.push(start);
44 while (q.size()) {
45 auto t = q.front();
46 q.pop();
47 for (int i = 0; i < 8; ++ i)
48 for (int j = 0; j < 8; ++ j) {
49 int x = t.x + dx[i],
50 y = t.y + dy[i];
51 if (x < 0 || x >= n || y < 0 || y >= m) continue;
52 if (g[x][y] == '*') continue;
53 if (dist[x][y] != ‐1) continue;
54 dist[x][y] = dist[t.x][t.y] + 1;
55 if (make_pair(x, y) == end)
56 return dist[x][y];
57 q.push({x, y});
58 }
59 }
60 return ‐1; // 本题保证有解
61 }
62
63 int main() {
64 scanf("%d %d", &m, &n);
Nanchang university ACM template 第 48 页
65 for (int i = 0; i < n; ++ i)
66 scanf("%s", g[i]);
67
68 PII start, end;
69 for (int i = 0; i < n; ++ i)
70 for (int j = 0; j < m; ++ j) {
71 if (g[i][j] == 'K')
72 start = {i, j};
73 if (g[i][j] == 'H')
74 end = {i, j};
75 }
76 printf("%d\n", BFS(start, end));
77 return 0;
78 }
3.2.5.3 迷宫问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：迷宫问题.cpp
4 * 创建日期：2021年11月23日 星期二 19时50分36秒 5 * 题 目：AcWing 1076 迷宫问题 6 * 算 法：最短路模型 7 * 描 述：输出从左上角到右下角的最短路线，0表示可以走，1表示 8 * 不可以走 9 * 0 1 0 0 0
10 * 0 1 0 1 0
11 * 0 0 0 0 0
12 * 0 1 1 1 0
13 * 0 0 0 1 0
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <utility>
19 #include <cstring>
20 using namespace std;
21 const int maxn = 1e3 + 5;
22 const int maxm = maxn * maxn;
23 typedef pair<int, int> PII;
24 int n, g[maxn][maxn];
25 PII q[maxm];
26 PII pre[maxn][maxn];
27 const int dx[] = {0, ‐1, 0, 1};
28 const int dy[] = {‐1, 0, 1, 0};
29 #define x first
30 #define y second
31
32 void BFS(int x, int y) {
33 int hh = 0, tt = ‐1;
34 q[ ++ tt] = {x, y};
35 memset(pre, ‐1, sizeof pre);
36 pre[x][y] = {0, 0};
37 while (hh <= tt) {
38 PII t = q[hh ++ ];
39 for (int i = 0; i < 4; ++ i) {
40 int nx = t.x + dx[i],
41 ny = t.y + dy[i];
42 if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
43 if (g[nx][ny]) continue;
44 if (pre[nx][ny].x != ‐1) continue;
45 q[ ++ tt] = {nx, ny};
46 pre[nx][ny] = t;
47 }
48 }
49 }
50
51 int main() {
52 scanf("%d", &n);
Nanchang university ACM template 第 49 页
53 for (int i = 0; i < n; ++ i)
54 for (int j = 0; j < n; ++ j)
55 scanf("%d", &g[i][j]);
56 BFS(n ‐ 1, n ‐ 1);
57 // pre 中存储的是结果路线中每个位置的前一个位置
58 PII end(0, 0);
59 while (true) {
60 printf("%d %d\n", end.x, end.y);
61 if (end.x == n ‐ 1 && end.y == n ‐ 1)
62 break;
63 end = pre[end.x][end.y];
64 }
65 return 0;
66 }
3.2.6 洪泛法
3.2.6.1 山峰和山谷.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：山峰和山谷.cpp
4 * 创建日期：2021年11月23日 星期二 09时14分20秒 5 * 题 目：AcWing 1106 山峰和山谷 6 * 算 法：洪泛法 7 * 描 述：就是找山峰山谷 8 * 9 * 8 8 8 7 7
10 * 7 7 8 8 7
11 * 7 7 7 7 7
12 * 7 8 8 7 8
13 * 7 8 8 8 8
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <utility>
19 #include <algorithm>
20 using namespace std;
21 typedef pair<int, int> PII;
22 #define x first
23 #define y second
24 const int maxn = 1e3 + 5, maxm = maxn * maxn;
25 int n;
26 int h[maxn][maxn];
27 PII q[maxm];
28 bool used[maxn][maxn];
29
30 void BFS(int x, int y, bool &has_lower, bool &has_higher) {
31 int hh = 0, tt = ‐1;
32 q[ ++ tt] = {x, y};
33 used[x][y] = true;
34 while (hh <= tt) {
35 PII t = q[hh ++ ];
36 for (int i = t.x ‐ 1; i <= t.x + 1; ++ i)
37 for (int j = t.y ‐ 1; j <= t.y + 1; ++ j) {
38 if (i == t.x && j == t.y) continue;
39 if (i < 0 || i >= n || j < 0 || j >= n) continue;
40 if (h[i][j] != h[t.x][t.y]) {
41 if (h[i][j] > h[t.x][t.y])
42 has_higher = true;
43 else
44 has_lower = true;
45 }
46 else if (!used[i][j]) {
47 q[ ++ tt] = {i, j};
48 used[i][j] = true;
49 }
50 }
51 }
Nanchang university ACM template 第 50 页
52 }
53
54 int main() {
55 scanf("%d", &n);
56 for (int i = 0; i < n; ++ i)
57 for (int j = 0; j < n; ++ j)
58 scanf("%d", &h[i][j]);
59 // 山峰，山谷
60 int peak = 0, valley = 0;
61 for (int i = 0; i < n; ++ i)
62 for (int j = 0; j < n; ++ j)
63 if (!used[i][j]) {
64 bool has_higher = false, has_lower = false;
65 BFS(i, j, has_lower, has_higher);
66 if (!has_lower)
67 valley ++ ;
68 if (!has_higher)
69 peak ++ ;
70 }
71 printf("%d %d\n", peak, valley);
72 return 0;
73 }
3.2.6.2 池塘计数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：池塘计数.cpp
4 * 创建日期：2021年11月22日 星期一 21时47分37秒 5 * 题 目：AcWing 1097 池塘计数 6 * 算 法：洪泛法 7 * 描 述：雨水是 'W'，'.' 是土地，每个单元格与相邻的八个格子相连 8 * 问共有多少片相连的 'W' 块。
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <utility>
14 using namespace std;
15 int n, m;
16 const int maxn = 1e3 + 5;
17 const int maxm = maxn * maxn;
18 const int dx[] = {‐1, ‐1, 0, 1, 1, 1, 0, ‐1};
19 const int dy[] = {0, ‐1, ‐1, ‐1, 0, 1, 1, 1};
20 bool used[maxn][maxn];
21 #define x first
22 #define y second
23 typedef pair<int, int> PII;
24
25 PII q[maxm];
26 char g[maxn][maxn];
27
28 void BFS(int x, int y) {
29 int hh = 0, tt = ‐1;
30 q[ ++ tt] = {x, y};
31 used[x][y] = true;
32
33 while (hh <= tt) {
34 PII t = q[hh ++ ];
35 for (int i = t.x ‐ 1; i <= t.x + 1; ++ i)
36 for (int j = t.y ‐ 1; j <= t.y + 1; ++ j) {
37 if (i == t.x && j == t.y) // 把一个 3 * 3 的矩阵中间挖掉
38 continue;
39 if (i < 0 || i >= n || j < 0 || j >= m)
40 continue;
41 if (g[i][j] == '.' || used[i][j])
42 continue;
43 q[ ++ tt] = {i, j};
44 used[i][j] = true;
Nanchang university ACM template 第 51 页
45 }
46 }
47 }
48
49 int main() {
50 scanf("%d %d", &n, &m);
51 for (int i = 0; i < n; ++ i)
52 scanf("%s", g[i]);
53 int cnt = 0;
54 for (int i = 0; i < n; ++ i)
55 for (int j = 0; j < m; ++ j)
56 if (g[i][j] == 'W' && !used[i][j]) {
57 BFS(i, j);
58 cnt ++ ;
59 }
60 printf("%d\n", cnt);
61 return 0;
62 }
3.2.7 走迷宫.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：走迷宫.cpp
4 * 创建日期：2021年10月07日 星期四 10时44分54秒 5 * 题 目：AcWing 0844 走迷宫 6 * 算 法：宽度优先搜索，泛洪法 7 * 描 述：
8 * 起点：(1, 1) 终点：(n, m) 1 为障碍物 求到终点最少移动距离 9 * 题目保证有解
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <utility>
15 #include <cstring>
16 using namespace std;
17 const int maxn = 100 + 5;
18 // 上 右 下 左 上左 上右 下右 下左
19 const int dirx[] = {‐1, 0, 1, 0, ‐1, ‐1, 1, 1};
20 const int diry[] = {0, 1, 0, ‐1, ‐1, 1, 1, ‐1};
21 typedef pair<int, int> PII;
22 int n, m;
23 int g[maxn][maxn];
24 int d[maxn][maxn];
25 PII quu[maxn * maxn]; // 考试时使用 q 就好
26 int hh = 0, tt = ‐1;
27
28 // 插入 quu[++ tt] = x;
29 // 弹出 hh ++ ;
30
31 void BFS() {
32 quu[++ tt] = {0, 0}; // 起点
33 memset(d, ‐1, sizeof d); // 有 used 的作用
34 d[0][0] = 0;
35 while (hh <= tt) {
36 auto t = quu[hh ++ ];
37 // printf("%d %d\n", t.first, t.second);
38 for (int i = 0; i < 4; ++ i) {
39 int newx = t.first + dirx[i]; // 考试时使用 x, y 就好
40 int newy = t.second + diry[i];
41 if (newx >= 0 && newx < n && newy >= 0 && newy < m && g[newx][newy] == 0 && d[newx][newy] == ‐1)
{
42 d[newx][newy] = d[t.first][t.second] + 1;
43 quu[ ++ tt] = {newx, newy};
44 }
45 }
46 }
47 }
Nanchang university ACM template 第 52 页
48
49 int main() {
50 scanf("%d %d", &n, &m);
51 for (int i = 0; i < n; ++ i)
52 for (int j = 0; j < m; ++ j)
53 scanf("%d", &g[i][j]);
54 BFS();
55 printf("%d\n", d[n ‐ 1][m ‐ 1]);
56 return 0;
57 }
3.3 双向搜索
3.3.1 字串变换.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：字串变换.cpp
4 * 创建日期：2021年11月24日 星期三 22时37分50秒 5 * 题 目：AcWing 0190 字串变换 6 * 算 法：双向搜索 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <queue>
13 #include <unordered_map>
14 #include <string>
15 #include <iostream>
16 using namespace std;
17 const int maxn = 6;
18 string A, B;
19 string a[maxn], b[maxn];
20 int n;
21
22 int extend(queue<string>& q, unordered_map<string, int>& da, unordered_map<string, int>& db,
23 string a[maxn], string b[maxn]) {
24 int d = da[q.front()];
25 while (q.size() && da[q.front()] == d) {
26 auto t = q.front(); q.pop();
27 for (int i = 0; i < n; ++ i)
28 for (int j = 0; j < t.size(); ++ j)
29 if (t.substr(j, a[i].size()) == a[i]) {
30 string str = t.substr(0, j) + b[i] + t.substr(j + a[i].size());
31 if (db.count(str))
32 return da[t] + db[str] + 1;
33 if (da.count(str))
34 continue;
35 da[str] = da[t] + 1;
36 q.push(str);
37 }
38 }
39 return 11;
40 }
41
42 int BFS() {
43 if (A == B)
44 return 0;
45 queue<string> qa, qb;
46 unordered_map<string, int> da, db;
47
48 qa.push(A), qb.push(B);
49 da[A] = db[B] = 0;
50
51 int step = 0;
52 while (qa.size() && qb.size()) {
53 int t;
54 if (qa.size() < qb.size())
Nanchang university ACM template 第 53 页
55 t = extend(qa, da, db, a, b);
56 else
57 t = extend(qb, db, da, b, a);
58 if (t <= 10)
59 return t;
60 if ( ++ step == 10)
61 return ‐1;
62 }
63 return ‐1;
64 }
65
66 int main() {
67 cin >> A >> B;
68 while (cin >> a[n] >> b[n])
69 n ++ ;
70 int t = BFS();
71 if (t == ‐1)
72 puts("NO ANSWER!");
73 else
74 cout << t << endl;
75 return 0;
76 }
3.4 A*
3.4.1 八数码.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：八数码.cpp
4 * 创建日期：2021年11月25日 星期四 11时27分52秒 5 * 题 目：AcWing 0179 八数码 6 * 算 法：astar 直接使用 BFS + cantor 也可以，代码在 7 * 数学 ‐> 组合数学 ‐> 康托展开 8 * 描 述：将输入的一个八数码通过移动 x 来转换为初始八数码 9 *
10 * 1 2 3 1 2 3
11 * x 4 6 ‐> 4 5 6
12 * 7 5 8 7 8 x
13 *
14 * u : 向上
15 * d : 向下
16 * l : 向左
17 * r : 向右
18 *
19 * 八数码问题无解当且仅当逆序对数量是奇数。
20 *
21 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
22 #include <cstdio>
23 #include <string>
24 #include <iostream>
25 #include <queue>
26 #include <unordered_map>
27 #include <algorithm>
28 using namespace std;
29 const int dx[] = {0, ‐1, 0, 1};
30 const int dy[] = {‐1, 0, 1, 0};
31 const char op[] = "lurd";
32
33 int f(string state) {
34 int res = 0;
35 for (int i = 0; i < state.size(); ++ i)
36 if (state[i] != 'x') {
37 int t = state[i] ‐ '1';
38 res += abs(i / 3 ‐ t / 3) + abs(i % 3 ‐ t % 3);
39 }
40 return res;
41 }
42
Nanchang university ACM template 第 54 页
43 string BFS(string start) {
44 string over = "12345678x";
45 unordered_map<string, int> dist;
46 unordered_map<string, bool> used;
47 unordered_map<string, pair<string, char>> prev;
48 priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> he;
49 he.push({f(start), start});
50 dist[start] = 0;
51 while (he.size()) {
52 auto t = he.top(); he.pop();
53 string state = t.second;
54 if (state == over)
55 break;
56 if (used[state])
57 continue;
58 used[state] = true;
59 int step = dist[state];
60 int x, y;
61 for (int i = 0; i < state.size(); ++ i)
62 if (state[i] == 'x')
63 x = i / 3, y = i % 3;
64 string source = state;
65 for (int i = 0; i < 4; ++ i) {
66 int nx = x + dx[i],
67 ny = y + dy[i];
68 if (nx < 0 || nx >= 3 || ny < 0 || ny >= 3)
69 continue;
70 swap(state[x * 3 + y], state[nx * 3 + ny]);
71 if (!dist.count(state) || dist[state] > step + 1) {
72 dist[state] = step + 1;
73 prev[state] = {source, op[i]};
74 he.push({dist[state] + f(state), state});
75 }
76 swap(state[x * 3 + y], state[nx * 3 + ny]);
77 }
78 }
79 string res;
80 while (over != start) {
81 res += prev[over].second;
82 over = prev[over].first;
83 }
84 reverse(res.begin(), res.end());
85 return res;
86 }
87
88 int main() {
89 string g, c, seq;
90 while (cin >> c) {
91 g += c;
92 if (c != "x")
93 seq += c;
94 }
95 int t = 0;
96 for (int i = 0; i < seq.size(); ++ i)
97 for (int j = i + 1; j < seq.size(); ++ j)
98 if (seq[i] > seq[j])
99 t ++ ;
100 if (t & 1)
101 cout << "unsolvable" << endl;
102 else
103 cout << BFS(g) << endl;
104 return 0;
105 }
3.4.2 第 k 短路.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：第k短路.cpp
Nanchang university ACM template 第 55 页 4 * 创建日期：2021年11月25日 星期四 10时41分54秒 5 * 题 目：AcWing 0178 第k短路 6 * 算 法：A* 7 * 描 述：n 个点，m 条边的有向图，求从起点 s 到终点 t 的第 k 8 * 短路的长度，路径允许重复经过点和边 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <queue>
14 #include <cstring>
15 using namespace std;
16 const int maxn = 1e3 + 5;
17 const int maxm = 2e5 + 5;
18 int n, m;
19 int h[maxn], rh[maxn], e[maxm], w[maxm], ne[maxm], idx;
20 int dist[maxn], f[maxn], used[maxn];
21 int S, T, K;
22 typedef pair<int, int> PII;
23 typedef pair<int, PII> PIII;
24
25 void add(int *h, int a, int b, int c) {
26 e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
27 }
28
29 void dijkstra() {
30 priority_queue<PII, vector<PII>, greater<PII>> he;
31 memset(dist, 0x3f, sizeof dist);
32 dist[T] = 0;
33 he.push({0, T});
34 while (he.size()) {
35 auto t = he.top(); he.pop();
36 int ver = t.second;
37 if (used[ver])
38 continue;
39 used[ver] = true;
40 for (int i = rh[ver]; ~i; i = ne[i]) {
41 int j = e[i];
42 if (dist[j] > dist[ver] + w[i]) {
43 dist[j] = dist[ver] + w[i];
44 he.push({dist[j], j});
45 }
46 }
47 }
48 memcpy(f, dist, sizeof dist);
49 }
50
51 int astar() {
52 priority_queue<PIII, vector<PIII>, greater<PIII>> he;
53 he.push({f[S], {0, S}});
54 memset(used, 0, sizeof used);
55 while (he.size()) {
56 auto t = he.top(); he.pop();
57 int ver = t.second.second, distance = t.second.first;
58 if (used[ver] >= K)
59 continue;
60 used[ver] ++ ;
61 if (ver == T && used[ver] == K)
62 return distance;
63 for (int i = h[ver]; ~i; i = ne[i]) {
64 int j = e[i];
65 if (used[j] < K)
66 he.push({distance + w[i] + f[j], {distance + w[i], j}});
67 }
68 }
69 return ‐1;
70 }
71
72 int main() {
73 scanf("%d %d", &n, &m);
Nanchang university ACM template 第 56 页
74 memset(h, ‐1, sizeof h);
75 memset(rh, ‐1, sizeof rh);
76 for (int i = 0; i < m; ++ i) {
77 int a, b, c;
78 scanf("%d %d %d", &a, &b, &c);
79 add(h, a, b, c), add(rh, b, a, c);
80 }
81 scanf("%d %d %d", &S, &T, &K);
82 if (S == T)
83 K ++ ;
84 dijkstra(); // 求启发函数，每个点到终点的最短距离
85 printf("%d\n", astar());
86 return 0;
87 }4 动态规划
4.1 DP 基础
4.1.1 硬币问题
4.1.1.1 最少硬币问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最少硬币问题.cpp
4 * 创建日期：2021年03月08日 ‐‐‐‐ 14时16分 5 * 题 目：硬币问题 6 * 算 法：动态规划 7 * 描 述：有5种硬币，面值分别为1, 5, 10, 25, 50，数量无限，输入非负整数 8 * 表示需要付的钱数，要求付钱时选择最少的硬币数 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 251; //购物需要的钱数不超过250
16 const int inf = 0x3f3f3f3f;
17 int type[5] = {1, 5, 10, 25, 50}; //5种硬币面值
18 int minCoins[maxn]; //minCoins[i]代表: 付i块钱最少需要多少硬币
19 #define bug printf("<‐‐‐>\n");
20
21 void solve() {
22 for (int i = 0; i < maxn; ++i) //动态转移方程需要此初始化
23 minCoins[i] = inf;
24 minCoins[0] = 0; //初始条件
25 for (int i = 0; i < 5; ++i) {
26 for (int j = type[i]; j < maxn; ++j)
27 minCoins[j] = min(minCoins[j], minCoins[j‐type[i]]+1);
28 }
29 }
30
31 int main() {
32 solve();
33 for (int i = 0; i < maxn; ++i)
34 printf("minCoins[%d] = %d\n", i, minCoins[i]);
35 return 0;
36 }
4.1.1.2 最少硬币组合.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最少硬币问题.cpp
4 * 创建日期：2021年03月08日 ‐‐‐‐ 14时16分 5 * 题 目：硬币问题 6 * 算 法：动态规划 7 * 描 述：有5种硬币，面值分别为1, 5, 10, 25, 50，数量无限，输入非负整数
Nanchang university ACM template 第 57 页 8 * 表示需要付的钱数，要求付钱时选择最少的硬币数 9 * 而且打印出硬币组合
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 251; //购物需要的钱数不超过250
17 const int inf = 0x3f3f3f3f;
18 int type[5] = {1, 5, 10, 25, 50}; //5种硬币面值
19 int minCoins[maxn]; //minCoins[i]代表: 付i块钱最少需要多少硬币
20 int coinPath[maxn]; //记录最少硬币路径
21 #define bug printf("<‐‐‐>\n");
22
23 void solve() {
24 for (int i = 0; i < maxn; ++i) //动态转移方程需要此初始化
25 minCoins[i] = inf;
26 minCoins[0] = 0; //初始条件
27 for (int i = 0; i < 5; ++i) {
28 for (int j = type[i]; j < maxn; ++j)
29 if (minCoins[j] > minCoins[j‐type[i]]+1) {
30 coinPath[j] = type[i]; //j块钱时选择的最后一块硬币是type[i]
31 minCoins[j] = minCoins[j‐type[i]] + 1;
32 }
33 }
34 }
35
36 void print(int money) {
37 while (money) {
38 printf("%d ", coinPath[money]);
39 money ‐= coinPath[money];
40 }
41 printf("\n");
42 }
43
44 int main() {
45 solve();
46 for (int i = 0; i < maxn; ++i) {
47 printf("minCoins[%d] = %d\n", i, minCoins[i]);
48 printf("==> ");
49 print(i);
50 }
51 return 0;
52 }
4.1.1.3 所有硬币组合-1.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最少硬币问题.cpp
4 * 创建日期：2021年03月08日 ‐‐‐‐ 14时16分 5 * 题 目：硬币问题 6 * 算 法：动态规划 7 * 描 述：有5种硬币，面值分别为1, 5, 10, 25, 50，数量无限，输入非负整数 8 * 表示需要付的钱数，要求付钱时选择最少的硬币数 9 * 而且打印出硬币组合
10 * 没有硬币数量限制
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 const int maxn = 251;
16 int type[5] = {1, 5, 10, 25, 50};
17 int dp[maxn];
18 void solve() {
19 dp[0] = 1;
20 for (int i = 0; i < 5; ++i)
21 for (int j = type[i]; j < maxn; ++j)
Nanchang university ACM template 第 58 页
22 dp[j] = dp[j] + dp[j‐type[i]];
23 }
24
25 int main() {
26 solve();
27 for (int i = 0; i < maxn; ++i)
28 printf("dp[%d] = %d\n", i, dp[i]);
29 return 0;
30 }
4.1.1.4 所有硬币组合-2.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最少硬币问题.cpp
4 * 创建日期：2021年03月08日 ‐‐‐‐ 14时16分 5 * 题 目：硬币问题 6 * 算 法：动态规划 7 * 描 述：有5种硬币，面值分别为1, 5, 10, 25, 50，数量无限，输入非负整数 8 * 表示需要付的钱数，要求付钱时选择最少的硬币数 9 * 而且打印出硬币组合
10 * 硬币数量限制为100
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 const int maxn = 251;
16 const int coin = 101; //限制最多选择100个硬币
17 int type[5] = {1, 5, 10, 25, 50};
18 int dp[maxn][coin];
19 int ans[maxn];
20 void solve() {
21 dp[0][0] = 1;
22 for (int i = 0; i < 5; ++i)
23 for (int j = 1; j < coin; ++j)
24 for (int k = type[i]; k < maxn; ++k)
25 dp[k][j] += dp[k‐type[i]][j‐1];
26 }
27
28 int main() {
29 solve();
30 for (int i = 0; i < maxn; ++i)
31 for (int j = 0; j < coin; ++j)
32 ans[i] += dp[i][j];
33 for (int i = 0; i < maxn; ++i)
34 printf("ans[%d] = %d\n", i, ans[i]);
35 return 0;
36 }
4.1.2 最长公共子序列
4.1.2.1 最长公共子序列.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐最长公共子序列.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 15时48分 5 * 题 目：hdu1159 Common Subsequence
6 * 算 法：动态规划 7 * 描 述：求两个序列的最长公共子序列，注意子序列不是子串 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <iostream>
12 #include <string>
13 #include <cstring>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 1005;
Nanchang university ACM template 第 59 页
17 int dp[maxn][maxn];
18 string str1, str2;
19 int LCS() {
20 memset(dp, 0, sizeof(dp));
21 for (int i = 1; i <= str1.length(); ++i)
22 for (int j = 1; j <= str2.length(); ++j) {
23 if (str1[i‐1] == str2[j‐1])
24 str1[i‐1] = dp[i‐1][j‐1] + 1;
25 else
26 dp[i][j] = max(dp[i‐1][j], dp[i][j‐1]);
27 }
28 return dp[str1.length()][str2.length()];
29 }
30
31 int main() {
32 while (cin >> str1 >> str2)
33 cout << LCS() << endl;
34 return 0;
35 }
4.1.3 最长递增子序列
4.2 记忆化搜索
4.2.1 The-Triangle.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐The‐Triangle.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 16时04分 5 * 题 目：poj1163 The Triangle
6 * 算 法：记忆化搜索 7 * 描 述：自下往上的方法更好，但是这里使用递归+记忆化 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 155;
16 int n; //三角形的高度
17 int Tri[maxn][maxn]; //存储三角形塔
18 int dp[maxn][maxn];
19 int dfs(int i, int j) {
20 if (i == n)
21 return Tri[i][j];
22 if (dp[i][j] >= 0)
23 return dp[i][j];
24 return dp[i][j] = max(dfs(i+1, j), dfs(i+1, j+1)) + Tri[i][j];
25 }
26
27 int main() {
28 freopen("in.txt", "r", stdin);
29 freopen("out.txt", "w", stdout);
30 scanf("%d", &n);
31 for (int i = 1; i <= n; ++i)
32 for (int j = 1; j <= i; ++j)
33 scanf("%d", &Tri[i][j]);
34 memset(dp, ‐1, sizeof(dp));
35 printf("%d\n", dfs(0, 0));
36 return 0;
37 }
4.2.2 滑雪.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 *
Nanchang university ACM template 第 60 页 3 * 文件名称：滑雪.cpp
4 * 创建日期：2021年11月01日 星期一 22时21分50秒 5 * 题 目：AcWing 0901 滑雪 6 * 算 法：记忆化搜索 7 * 描 述：给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场，
8 * 矩阵中第 i 行第 j 列的点表示滑雪场第 i 行第 j 列区域的高度。
9 * 一个人从滑雪场中的某个区域出发，每次可以向上下左右任意一个
10 * 方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前
11 * 提是该区域的高度低于自己目前所在区域的高度。
12 *
13 * 1 2 3 4 5
14 * 16 17 18 19 6
15 * 15 24 25 20 7
16 * 14 23 22 21 8
17 * 13 12 11 10 9
18 *
19 * 在给定矩阵中，一条可行的滑行轨迹为 24 ‐> 17 ‐> 2 ‐> 1，
20 * 最长的滑行轨迹为 25 ‐> 24 ‐> 23 ‐> ... ‐> 3 ‐> 2 ‐> 1
21 * 沿途共经过 25 个区域。
22 *
23 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
24
25 #include <cstdio>
26 #include <cstring>
27 #include <algorithm>
28 using namespace std;
29 const int maxn = 300 + 5;
30 int n, m;
31 int h[maxn][maxn];
32 int dp[maxn][maxn];
33 int dirx[4] = {‐1, 0, 1, 0}, diry[4] = {0, 1, 0, ‐1};
34
35 int work(int x, int y) {
36 int &v = dp[x][y];
37 if (v != ‐1)
38 return v;
39 v = 1;
40 for (int i = 0; i < 4; ++ i) {
41 int newx = x + dirx[i],
42 newy = y + diry[i];
43 if (newx >= 1 && newx <= n && newy >= 1 && newy <= m && h[newx][newy] < h[x][y])
44 v = max(v, work(newx, newy) + 1);
45 }
46 return v;
47 }
48
49 int main() {
50 scanf("%d %d", &n, &m);
51 for (int i = 1; i <= n; ++ i)
52 for (int j = 1; j <= m; ++ j)
53 scanf("%d", &h[i][j]);
54 memset(dp, ‐1, sizeof dp);
55 int res = 0;
56 for (int i = 1; i <= n; ++ i)
57 for (int j = 1; j <= m; ++ j)
58 res = max(res, work(i, j));
59 printf("%d\n", res);
60 return 0;
61 }
4.3 背包 DP
4.3.1 01 背包
4.3.1.1 01 背包问题-一维.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：0043‐01背包问题‐一维.cpp
4 * 创建日期：2021年10月15日 星期五 23时35分00秒
Nanchang university ACM template 第 61 页 5 * 题 目：AcWing 0002 01背包问题 6 * 算 法：动态规划 7 * 描 述：有N件物品，背包容积是V，第i件物品的体积是vi，价值wi
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using namespace std;
14 const int maxn = 1e3 + 5;
15 int N, V;
16 int v[maxn], w[maxn];
17 int dp[maxn];
18
19 int main() {
20 scanf("%d %d", &N, &V);
21 for (int i = 1; i <= N; ++ i)
22 scanf("%d %d", &v[i], &w[i]);
23 for (int i = 1; i <= N; ++ i)
24 for (int j = V; j >= v[i]; ‐‐ j)
25 dp[j] = max(dp[j], dp[j ‐ v[i]] + w[i]);
26 printf("%d\n", dp[V]);
27 return 0;
28 }
4.3.1.2 01 背包问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
4 * 5 * 文件名称：0042‐01背包问题.cpp
6 * 创建日期：2021年03月29日 ‐‐‐‐ 22时18分 7 * 创建日期：2021年10月15日 星期五 23时16分05秒 8 * 题 目：AcWing 0002 01 背包问题 9 * 算 法：动态规划 01背包
10 * 描 述：有N件物品，背包容积是V，第i件物品的体积是vi，价值wi
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <algorithm>
16 using namespace std;
17 const int maxn = 1e3 + 5;
18 int N; // N件物品
19 int V; // 背包容量
20 int dp[maxn][maxn];
21 int v[maxn], w[maxn];
22
23 int main() {
24 scanf("%d %d", &N, &V);
25 for (int i = 1; i <= N; ++ i)
26 scanf("%d %d", &v[i], &w[i]);
27 for (int i = 1; i <= N; ++ i)
28 for (int j = 0; j <= V; ++ j) {
29 dp[i][j] = dp[i ‐ 1][j];
30 if (j >= v[i])
31 dp[i][j] = max(dp[i ‐ 1][j], dp[i ‐ 1][j ‐ v[i]] + w[i]);
32 }
33 printf("%d\n", dp[N][V]);
34 return 0;
35 }
4.3.1.3 Bone-Collector.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Bone‐Collector.cpp
Nanchang university ACM template 第 62 页 4 * 创建日期：2021年03月09日 ‐‐‐‐ 15时34分 5 * 题 目：hdu2602 Bone Collector
6 * 算 法：o1背包 7 * 描 述：骨头收集者带着体积为V的背包去捡骨头，已知每个骨头的 8 * 体积和价值，求能装进背包的最大价值 9 * 第一行是测试数量，第二行是骨头数量和背包体积，
10 * 第三行是每个骨头的价值，第四行是每个骨头的体积
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <cstring>
16 #include <algorithm>
17 using namespace std;
18 const int maxn = 1005;
19 struct Bone {
20 int val;
21 int vol;
22 } bone[maxn];
23 int N; // 骨头数量
24 int V; // 背包体积
25 // dp[i][j]: 前i件物品放在体积为j的背包中最大价值
26 int dp[maxn][maxn];
27
28 int solve() {
29 memset(dp, 0, sizeof(dp));
30 for (int i = 1; i <= N; ++i)
31 for (int j = 0; j <= V; ++j) {
32 if (bone[i].vol > j) // 第i个物品太大，装不下
33 dp[i][j] = dp[i‐1][j];
34 else
35 dp[i][j] = max(dp[i‐1][j], dp[i‐1][j‐bone[i].vol] + bone[i].val);
36 }
37 return dp[N][V];
38 }
39
40 int main() {
41 int t;
42 scanf("%d", &t);
43 while (t ‐‐ ) {
44 scanf("%d %d", &N, &V);
45 // dp题还是从1开始吧，因为需要用到dp[i‐1][j]
46 for (int i = 1; i <= N; ++i)
47 scanf("%d", &bone[i].val);
48 for (int i = 1; i <= N; ++i)
49 scanf("%d", &bone[i].vol);
50 printf("%d\n", solve());
51 }
52 return 0;
53 }
4.3.2 完全背包
4.3.2.1 完全背包问题-一维.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐一维.cpp
4 * 创建日期：2021年03月30日 ‐‐‐‐ 16时20分 5 * 创建日期：2021年10月18日 星期一 11时53分17秒 6 * 题 目：AcWing 0003 完全背包 7 * 算 法：动态规划 8 * 描 述：与01背包问题代码相差无几 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1e3 + 5;
Nanchang university ACM template 第 63 页
16 int n, m;
17 int dp[maxn];
18 int v[maxn], w[maxn];
19
20 int main() {
21 scanf("%d %d", &n, &m);
22 for (int i = 1; i <= n; ++ i)
23 scanf("%d %d", &v[i], &w[i]);
24 for (int i = 1; i <= n; ++ i)
25 for (int j = v[i]; j <= m; ++ j)
26 dp[j] = max(dp[j], dp[j ‐ v[i]] + w[i]);
27 printf("%d\n", dp[m]);
28 return 0;
29 }
4.3.2.2 完全背包问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年03月30日 ‐‐‐‐ 15时30分 5 * 创建日期：2021年10月18日 星期一 11时47分41秒 6 * 题 目：AcWing 0003 完全背包问题 7 * 算 法：动态规划 8 * 描 述：与01背包问题代码相差无几 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1e3 + 5;
16 int n, m;
17 int dp[maxn][maxn];
18 int v[maxn], w[maxn];
19
20 // dp[i][j] = max(dp[i ‐ 1][j], dp[i][j ‐ v[i]] + w[i]);
21 int main() {
22 scanf("%d %d", &n, &m);
23 for (int i = 1; i <= n; ++ i)
24 scanf("%d %d", &v[i], &w[i]);
25 for (int i = 1; i <= n; ++ i)
26 for (int j = 1; j <= m; ++ j) {
27 dp[i][j] = dp[i ‐ 1][j];
28 if (j >= v[i])
29 dp[i][j] = max(dp[i][j], dp[i][j ‐ v[i]] + w[i]);
30 }
31 printf("%d\n", dp[n][m]);
32 return 0;
33 }
4.3.3 多重背包
4.3.3.1 多重背包问题 I-朴素.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：多重背包问题I‐朴素.cpp
4 * 创建日期：2021年04月10日 ‐‐‐‐ 10时39分 5 * 创建日期：2021年10月18日 星期一 18时35分36秒 6 * 题 目：AcWing 0004 多重背包 7 * 算 法：多重背包 8 * 描 述：每种物品选ai次转化为有ai个物品选1次，即01背包 9 *
10 * 0 < n, m < 100
11 * 0 < v, w, s < 100
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
Nanchang university ACM template 第 64 页
15 #include <cstdio>
16 #include <algorithm>
17 using namespace std;
18 const int maxn = 105;
19 int n, m;
20 int dp[maxn];
21
22 int main() {
23 scanf("%d %d", &n, &m);
24 for (int i = 0; i < n; ++ i) {
25 int v, w, s;
26 scanf("%d %d %d", &v, &w, &s);
27 for (int j = m; j >= v; ‐‐ j)
28 for (int k = 1; k <= s && k * v <= j; ++ k)
29 dp[j] = max(dp[j], dp[j ‐ k * v] + k * w);
30 }
31 printf("%d\n", dp[m]);
32 return 0;
33 }
4.3.3.2 多重背包问题 II-二进制分组优化.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：多重背包问题II‐二进制分组优化.cpp
4 * 创建日期：2021年10月18日 星期一 18时46分46秒 5 * 题 目：AcWing 0005 多重背包问题II
6 * 算 法：多重背包二进制优化 7 * 描 述：有n个物品，一个容量是m的背包 8 * 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 9 * 求解将哪些物品装入背包，可使物品体积总和不超过背包容量
10 * 且价值总和最大。
11 *
12 * 0 < n < 1000
13 * 0 < m < 2000
14 * 0 < v, w, s < 2000
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
17
18 #include <cstdio>
19 #include <vector>
20 using namespace std;
21 const int maxn = 1005;
22 int n, m;
23 int dp[10 * maxn];
24
25 struct Bone {
26 int v, w; // 体积，价值
27 } bone[10 * maxn];
28
29 int main() {
30 scanf("%d %d", &n, &m);
31 int idx = 1;
32 for (int i = 1; i <= n; ++ i) {
33 int v, w, s;
34 scanf("%d %d %d", &v, &w, &s);
35 int b = 1; // 二进制分组优化, 1, 2, 4, 8, 16, ...
36 while (s ‐ b > 0) {
37 s ‐= b;
38 bone[idx].v = b * v;
39 bone[idx].w = b * w;
40 idx ++;
41 b *= 2;
42 }
43 if (s) {
44 bone[idx].v = s * v;
45 bone[idx].w = s * w;
46 idx ++;
47 }
Nanchang university ACM template 第 65 页
48 }
49 for (int i = 1; i < idx; ++ i)
50 for (int j = m; j >= bone[i].v; ‐‐ j)
51 dp[j] = max(dp[j], dp[j ‐ bone[i].v] + bone[i].w);
52 printf("%d\n", dp[m]);
53 return 0;
54 }
4.3.3.3 多重背包问题 III-单调队列优化.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：03‐单调队列优化.cpp
4 * 创建日期：2021年04月07日 ‐‐‐‐ 17时52分 5 * 创建日期：2021年10月18日 星期一 20时16分52秒 6 * 题 目：AcWing 0006 多重背包问题 7 * 算 法：多重背包，单调队列优化 8 * 描 述：执行单调队列的三个惯例操作 9 * 1. 检查队头合法性
10 * 2. 取队头为最优策略，更新
11 * 3. 把新策略插入队尾，入队前检查队尾单调性，排除无用决策
12 *
13 * 0 < n < 1000
14 * 0 < m < 20000
15 * 0 < v, w, s < 20000
16 *
17 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
18
19 #include <cstdio>
20 #include <algorithm>
21 #include <cstring>
22 using namespace std;
23 const int maxn = 2e4 + 5;
24 int n, m;
25 int dp[maxn], tmp[maxn];
26 int q[maxn];
27
28 int main() {
29 scanf("%d %d", &n, &m);
30 for (int i = 0; i < n; ++ i) {
31 int v, w, s; // 体积，价值，当前物品数量
32 scanf("%d %d %d", &v, &w, &s);
33 memcpy(tmp, dp, sizeof dp); // tmp 为 dp[i ‐ 1]，dp 为 dp[i]，有滚动数组的味道了
34 /*
35 * 枚举余数即等价类
36 * 背包体积，j < v 是因为 v 可以由 j = 0 + v 得到
37 * 每个等价类有0, 0+1v, 0+2v, 0+3v ... ‐> 每个 for(j) 进行单调队列操作，为了找出这个等价类中最大的价值
38 * 1, 1+1v, 1+2v, 1+3v ...
39 * 2, 2+1v, 2+2v, 2+3v ...
40 * ...
41 * v‐1, ...
42 * 所有等价类中的数就是0 ~ m，也就是背包的第二维
43 */
44 for (int j = 0; j < v; ++ j) {
45 int hh = 0, tt = ‐1;
46 for (int k = j; k <= m; k += v) {
47 // 如果当前位置表示的背包体积 > 队首体积 + 当前物品总体积，很显然队首体积不合法了，出队
48 if (hh <= tt && q[hh] < k ‐ s * v)
49 ++ hh;
50 /*
51 * 使用tmp，决策上一件物品是队首体积时的最优解+队首体积到当前体积需要的当前物品总价值
52 *
53 * |‐‐‐‐‐‐‐ q[hh]指向的位置，tmp[q[hh]] 存储这里的最优解（背包体积为 q[hh] 时，最大价值）
54 * v
55 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
56 * | | | | | | | | | | | | | | | | | | | | | | | | |
57 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
58 * | | | | | | | | | | | | | | | | | | | | | | | | |
59 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
Nanchang university ACM template 第 66 页
60 * ^ ^
61 * |‐‐‐ 填充到当前体积需要的物品数(k ‐ q[hh]) / v * w ‐‐‐|
62 */
63 if (hh <= tt)
64 dp[k] = max(dp[k], tmp[q[hh]] + (k ‐ q[hh]) / v * w);
65 /*
66 * tmp[q[tt]] 放入上一件物品体积在队尾体积处时的最大价值
67 * (q[tt] ‐ j) / v * w 等价类的第一个体积到队尾体积全部填充当前物品所需要的总价值
68 * tmp[k] 放入上一件物品体积在当前体积处时的最大价值
69 * (k ‐ j) / v * w 等价类的第一个体积到当前体积全部填充当前物品所需要的总价值
70 *
71 * 在动态转移方程里是tmp[q[hh]] + (k ‐ q[hh]) / v * w
72 * 也就是最近的k个物品的决策里的最大值
73 * 但为什么在这里就是tmp[q[tt]] ‐ (q[tt] ‐ j) / v * w 呢
74 *
75 * 前 a‐1 个数在单调队列中的决策
76 * dp[k] = max(dp[k], dp[k‐v]+w, dp[k‐2v]+2w, dp[k‐3v]+3w, ...)
77 * 在单调队列中无法实现，转化为
78 * dp[k]‐(k‐j)/v*w, dp[k‐v]‐(k‐v‐j)/v*w, dp[k‐2v]‐(k‐2v‐j)/v*w, ...
79 * 会发现，上下两式各项都相差(k‐j)/v*w，所以可以转化
80 *
81 * 队列中肯定要放最大值，这里的最大值还要根据k的位置确定，因为在求dp[k]时，队首元素到
82 * 当前位置k所需要的(k‐q[hh])/v*w是随着k的变化而变化的，所以队列中不能存储确定的值，只能存储位置
83 * 对于当前位置，队列中的元素到达当前位置的总价值是无法确定的，但是到达等价类的第一个位置的总价值是
84 * 确定的，而且等价类的第一个位置到当前位置的总价值也是确定的，所以单调队列中存储的本应是前a个位置到
85 * 达当前位置的总价值由大到小排序(部分不满足由大到小的位置出队)，然而到达当前位置的总价值无法确定，所 以
86 * 转化为到达等价类第一个位置的总价值
87 */
88 while (hh <= tt && tmp[q[tt]] ‐ (q[tt] ‐ j) / v * w <= tmp[k] ‐ (k ‐ j) / v * w)
89 ‐‐ tt;
90 // 无论如何，将当前位置插入队列
91 q[ ++ tt] = k;
92 }
93 }
94 }
95 printf("%d\n", dp[m]);
96 return 0;
97 }
4.3.4 混合背包
4.3.4.1 混合背包问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐混合背包.cpp
4 * 创建日期：2021年04月07日 ‐‐‐‐ 17时56分 5 * 创建日期：2021年10月25日 星期一 08时30分20秒 6 * 题 目：AcWing 0007 混合背包问题 7 * 算 法：混合背包 8 * 描 述：转化为多重背包二进制优化 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1000 + 5;
16 int dp[10 * maxn];
17
18 int main() {
19 int n, m;
20 scanf("%d %d", &n, &m);
21 for (int i = 0; i < n; ++ i) {
22 int v, w, s; // 体积，价值，数量
23 scanf("%d %d %d", &v, &w, &s);
24 if (s == 0) { // 完全背包
25 for (int j = v; j <= m; ++ j)
26 dp[j] = max(dp[j], dp[j ‐ v] + w);
Nanchang university ACM template 第 67 页
27 }
28 else { // 多重背包或01背包
29 if (s == ‐1) // 01背包是特殊的多重背包
30 s = 1;
31 int b = 1;
32 while (s ‐ b > 0) {
33 for (int j = m; j >= b * v; ‐‐ j)
34 dp[j] = max(dp[j], dp[j ‐ b * v] + b * w);
35 s ‐= b;
36 b *= 2;
37 }
38 if (s) {
39 for (int j = m; j >= s * v; ‐‐ j)
40 dp[j] = max(dp[j], dp[j ‐ s * v] + s * w);
41 }
42 }
43 }
44 printf("%d\n", dp[m]);
45 return 0;
46 }
4.3.5 二维费用背包
4.3.5.1 二维费用的背包问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐二维费用的背包问题.cpp
4 * 创建日期：2021年04月28日 ‐‐‐‐ 10时37分 5 * 创建日期：2021年10月25日 星期一 08时56分17秒 6 * 题 目：AcWing 0008 二维费用问题 7 * 算 法：二维费用背包 8 * 描 述：
9 * 有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M
10 * 每件物品只能用一次 体积是 vi，重量是 mi，价值是 wi
11 * 求解将哪些物品装入背包，可使物品总体积不超过背包容量
12 * 总重量不超过背包可承受的最大重量，且价值总和最大
13 *
14 * 0 < N <= 1000
15 * 0 < V, M <= 100
16 * 0 < v, m <= 100
17 * 0 < w <= 1000
18 *
19 * dp[V][M] 表示在体积不超过 V，重量不超过 M，的最大价值
20 *
21 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
22
23 #include <cstdio>
24 #include <algorithm>
25 using namespace std;
26 const int maxn = 1e2 + 5;
27 int dp[maxn][maxn];
28
29 int main() {
30 int N, V, M;
31 scanf("%d %d %d", &N, &V, &M);
32 for (int i = 0; i < N; ++ i) {
33 int v, m, w;
34 scanf("%d %d %d", &v, &m, &w);
35 for (int j = V; j >= v; ‐‐ j)
36 for (int k = M; k >= m; ‐‐ k)
37 dp[j][k] = max(dp[j][k], dp[j ‐ v][k ‐ m] + w);
38 }
39 printf("%d\n", dp[V][M]);
40 return 0;
41 }
Nanchang university ACM template 第 68 页
4.3.6 分组背包
4.3.6.1 分组背包问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：分组背包问题.cpp
4 * 创建日期：2021年10月21日 星期四 19时58分08秒 5 * 题 目：AcWing 0009 分组背包问题 6 * 算 法：动态规划 分组背包 7 * 描 述：有 N 组物品和一个容量是 V 的背包。
8 * 每组物品有若干个，同一组内的物品最多只能选一个。
9 * 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。
10 * 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <algorithm>
16 using namespace std;
17 const int maxn = 100 + 5;
18 int n, m;
19 int dp[maxn];
20 int v[maxn], w[maxn];
21
22 int main() {
23 scanf("%d %d", &n, &m);
24 for (int i = 0; i < n; ++ i) { // 物品组数
25 // 输入
26 int s; scanf("%d", &s);
27 for (int j = 0; j < s; ++ j) // 这组物品信息，体积、价值
28 scanf("%d %d", &v[j], &w[j]);
29
30 /* 动态规划
31 * 其实和 01背包 差不多不是吗
32 * for (int i = 0; i < n; ++ i)
33 * for (int j = m; j >= v[i]; ‐‐ j)
34 * dp[j] = max(dp[j], dp[j ‐ v[i]] + w[i]);
35 *
36 * 分组背包只不过是把一个背包换成一组，多个 for(k) 就行
37 **/
38 for (int j = m; j >= 0; ‐‐ j) // 体积
39 for (int k = 0; k < s; ++ k) // 遍历每个物品
40 if (j >= v[k])
41 dp[j] = max(dp[j], dp[j ‐ v[k]] + w[k]);
42 }
43 printf("%d\n", dp[m]);
44 return 0;
45 }
4.4 区间 DP
4.4.1 回文串.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐回文串.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 17时37分 5 * 题 目：poj3280 Cheapest Palindrome
6 * 算 法：区间DP
7 * 描 述：给定字符串s，长度为m，由n个小写字母构成，在s的任意位置 8 * 增删字母，把它变为回文串，增删特定字母的花费不同，求最小花费 9 * 3 4
10 * abcb
11 * b 350 700
12 * c 200 800
13 * a 1000 1100
14 *
15 * 900
16 *
Nanchang university ACM template 第 69 页
17 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
18
19 #include <iostream>
20 #include <string>
21 #include <algorithm>
22 using namespace std;
23 const int maxn = 2005;
24 int weight[30];
25 int dp[maxn][maxn];
26
27 int main() {
28 int n, m;
29 while (cin >> n >> m) {
30 string str;
31 cin >> str;
32 for (int i = 0; i < n; ++i) {
33 int x, y;
34 char ch;
35 cin >> ch >> x >> y; //读取每个字符的插入和删除花费
36 weight[ch‐'a'] = min(x, y); //取其中的最小值
37 }
38 for (int i = m‐1; i >= 0; ‐‐i) //i是子区间的起点
39 for (int j = i+1; j < m; ++j) { //j是子区间的终点
40 if (str[i] == str[j])
41 dp[i][j] = dp[i+1][j‐1];
42 else
43 dp[i][j] = min(dp[i+1][j] + weight[str[i]‐'a'], dp[i][j‐1] + weight[str[j]‐'a']);
44 }
45 cout << dp[0][m‐1] << endl;
46 }
47 return 0;
48 }
4.4.2 石子合并.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：石子合并.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 17时08分 5 * 创建日期：2021年10月28日 星期四 16时13分02秒 6 * 题 目：AcWing 0282 石子合并 7 * 算 法：区间DP
8 * 描 述：设有 N 堆石子排成一排，其编号为 1, 2, 3, ..., N 9 * 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N
10 * 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为
11 * 这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，
12 * 合并时由于选择的顺序不同，合并的总代价也不相同。
13 *
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
15
16 #include <cstdio>
17 #include <algorithm>
18 using namespace std;
19 const int maxn = 300 + 5;
20 int preS[maxn], dp[maxn][maxn];
21 const int INF = 0x3f3f3f3f;
22
23 int main() {
24 int n; scanf("%d", &n);
25 for (int i = 1; i <= n; ++ i) {
26 scanf("%d", &preS[i]);
27 preS[i] += preS[i ‐ 1];
28 }
29 for (int len = 2; len <= n; ++ len)
30 for (int i = 1; i + len ‐ 1 <= n; ++ i) {
31 int j = i + len ‐ 1;
32 dp[i][j] = INF;
33 for (int k = i; k < j; ++ k)
34 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + preS[j] ‐ preS[i ‐ 1]);
Nanchang university ACM template 第 70 页
35 }
36 printf("%d\n", dp[1][n]);
37 return 0;
38 }
4.5 树形 DP
4.5.1 Anniversary-Party.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Anniversary‐Party.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 18时08分 5 * 题 目：hdu1520 Anniversary Party
6 * 算 法：树形DP
7 * 描 述：一颗有根树上每个结点有一个权值，相邻的父结点和子结点只能选择一个 8 * 问如何选择使得总权值之和最大(邀请员工参加宴会，为了避免员工和直属上司发 9 * 生尴尬，规定员工和直属上司不能同时出席)
10 * 输 入：(规定结点编号从1到N)，输入第一行是一个数字N，后续N行中的每一行都
11 * 包含结点的权值，范围是 ‐128 ~ 127，下面T行分别输入两个结点，后一个结点
12 * 是前一个结点的父亲，读到0 0结束
13 * 5
14 * 1 1 1 1 1
15 * 1 3
16 * 2 3
17 * 4 5
18 * 3 5
19 * 0 0
20 * 输 出：总的最大权值
21 * 3
22 *
23 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
24
25 #include <cstdio>
26 #include <vector>
27 #include <algorithm>
28 using namespace std;
29 const int maxn = 6005;
30 int n;
31 int value[maxn];
32 int dp[maxn][2];
33 int fa[maxn];
34 vector<int> tree[maxn];
35
36 void dfs(int node) {
37 dp[node][0] = 0; //每次都初始化，不参加宴会(不选择当前结点)
38 dp[node][1] = value[node]; //参加宴会(选择当前结点)
39 for (int i = 0; i < tree[node].size(); ++i) {
40 int son = tree[node][i];
41 dfs(son);
42 dp[node][0] += max(dp[son][1], dp[son][0]); //父结点不选，那么子结点可选可不选
43 dp[node][1] += dp[son][0]; //选择父结点，子结点不能选
44 }
45 }
46
47 int main() {
48 while (~scanf("%d", &n)) {
49 for (int i = 1; i <= n; ++i) {
50 scanf("%d", &value[i]);
51 tree[i].clear();
52 fa[i] = ‐1;
53 }
54 while (1) {
55 int a, b;
56 scanf("%d %d", &a, &b);
57 if (a == 0 && b == 0)
58 break;
59 tree[b].push_back(a); //邻接表建树
60 fa[a] = b;
Nanchang university ACM template 第 71 页
61 }
62 int t = 1;
63 while (fa[t] != ‐1)
64 t = fa[t]; //找到根结点
65 dfs(t);
66 printf("%d\n", max(dp[t][1], dp[t][0]));
67 }
68 return 0;
69 }
4.5.2 没有上司的舞会.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：没有上司的舞会.cpp
4 * 创建日期：2021年11月01日 星期一 21时07分35秒 5 * 题 目：AcWing 0285 没有上司的舞会 6 * 算 法：树形DP
7 * 描 述：某大学有 n 个职员，编号为 [1, n]。他们之间有从属关系 8 * 也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司 9 * 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 ai，
10 * 但是呢，如果某个职员的上司来参加舞会了，
11 * 那么这个职员就无论如何也不肯来参加舞会了。
12 * 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。
13 *
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
15
16 #include <cstdio>
17 #include <algorithm>
18 #include <cstring>
19 using namespace std;
20 const int maxn = 6000 + 5;
21 int n, happy[maxn];
22 int dp[maxn][2];
23 int h[maxn], e[maxn], ne[maxn], idx;
24 bool has_father[maxn];
25
26 void add(int a, int b) {
27 e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
28 }
29
30 void DFS(int u) {
31 dp[u][1] = happy[u];
32 for (int i = h[u]; i != ‐1; i = ne[i]) {
33 int j = e[i];
34 DFS(j);
35 dp[u][0] += max(dp[j][0], dp[j][1]);
36 dp[u][1] += dp[j][0];
37 }
38 }
39
40 int main() {
41 scanf("%d", &n);
42 for (int i = 1; i <= n; ++ i)
43 scanf("%d", &happy[i]);
44 memset(h, ‐1, sizeof h);
45 for (int i = 0; i < n ‐ 1; ++ i) {
46 int a, b; // b 是 a 的上司
47 scanf("%d %d", &a, &b);
48 has_father[a] = true;
49 add(b, a);
50 }
51 int root = 1;
52 while (has_father[root])
53 root ++ ;
54
55 DFS(root);
56 printf("%d\n", max(dp[root][0], dp[root][1]));
57 return 0;
Nanchang university ACM template 第 72 页
58 }
4.6 状压 DP
4.6.1 Corn-Fields.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Corn‐Fields.cpp
4 * 创建日期：2021年03月10日 ‐‐‐‐ 20时08分 5 * 题 目：poj3254 Corn Fields
6 * 算 法：状态压缩DP
7 * 描 述：输入一个矩阵，选择不相邻的方格的方案数 8 * | 1 | 2 | 3 | 9 * | | 4 | |
10 * 可以的方案数有{}、{1}、{2}、{3}、{4}、{1, 3}、{1, 4}、{3, 4}、{1, 3, 4}
11 *
12 * 单看第一行，使用二进制描述方格，1表示种玉米，0表示不种玉米
13 * | 编号 | 1 | 2 | 3 | 4 | 5 |
14 * | 方案 | 000 | 001 | 010 | 100 | 101 |
15 *
16 * 单看第二行，使用二进制描述方格，1表示种玉米，0表示不种玉米
17 * | 编号 | 1 | 2 |
18 * | 方案 | 000 | 010 |
19 *
20 * 如果第二行选编号1，第一行可以选五种不冲突方案
21 * 如果第二行选编号2，会与第一行010冲突，其他四种没问题
22 *
23 * dp[i][j]表示第i行采用第j种编号的方案时前i行可以得到
24 * 的可行方案总数
25 * 例如dp[2][2] = 4表示第二行使用第二种方案时的方案总数是4
26 *
27 * 状态转移方程dp[i][k] = dp[i‐1][j] (j From 1 To n)
28 * 最后一行的dp[m][k]相加就得到了答案
29 *
30 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
31
32 //<++>
4.6.2 最短 Hamiton 路径.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最短Hamiton路径.cpp
4 * 创建日期：2021年11月01日 星期一 20时06分05秒 5 * 题 目：AcWing 0091 最短Hamiton路径 6 * 算 法：状压DP
7 * 描 述：给定一张 n 个点的带权无向图，点从 0￾n−1 标号，
8 * 求起点 0 到终点 n−1 的最短 Hamilton 路径。
9 * Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。
10 *
11 * 题目输入：一个数n，然后是 n * n 个整数，第 i 行第 j 列的整数表示
12 * 点 i 到 j 的距离
13 *
14 * 1 <= n <= 20
15 * 0 <= dist[i, j] <= 1e7
16 *
17 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
18
19 #include <cstdio>
20 #include <algorithm>
21 #include <cstring>
22 using namespace std;
23 const int maxn = 20 + 5, maxm = 1 << 20;
24 int dist[maxn][maxn];
25 int n;
26 int dp[maxm][maxn];
Nanchang university ACM template 第 73 页
27
28 int main() {
29 scanf("%d", &n);
30 for (int i = 0; i < n; ++ i)
31 for (int j = 0; j < n; ++ j)
32 scanf("%d", &dist[i][j]);
33 memset(dp, 0x3f, sizeof dp);
34 dp[1][0] = 0;
35 for (int i = 0; i < 1 << n; ++ i) // 遍历当前状态
36 for (int j = 0; j < n; ++ j) // 最后一个点是 j
37 if (i >> j & 1) // 显然需要满足当前状态有 j 这个点
38 for (int k = 0; k < n; ++ k) // 当前状态由当前状态去除最后一个点 j 且最后一个点是 k 的路径转移过 来
39 if (i ‐ (1 << j) >> k & 1) // 显然需要满足这个状态有 k 这个点
40 dp[i][j] = min(dp[i][j], dp[i ‐ (1 << j)][k] + dist[k][j]);
41 printf("%d\n", dp[(1 << n) ‐ 1][n ‐ 1]);
42 return 0;
43 }
4.6.3 蒙德里安的梦想.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：蒙德里安的梦想.cpp
4 * 创建日期：2021年11月01日 星期一 08时49分37秒 5 * 题 目：AcWing 0291 蒙德里安的梦想 6 * 算 法：状压DP
7 * 描 述：求把 N * M 的棋盘分割成若干个 1 * 2 的长方形，有多少 8 * 种方案 9 *
10 * 例如 N = 2, M = 3 有 3 种方案
11 *
12 * |‐‐‐‐‐‐‐‐|‐‐‐‐| |‐‐‐‐|‐‐‐‐‐‐‐‐| |‐‐‐‐|‐‐‐‐|‐‐‐‐|
13 * | | | | | | | | | |
14 * |‐‐‐‐‐‐‐‐| | | |‐‐‐‐‐‐‐‐| | | | |
15 * | | | | | | | | | |
16 * |‐‐‐‐‐‐‐‐|‐‐‐‐| |‐‐‐‐|‐‐‐‐‐‐‐‐| |‐‐‐‐|‐‐‐‐|‐‐‐‐|
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <vector>
22 #include <cstring>
23 using namespace std;
24 const int maxn = 12, maxm = 1 << maxn;
25 typedef long long ll;
26 int n, m;
27 // dp[i][j] 表示已经将前 i ‐ 1 列放好，第 i ‐ 1 列中横放的方块占据第 i 列的状态为 j 的方案数
28 ll dp[maxn][maxm];
29 vector<int> state[maxm];
30 bool used[maxm];
31
32
33 /*
34 * 这里是第 i ‐ 1 列 ‐‐| |‐‐ 这里是第 i 列
35 * V V
36 * |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
37 * | | | | | | | | | | | |
38 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
39 * | | | | | | | | | | | |
40 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
41 * | | | + | | | | | | | | | |
42 * | | |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
43 * | | | + | | | | | | | | | |
44 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
45 * | | | | | | | | | | | |
46 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
47 * | | | + | | | | | | | | | |
48 * | | |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
Nanchang university ACM template 第 74 页
49 * | | | + | | | | | | | | | |
50 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
51 * | | | | | | | | | | | |
52 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
53 * | | | + | | | | | | | | | |
54 * | | |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
55 * | | | + | | | | | | | | | |
56 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
57 * | | | + | | | | | | | | | |
58 * | | |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
59 * | | | + | | | | | | | | | |
60 * | |‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
61 * | | | | | | | | | | | |
62 * |‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐‐‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|‐‐‐|
63 *
64 * 在这个图中，第 i 列可能部分位置被第 i ‐ 1 列横放的方块占据
65 * 对于第 i 列来说，被占据的位置用 1 表示，没被占据的位置用 0 表示
66 * 则可以用一个二进制数表示这一列当前的状态，在这里是：1100100100001
67 *
68 * 这个状态成立的条件之一就是没被占据的空位置的长度都必须是偶数
69 *
70 */
71
72 int main() {
73 while (scanf("%d %d", &n, &m) && (n || m)) {
74 // 预处理当前状态 i 是否存在，也就是没有奇数长度的空位置
75 for (int i = 0; i < 1 << n; ++ i) {
76 int cnt = 0; // 这个空位的长度
77 bool is_valid = true; // 判断是否合法，如果有奇数个零，表示不合法
78 for (int j = 0; j < n; ++ j) {
79 if (i >> j & 1) {
80 if (cnt & 1) {
81 is_valid = false;
82 break;
83 }
84 cnt = 0;
85 }
86 else {
87 cnt ++ ;
88 }
89 }
90 if (cnt & 1) // 还要判断最后一个空的长度
91 is_valid = false;
92 used[i] = is_valid;
93 }
94 for (int i = 0; i < 1 << n; ++ i) {
95 state[i].clear();
96 for (int j = 0; j < 1 << n; ++ j)
97 if ((i & j) == 0 && used[i | j])
98 // 对于前一列的状态 i 来说，当前列的状态 j 是满足的
99 // 对于当前列的状态 i 来说，前一列的状态 j 是满足的
100 state[i].push_back(j);
101 }
102 memset(dp, 0, sizeof dp);
103 dp[0][0] = 1;
104 for (int i = 1; i <= m; ++ i)
105 for (int j = 0; j < 1 << n; ++ j) // i ‐ 1 列横放的方块占据的第 i 列的状态为 j
106 for (auto k : state[j]) // 第 i ‐ 1 列是怎么放的
107 dp[i][j] += dp[i ‐ 1][k];
108 printf("%lld\n", dp[m][0]);
109 }
110 return 0;
111 }
4.7 数位 DP
4.7.1 不要 4-递推.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
Nanchang university ACM template 第 75 页 2 * 3 * 文件名称：01‐不要4‐递推.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 21时57分 5 * 题 目：hdu2089 不要62
6 * 算 法：数位DP
7 * 描 述：一个数字如果包含‘4’或者'62'，它是不吉利的，给定m和n 8 * 0 < m < n < 1e6，统计[m, n]范围内的吉利数 9 * 只是为了理解数位DP，所以简化题目要求，只排除了'4'
10 * dp[i][j]表示i位数中首位是j，符合要求的数的个数
11 * 递推公式dp[i][j] = dp[i‐1][k] (k From 0 To 9) && (j != 4) && (k != 2 && j != 6)
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 12; //可以更大
17 int dp[maxn+1][10]; //dp[i][j]表示i位数，第1位数是j时符合条件的数字数量
18 int digit[maxn+1]; //digit[i]存第i位数字
19 void init() {
20 dp[0][0] = 1;
21 for (int i = 1; i <= maxn; ++i)
22 for (int j = 0; j < 10; ++j)
23 for (int k = 0; k < 10; ++k)
24 if (j != 4) //排除数字4
25 dp[i][j] += dp[i‐1][k];
26 }
27
28 /*计算0 ~ n区间满足条件的数字个数*/
29 int solve(int len) {
30 int res = 0;
31 for (int i = len; i >= 1; ‐‐i) { //从高位到低位处理
32 for (int j = 0; j < digit[i]; ++j)
33 if (j != 4)
34 res += dp[i][j];
35 if (digit[i] == 4) { //第i位是4，以4开头的2数都不行
36 ‐‐res;
37 break;
38 }
39 }
40 return res;
41 }
42
43 int main() {
44 int n;
45 int len = 0;
46 init(); //预计算dp[][]
47 scanf("%d", &n);
48 while (n) { //len是n的位数，例如n = 324，是3位数，len = 3
49 digit[++len] = n % 10; //digit[3] = 3, digit[2] = 2, digit[1] = 4
50 n /= 10;
51 }
52 printf("%d\n", solve(len) + 1); //求0 ~ n不含4的个数
53 return 0;
54 }
4.7.2 不要 4-记忆化.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐不要4‐记忆化.cpp
4 * 创建日期：2021年03月10日 ‐‐‐‐ 08时12分 5 * 题 目：hdu2089 不要62
6 * 算 法：数位DP
7 * 描 述：一个数字如果包含‘4’或者'62'，它是不吉利的，给定m和n 8 * 0 < m < n < 1e6，统计[m, n]范围内的吉利数 9 * 只是为了理解数位DP，所以简化题目要求，只排除了'4'
10 * 记忆化搜索的思路就是在递归dfs()中搜索所有可能的情况，遇到已
11 * 经算过的记录在dp[]中的结果就直接使用，不再重复计算
12 * dp[i]表示i位数中符合条件的数字个数
13 *
Nanchang university ACM template 第 76 页
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
15
16 #include <cstdio>
17 #include <cstring>
18 const int maxn = 12;
19 int dp[maxn]; //dp[i]表示i位数符合要求的个数，dp[2]表示00 ~ 99内符合要求的个数
20 int digit[maxn];
21 int dfs(int len, int ismax) { //如果ismax == 1，
22 int res = 0;
23 int maxx;
24 if (!len) //已经递归到0位数，返回
25 return 1;
26 if (!ismax && dp[len] != ‐1) //记忆化搜索，如果已经计算过，就直接使用
27 return dp[len];
28 maxx = (ismax ? digit[len] : 9); //用来判断搜索到什么位置，比如324在十位只用搜索到2
29 for (int i = 0; i <= maxx; ++i) {
30 if (i == 4) //排除4
31 continue;
32 res += dfs(len‐1, ismax && i == maxx);
33 }
34 if (!ismax)
35 dp[len] = res;
36 return res;
37 }
38
39 int main() {
40 int n;
41 int len = 0;
42 memset(dp, ‐1, sizeof(dp));
43 scanf("%d", &n);
44 while(n) {
45 digit[++len] = n % 10;
46 n /= 10;
47 }
48 printf("%d\n", dfs(len, 1));
49 return 0;
50 }
4.7.3 不要 4-递推.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐不要4‐递推.cpp
4 * 创建日期：2021年03月09日 ‐‐‐‐ 21时57分 5 * 题 目：hdu2089 不要62
6 * 算 法：数位DP
7 * 描 述：一个数字如果包含‘4’或者'62'，它是不吉利的，给定m和n 8 * 0 < m < n < 1e6，统计[m, n]范围内的吉利数 9 * 只是为了理解数位DP，所以简化题目要求，只排除了'4'
10 * dp[i][j]表示i位数中首位是j，符合要求的数的个数
11 * 递推公式dp[i][j] = dp[i‐1][k] (k From 0 To 9) && (j != 4) && (k != 2 && j != 6)
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 12; //可以更大
17 int dp[maxn+1][10]; //dp[i][j]表示i位数，第1位数是j时符合条件的数字数量
18 int digit[maxn+1]; //digit[i]存第i位数字
19 void init() {
20 dp[0][0] = 1;
21 for (int i = 1; i <= maxn; ++i)
22 for (int j = 0; j < 10; ++j)
23 for (int k = 0; k < 10; ++k)
24 if (j != 4) //排除数字4
25 dp[i][j] += dp[i‐1][k];
26 }
27
28 /*计算0 ~ n区间满足条件的数字个数*/
29 int solve(int len) {
Nanchang university ACM template 第 77 页
30 int res = 0;
31 for (int i = len; i >= 1; ‐‐i) { //从高位到低位处理
32 for (int j = 0; j < digit[i]; ++j)
33 if (j != 4)
34 res += dp[i][j];
35 if (digit[i] == 4) { //第i位是4，以4开头的2数都不行
36 ‐‐res;
37 break;
38 }
39 }
40 return res;
41 }
42
43 int main() {
44 int n;
45 int len = 0;
46 init(); //预计算dp[][]
47 scanf("%d", &n);
48 while (n) { //len是n的位数，例如n = 324，是3位数，len = 3
49 digit[++len] = n % 10; //digit[3] = 3, digit[2] = 2, digit[1] = 4
50 n /= 10;
51 }
52 printf("%d\n", solve(len) + 1); //求0 ~ n不含4的个数
53 return 0;
54 }
4.7.4 计数问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：计数问题.cpp
4 * 创建日期：2021年10月31日 星期日 22时03分14秒 5 * 题 目：AcWing 0338 计数问题 6 * 算 法：数位DP
7 * 描 述：给定两个整数 a 和 b，求 a 和 b 之间所有数字中 [0, 9]
8 * 的出现次数 9 *
10 * 例如：a = 1024，b = 1032，则 a 和 b 之间的 9 个数：
11 *
12 * 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032
13 *
14 * 其中 0 出现 10 次；1 出现 10 次；2 出现 7 次 ......
15 *
16 * 0 < a, b < 1e8
17 *
18 * 多组输入，输入两个 0 结束输入。
19 *
20 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
21
22 #include <cstdio>
23 #include <algorithm>
24 #include <vector>
25 using namespace std;
26 #define NEXTLINE puts("");
27
28 // 算出前面的数字 abc
29 int get(vector<int> num, int l, int r) {
30 int res = 0;
31 for (int i = l; i >= r; ‐‐ i)
32 res = res * 10 + num[i];
33 return res;
34 }
35
36 // 后面还有 x 个数字，10^x
37 int power10(int x) {
38 int res = 1;
39 while (x ‐‐ )
40 res *= 10;
41 return res;
Nanchang university ACM template 第 78 页
42 }
43
44
45 // 从 1 到 n 中 x 出现的次数
46 int count(int n, int x) {
47 if (!n)
48 return 0;
49 vector<int> num;
50 // n 的每一位是什么
51 while (n) {
52 num.push_back(n % 10);
53 n /= 10;
54 }
55 n = num.size(); // n 现在是 n 的位数
56 int res = 0;
57 // 从最高位上开始枚举
58 for (int i = n ‐ 1 ‐ !x; i >= 0; ‐‐ i) {
59 // 只有 i < n ‐ 1 才会出现前面有数，abcdefg
60 // ^ 前面要有数字
61 if (i < n ‐ 1) {
62 res += get(num, n ‐ 1, i + 1) * power10(i);
63 if (!x)
64 res ‐= power10(i);
65 }
66 if (num[i] == x)
67 res += get(num, i ‐ 1, 0) + 1;
68 else if (num[i] > x)
69 res += power10(i);
70 }
71 return res;
72 }
73
74 int main() {
75 int a, b;
76 while (scanf("%d %d", &a, &b) && (a || b)) {
77 if (a > b)
78 swap(a, b);
79 for (int i = 0; i < 10; ++ i)
80 printf("%d ", count(b, i) ‐ count(a ‐ 1, i));
81 NEXTLINE;
82 }
83 return 0;
84 }
4.8 计数 DP
4.8.1 整数划分-完全背包.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：整数划分.cpp
4 * 创建日期：2021年10月28日 星期四 16时51分46秒 5 * 题 目：AcWing 0900 整数划分 6 * 算 法：完全背包 7 * 描 述：一个正整数 n 可以表示成若干个正整数之和，
8 * 形如：n = n1 + n2 + ... + nk， 9 * 其中 n1 >= n2 >= ... >= nk,k >= 1
10 * 我们将这样的一种表示称为正整数 n 的一种划分。
11 * 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。
12 *
13 *
14 * 有一个体积为 n 的背包，和体积分别为 1, 2, 3, ..., n 的物品
15 * 问装满这个背包的选法有多少种
16 *
17 * dp[i][j]: 从 [1, i] 中选总体积恰好为 j 的选法的数量
18 *
19 * dp[i][j] = dp[i ‐ 1][j] + dp[i ‐ 1][j ‐ i] + dp[i ‐ 1][j ‐ 2i]
20 * + dp[i ‐ 1][j ‐ 3i] + ... + dp[i ‐ 1][j ‐ si]
21 *
Nanchang university ACM template 第 79 页
22 * 表示从 [1, i ‐ 1] 中选总体积恰好为 j ‐ ki 的选法的数量
23 *
24 * dp[i][j ‐ i] = dp[i ‐ 1][j ‐ i] + dp[i ‐ 1][j ‐ 2i]
25 * + dp[i ‐ 1][j ‐ 3i] + ... + dp[i ‐ 1][j ‐ si]
26 *
27 * 所以有：dp[i][j] = dp[i ‐ 1][j] + dp[i][j ‐ i];
28 *
29 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
30
31 #include <cstdio>
32 const int maxn = 1e3 + 5, MOD = 1e9 + 7;
33 int dp[maxn];
34
35 int main() {
36 int n; scanf("%d", &n);
37 dp[0] = 1; // 总体积恰好为 0 的选法的方案数是一
38 for (int i = 1; i <= n; ++ i)
39 for (int j = i; j <= n; ++ j)
40 dp[j] = (dp[j] + dp[j ‐ i]) % MOD;
41 printf("%d\n", dp[n]);
42 return 0;
43 }
4.8.2 整数划分-计数 DP.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：整数划分‐计数DP.cpp
4 * 创建日期：2021年10月31日 星期日 16时08分19秒 5 * 题 目：AcWing 0900 整数划分 6 * 算 法：计数DP
7 * 描 述：一个正整数 n 可以表示成若干个正整数之和，
8 * 形如：n = n1 + n2 + ... + nk， 9 * 其中 n1 >= n2 >= ... >= nk,k >= 1
10 * 我们将这样的一种表示称为正整数 n 的一种划分。
11 * 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。
12 *
13 * dp[i][j]: 所有总和是 i，并且恰好表示成 j 个数的和的方案数量
14 *
15 * dp[i][j]: dp[i ‐ 1][j ‐ 1] + dp[i ‐ j][j];
16 *
17 * 分为两种情况：
18 * 1. 这 j 个数中最小值是 1，那么把这个 1 给去掉，就有 j ‐ 1 个数
19 * 的总和是 i ‐ 1
20 * 2. 这 j 个数中最小值不是 1，那么把这 j 个数都减 1，就还是 j 个
21 * 数，总和变成了 i ‐ j
22 * 显然所有的数的组合都被这两种情况所涵盖，且不重合
23 *
24 * 就有：dp[i][j]: dp[i ‐ 1][j ‐ 1] + dp[i ‐ j][j];
25 *
26 * 最后的结果是 dp[n][1] + dp[n][2] + ... + dp[n][n]
27 *
28 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
29
30 #include <cstdio>
31 const int maxn = 1e3 + 5, MOD = 1e9 + 7;
32 int dp[maxn][maxn];
33
34 int main() {
35 int n; scanf("%d", &n);
36 dp[0][0] = 1; // 所有总和是 0，并且恰好表示成 0 个数的和的方案数量
37 for (int i = 1; i <= n; ++ i)
38 for (int j = 1; j <= i; ++ j)
39 dp[i][j] = (dp[i ‐ 1][j ‐ 1] + dp[i ‐ j][j]) % MOD;
40 int res = 0;
41 for (int j = 1; j <= n; ++ j)
42 res = (res + dp[n][j]) % MOD;
43 printf("%d\n", res);
44 return 0;
Nanchang university ACM template 第 80 页
45 }
4.9 线性 DP
4.9.1 数字三角形.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：数字三角形.cpp
4 * 创建日期：2021年10月25日 星期一 19时36分09秒 5 * 题 目：AcWing 0898 数字三角形 6 * 算 法：线性DP
7 * 描 述：
8 * 给定一个如下图所示的数字三角形，从顶部出发 9 * 在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点
10 * 一直走到底层，要求找出一条路径，使路径上的数字的和最大。
11 *
12 * 7
13 * 3 8
14 * 8 1 0
15 * 2 7 4 4
16 * 4 5 2 6 5
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <algorithm>
22 using namespace std;
23 const int maxn = 500 + 5;
24 int a[maxn][maxn], dp[maxn][maxn];
25
26 int main() {
27 int n; scanf("%d", &n);
28 for (int i = 1; i <= n; ++ i)
29 for (int j = 1; j <= i; ++ j)
30 scanf("%d", &a[i][j]);
31 for (int i = 1; i <= n; ++ i)
32 dp[n][i] = a[n][i];
33 for (int i = n ‐ 1; i; ‐‐ i)
34 for (int j = 1; j <= i; ++ j)
35 dp[i][j] = max(dp[i + 1][j] + a[i][j], dp[i + 1][j + 1] + a[i][j]);
36 printf("%d\n", dp[1][1]);
37 return 0;
38 }
4.9.2 最短编辑距离.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最短编辑距离.cpp
4 * 创建日期：2021年10月27日 星期三 21时07分54秒 5 * 题 目：AcWing 0902 最短编辑距离 6 * 算 法：线性DP
7 * 描 述：给定两个字符串 A 和 B 8 * 现在要将 A 经过若干操作变为 B，可进行的操作有：
9 * 删除 – 将字符串 A 中的某个字符删除。
10 * 插入 – 在字符串 A 的某个位置插入某个字符。
11 * 替换 – 将字符串 A 中的某个字符替换为另一个字符。
12 * 现在请你求出，将 A 变为 B 至少需要进行多少次操作。
13 *
14 * 0 <= n <= 1000, 0 <= m <= 1000
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
17
18 #include <cstdio>
19 #include <algorithm>
20 using namespace std;
Nanchang university ACM template 第 81 页
21 const int maxn = 1e3 + 5;
22 int n, m;
23 char a[maxn], b[maxn];
24 int dp[maxn][maxn];
25
26 int main() {
27 scanf("%d %s", &n, a + 1);
28 scanf("%d %s", &m, b + 1);
29 // 初始化
30 for (int i = 1; i <= n; ++ i)
31 dp[i][0] = i; // 将a的前i个字符与b的前0个字符匹配，删i次
32 for (int j = 1; j <= m; ++ j)
33 dp[0][j] = j; // 将a的前0个字符与b的前j个字符匹配，增j次
34
35 for (int i = 1; i <= n; ++ i)
36 for (int j = 1; j <= m; ++ j) {
37 dp[i][j] = min(dp[i ‐ 1][j] + 1, dp[i][j ‐ 1] + 1);
38 if (a[i] == b[j])
39 dp[i][j] = min(dp[i][j], dp[i ‐ 1][j ‐ 1]);
40 else
41 dp[i][j] = min(dp[i][j], dp[i ‐ 1][j ‐ 1] + 1);
42 }
43 printf("%d\n", dp[n][m]);
44 return 0;
45 }
4.9.3 最长上升子序列 I.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最长上升子序列.cpp
4 * 创建日期：2021年10月25日 星期一 19时57分02秒 5 * 题 目：AcWing 0895 最长上升子序列 6 * 算 法：线性DP
7 * 描 述：
8 * 给一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1000 + 5;
16 int sequ[maxn];
17 int dp[maxn];
18
19 int main() {
20 int n; scanf("%d", &n);
21 for (int i = 1; i <= n; ++ i)
22 scanf("%d", &sequ[i]);
23 for (int i = 1; i <= n; ++ i) {
24 dp[i] = 1;
25 for (int j = 1; j < i; ++ j)
26 if (sequ[j] < sequ[i])
27 dp[i] = max(dp[i], dp[j] + 1);
28 }
29 int res = 0;
30 for (int i = 1; i <= n; ++ i)
31 res = max(res, dp[i]);
32 printf("%d\n", res);
33 return 0;
34 }
4.9.4 最长上升子序列 II.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 *
Nanchang university ACM template 第 82 页 3 * 文件名称：最长上升子序列II.cpp
4 * 创建日期：2021年10月25日 星期一 20时09分03秒 5 * 题 目：AcWing 0896 最长上升子序列II
6 * 算 法：线性DP
7 * 描 述：
8 * 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少 9 *
10 * 还要输出这个最长上升子序列
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <algorithm>
16 using namespace std;
17 const int maxn = 1e5 + 5;
18 int a[maxn], // 原序列
19 mini[maxn]; // 所有长度下结尾的最小值
20 const int INF = 0x3f3f3f3f;
21
22 int main() {
23 int n; scanf("%d", &n);
24 for (int i = 0; i < n; ++ i)
25 scanf("%d", &a[i]);
26 int len = 0; // 当前的最大长度
27 mini[0] = ‐INF; // 为了使比当前的数还小的数存在
28 for (int i = 0; i < n; ++ i) {
29 int l = 0, r = len;
30 // 找到在 mini[] 地一个小于 a[i] 的数
31 while (l < r) {
32 // [l, mid ‐ 1] [mid, r]
33 int mid = l + r + 1 >> 1;
34 if (mini[mid] < a[i])
35 l = mid;
36 else
37 r = mid ‐ 1;
38 }
39 len = max(len, r + 1);
40 /**
41 * 我们二分找到第一个小于 a[i] 的数就是 mini[l] = mini[r]
42 * 那么就一定有 a[i] 大于等于 mini[l + 1] = mini[r + 1]
43 * 所以更新 mini[r + 1]
44 * mini[r + 1] = a[i]
45 * 最大长度为 r + 1 的子序列的结尾是 a[i]
46 */
47 mini[r + 1] = a[i];
48 }
49 printf("%d\n", len);
50 return 0;
51 }
4.9.5 最长公共子序列.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最长公共子序列.cpp
4 * 创建日期：2021年10月26日 星期二 21时28分44秒 5 * 题 目：AcWing 0897 最长公共子序列 6 * 算 法：线性DP
7 * 描 述：给定两个长度分别为 N 和 M 的字符串 A 和 B 8 * 求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 1e3 + 5;
16 int n, m;
17 char a[maxn], b[maxn];
Nanchang university ACM template 第 83 页
18 int dp[maxn][maxn];
19
20 int main() {
21 scanf("%d %d", &n, &m);
22 scanf("%s %s", a + 1, b + 1);
23 for (int i = 1; i <= n; ++ i)
24 for (int j = 1; j <= m; ++ j) {
25 dp[i][j] = max(dp[i ‐ 1][j], dp[i][j ‐ 1]);
26 if (a[i] == b[j])
27 dp[i][j] = max(dp[i][j], dp[i ‐ 1][j ‐ 1] + 1);
28 }
29 printf("%d\n", dp[n][m]);
30 return 0;
31 }
4.9.6 编辑距离.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：编辑距离.cpp
4 * 创建日期：2021年10月27日 星期三 21时54分18秒 5 * 题 目：AcWing 0899 编辑距离 6 * 算 法：线性DP
7 * 描 述：给定 n 个长度不超过 10 的字符串以及 m 次询问 8 * 每次询问给出一个字符串和一个操作次数上限。
9 * 对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以
10 * 在上限操作次数内经过操作变成询问给出的字符串。
11 * 每个对字符串进行的单个字符的插入、删除或替换算作一次操作。
12 *
13 * 0 <= n <= 1000, 0 <= m <= 1000
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <algorithm>
19 #include <cstring>
20 using namespace std;
21 const int maxn = 10 + 5, maxm = 1e3 + 5;;
22 int n, m;
23 int dp[maxn][maxn];
24 char str[maxm][maxn];
25
26 int edit_distance(char a[], char b[]) {
27 int len_a = strlen(a + 1),
28 len_b = strlen(b + 1);
29 for (int i = 0; i <= len_a; ++ i)
30 dp[i][0] = i;
31 for (int j = 0; j <= len_b; ++ j)
32 dp[0][j] = j;
33 for (int i = 1; i <= len_a; ++ i)
34 for (int j = 1; j <= len_b; ++ j) {
35 dp[i][j] = min(dp[i ‐ 1][j] + 1, dp[i][j ‐ 1] + 1);
36 dp[i][j] = min(dp[i][j], dp[i ‐ 1][j ‐ 1] + (a[i] != b[j]));
37 }
38 return dp[len_a][len_b];
39 }
40
41 int main() {
42 scanf("%d %d", &n, &m);
43 for (int i = 0; i < n; ++ i)
44 scanf("%s", str[i] + 1);
45 while (m ‐‐ ) {
46 char s[maxn];
47 int limit;
48 scanf("%s %d", s + 1, &limit);
49 int res = 0;
50 for (int i = 0; i < n; ++ i)
51 if (edit_distance(str[i], s) <= limit)
52 res ++ ;
Nanchang university ACM template 第 84 页
53 printf("%d\n", res);
54 }
55 return 0;
56 }5 字符串
5.1 字符串哈希
5.1.1 字符串哈希.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月11日 星期三 00时17分16秒 5 * 题 目：AcWing 0841 字符串哈希 6 * 算 法：哈希 7 * 描 述：预处理所有前缀的哈希 8 * hash? 9 * [高位] <‐‐‐‐‐‐‐‐‐> [低位]
10 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
11 * 1 L R
12 * ^
13 * |‐‐‐‐ 从1开始，
14 *
15 *
16 * 我们现在已知ha[L‐1]，ha[R]
17 *
18 * ha[L‐1]: 表示下面这个子串的哈希值
19 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
20 * 1 L ‐ 1
21 *
22 * ha[R]: 表示下面这个长的子串的哈希值
23 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐|
24 * 1 L R
25 *
26 * 让上面的两个串的高位对齐、相减得到我们想要表示出[L, R]区间的哈希值
27 * $hash = ha[R] ‐ ha[L] * p^{R ‐ L + 1};$
28 *
29 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
30
31 #include <cstdio>
32 typedef unsigned long long ull;
33 const int maxn = 1e5 + 5;
34 int P = 131; // P进制数，虽然没写Q = 2^64，但是ull溢出隐藏了这一步
35 int n, m;
36 char str[maxn];
37 ull ha[maxn], p[maxn]; // 发现公式中需要乘一个p的一个指数，所以用一个数组预处理
38
39 ull get(int l, int r) {
40 return ha[r] ‐ ha[l ‐ 1] * p[r ‐ l + 1];
41 }
42
43 int main() {
44 scanf("%d %d", &n, &m);
45 scanf("%s", str + 1);
46 p[0] = 1; // p^0 = 1;
47 for (int i = 1; i <= n; ++i) { // 预处理p数组，与前缀子串哈希
48 p[i] = p[i‐1] * P;
49 // P是131，这是一个131进制的数，一个131进制的数的一个位上出现'z' = 122有问题吗？
50 // 我告诉你，显然没问题
51 ha[i] = ha[i‐1] * P + str[i]; // woc，不用str[i] ‐ 'a' + 1，神了
52 }
53 while (m ‐‐) {
54 int l1, r1, l2, r2;
55 scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
56 if (get(l1, r1) == get(l2, r2))
57 printf("Yes\n");
58 else
Nanchang university ACM template 第 85 页
59 printf("No\n");
60 }
61 return 0;
62 }
5.1.2 拉链法.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：拉链法.cpp
4 * 创建日期：2021年08月10日 星期二 10时57分04秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：数学上可以证明，mod一个素数，产生的冲突概率较小 8 * 所以我们需要先寻找一个素数，而且这里把最大值设为N，而不是maxn了 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <cstring>
14 const int N = 1e5 + 3;
15 int ha[N];
16 int e[N], ne[N], idx;
17
18 // 运行之后发现大于1e5的最小的素数是1e5 + 3，所以N = 1e5 + 3;
19 void get_prime() {
20 for (int i = 100000; ; ++i) {
21 bool flag = true;
22 for (int j = 2; j * j <= i; ++j)
23 if (i % j == 0) {
24 flag = false;
25 break;
26 }
27 if (flag) {
28 printf("%d\n", i);
29 return;
30 }
31 }
32 }
33
34 /**
35 * 我们另k = (x % N + N) % N = 2;
36 * 0 1 2 3 4 5 6 ha[maxn];
37 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
38 * | | | | | | | | ha[maxn]; // 里面存的是指针(idx)
39 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
40 * | <‐ 往这里插入一个值x(头插法)
41 * ‐‐‐
42 * | |
43 * ‐‐‐
44 * idx |
45 * v
46 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
47 * | ‐ | ‐ | ‐ | ‐ | ‐ | x | | e[maxn];
48 * ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
49 *
50 */
51
52 void insert(int x) {
53 int k = (x % N + N) % N; // k就是哈希值
54 e[idx] = x; // e数组存储数据
55 ne[idx] = ha[k]; // ne数组存储指针，因为ha[k]中就是指针，是上一个数的idx，
56 ha[k] = idx++; // 存储指针，当前的idx
57 }
58
59 bool find(int x) {
60 int k = (x % N + N) % N;
61 for (int i = ha[k]; i != ‐1; i = ne[i])
62 if (e[i] == x)
Nanchang university ACM template 第 86 页
63 return true;
64 return false;
65 }
66
67 int main() {
68 // get_prime();
69 int n; scanf("%d", &n);
70 memset(ha, ‐1, sizeof ha);
71 while (n‐‐) {
72 char op[2];
73 int x;
74 scanf("%s %d", op, &x);
75 if (*op == 'I')
76 insert(x);
77 else {
78 if (find(x))
79 puts("Yes");
80 else
81 puts("No");
82 }
83 }
84 return 0;
85 }
5.2 字典树
5.2.1 Trie 字符串统计.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Trie字符串统计.cpp
4 * 创建日期：2021年08月07日 星期六 20时16分23秒 5 * 题 目：AcWing 0835 Trie字符串统计 6 * 算 法：字典树 7 * 描 述：
8 * 维护一个字符串集合，支持两种操作：
9 * 1. I x 向集合中插入一个字符串x
10 * 2. Q x 询问一个字符串在集合中出现了多少次
11 *
12 * 简单，trie就是一个字典树，实际上就是一个多链表
13 * cnt用来标记这个是不是字串的结尾
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 const int maxn = 1e5 + 5; // 单个字符串的长度
19 int trie[maxn][26], cnt[maxn], idx; // 下标是0的点，既是根结点，又是空节点
20
21 void insert(char str[]) {
22 int p = 0; // 根结点, 变量名随便定义，用root也可以
23 for (int i = 0; str[i]; ++ i) {
24 int u = str[i] ‐ 'a';
25 if (!trie[p][u]) // 创建新结点
26 trie[p][u] = ++ idx;
27 p = trie[p][u];
28 }
29 cnt[p] ++ ; // 画个星星标记
30 }
31
32 // 查询这个字符串出现次数
33 int query(char str[]) {
34 int p = 0;
35 for (int i = 0; str[i]; ++i) {
36 int u = str[i] ‐ 'a';
37 if (!trie[p][u])
38 return 0;
39 p = trie[p][u];
40 }
41 return cnt[p];
Nanchang university ACM template 第 87 页
42 }
43
44 int main() {
45 int n; scanf("%d", &n);
46 while (n ‐‐ ) {
47 char op[2];
48 char str[maxn];
49 scanf("%s %s", op, str);
50 if (op[0] == 'I')
51 insert(str);
52 else if (op[0] == 'Q')
53 printf("%d\n", query(str));
54 }
55 return 0;
56 }
5.2.2 python-trie.py
1 # Python Version
2 class trie:
3 nex = [[0 for i in range(26)] for j in range(100000)]
4 cnt = 0
5 exist = [False] * 100000 # 该结点结尾的字符串是否存在
67 def insert(s, l): # 插入字符串
8 p = 0
9 for i in range(0, l):
10 c = ord(s[i]) ‐ ord('a')
11 if nex[p][c] == 0:
12 nex[p][c] = cnt # 如果没有，就添加结点
13 cnt += 1
14 p = nex[p][c]
15 exist[p] = True
16
17 def find(s, l): # 查找字符串
18 p = 0
19 for i in range(0, l):
20 c = ord(s[i]) ‐ ord('a')
21 if nex[p][c] == 0:
22 return False
23 p = nex[p][c]
24 return exist[p]
5.2.3 最大异或对.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月08日 星期日 17时43分39秒 5 * 题 目：AcWing 0143 最大异或对 6 * 算 法：Trie
7 * 描 述：从n个数中找两个数，它们异或得到的值最大 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using namespace std;
14 const int maxn = 1e5 + 5;
15 const int maxm = 3e6 + 5;
16 int son[maxm][2], idx;
17 int a[maxn];
18
19 void insert(int x) {
20 int root = 0;
21 // 取反i等于i >= 0
22 for (int i = 30; ~i; ‐‐i) {
Nanchang university ACM template 第 88 页
23 int &s = son[root][x >> i & 1];
24 if (!s)
25 s = ++idx;
26 root = s;
27 }
28 // cnt[root]++; // 不需要这句
29 }
30
31 int query(int x) {
32 int res = 0, root = 0;
33 for (int i = 30; ~i; ‐‐i) {
34 int bit = x >> i & 1;
35 if (son[root][!bit]) {
36 res += 1 << i;
37 root = son[root][!bit];
38 }
39 else
40 root = son[root][bit];
41 }
42 return res;
43 }
44
45 int main() {
46 int n; scanf("%d", &n);
47 for (int i = 0; i < n; ++i) {
48 scanf("%d", &a[i]);
49 insert(a[i]);
50 }
51 int res = 0;
52 for (int i = 0; i < n; ++i)
53 res = max(res, query(a[i]));
54 printf("%d\n", res);
55 return 0;
56 }
5.3 前缀函数与 KMP 算法
5.3.1 KMP-OI.cpp
1 #include <cstdio>
2 #include <cstring>
3 const int maxn = 1e6 + 5, maxm = 1e6 + 5;
4 #define bug printf("<‐‐>\n");
5 #define NEXTLINE puts("");
6 int n, m;
7 char text[maxn], pattern[maxm];
8 int ne[maxm];
9
10 void prefix_table(char pattern[]) {
11 int n = strlen(pattern);
12 for (int i = 1; i < n; ++ i) {
13 int j = ne[i ‐ 1];
14 while (j > 0 && pattern[i] != pattern[j])
15 j = ne[j ‐ 1];
16 if (pattern[i] == pattern[j])
17 j ++ ;
18 ne[i] = j;
19 }
20 }
5.3.2 KMP 字符串-idx-0.cpp
1 // 字符串下标从0开始 2 #include <cstdio>
3 #include <cstring>
4 const int maxn = 1e5 + 5, maxm = 1e6 + 5;
5 int n, m;
Nanchang university ACM template 第 89 页 6 char text[maxm], pattern[maxn];
7 int ne[maxn];
8 #define NEXTLINE puts("");
9
10 int main() {
11 scanf("%d %s", &n, pattern);
12 scanf("%d %s", &m, text);
13 ne[0] = ‐1;
14 for (int i = 1, j = ‐1; i < n; i ++ ) {
15 while (j >= 0 && pattern[j + 1] != pattern[i])
16 j = ne[j];
17 if (pattern[j + 1] == pattern[i])
18 j ++ ;
19 ne[i] = j;
20 }
21 for (int i = 0; i <= n; ++ i)
22 printf("%d ", ne[i]);
23 NEXTLINE;
24
25 for (int i = 0, j = ‐1; i < m; i ++ ) {
26 while (j != ‐1 && text[i] != pattern[j + 1])
27 j = ne[j];
28 if (text[i] == pattern[j + 1])
29 j ++ ;
30 if (j == n ‐ 1) {
31 printf("%d ", i ‐ j);
32 j = ne[j];
33 }
34 }
35 return 0;
36 }
5.3.3 KMP 字符串-idx-1.cpp
1 // 字符串下标从1开始 2 #include <cstdio>
3 #include <cstring>
4 const int maxn = 1e5 + 5, maxm = 1e6 + 5;
5 int ne[maxn];
6 char pattern[maxn], text[maxm];
7 #define NEXTLINE puts("");
89 void get_perfix_table(char pattern[]) {
10 int n = strlen(pattern + 1);
11 for (int i = 2, j = 0; i <= n; ++ i) {
12 while (j && pattern[i] != pattern[j + 1])
13 j = ne[j];
14 if (pattern[i] == pattern[j + 1])
15 j ++ ;
16 ne[i] = j;
17 }
18 }
19
20 void kmp_search(char text[], char pattern[]) {
21 int m = strlen(text + 1),
22 n = strlen(pattern + 1);
23 for (int i = 1, j = 0; i <= m; ++ i) {
24 while (j && text[i] != pattern[j + 1])
25 j = ne[j];
26 if (text[i] == pattern[j + 1])
27 j ++ ;
28 if (j == n) {
29 printf("%d ", i ‐ n);
30 j = ne[j];
31 }
32 }
33 }
34
35 int main() {
Nanchang university ACM template 第 90 页
36 int n, m;
37 scanf("%d %s", &n, pattern + 1);
38 scanf("%d %s", &m, text + 1);
39 get_perfix_table(pattern);
40 /*
41 * printf("%s\n", pattern + 1);
42 * for (int i = 1; i <= n; ++ i)
43 * printf("%d", ne[i]);
44 * NEXTLINE;
45 */
46 kmp_search(text, pattern);
47 return 0;
48 }
49
50 /*
51 6
52 ABAABA
53 33
54 ABAABAABAABAABAAABBCCABABCABAABAA
55 | | |
56 1 9 22
57
58 9
59 ABABCABAA
60 19
61 ABABABCABAABABAABAB
62 */
5.3.4 KMP 字符串.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：KMP字符串.cpp
4 * 创建日期：2021年08月06日 星期五 21时23分58秒 5 * 题 目：AcWing 0831 KMP字符串 6 * 算 法：KMP
7 * 描 述：ne[0] = 0，没有改变ne的下标 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 // maxn 是文本串的长度，maxm 是模式串的长度
14 const int maxn = 1e6 + 5, maxm = 1e6 + 5;
15 #define bug printf("<‐‐>\n");
16 #define NEXTLINE puts("");
17 int n, m;
18 char text[maxn], pattern[maxm];
19 int ne[maxm];
20
21 void prefix_table() {
22 ne[0] = 0;
23 for (int i = 1, j = 0; i < n;) {
24 if (pattern[i] == pattern[j])
25 ne[i ++ ] = ++ j;
26 else if (j > 0)
27 j = ne[j ‐ 1];
28 else // j <= 0，说明前i个字符没有相等的真前后缀
29 ne[i ++ ] = 0;
30 }
31 for (int i = n ‐ 1; i > 0; ‐‐ i)
32 ne[i] = ne[i ‐ 1];
33 ne[0] = ‐1;
34 }
35
36 void kmp_search() {
37 prefix_table();
38 for (int i = 0, j = 0; i < m;) {
39 if (j == n ‐ 1 && text[i] == pattern[j]) {
Nanchang university ACM template 第 91 页
40 printf("%d ", i ‐ j); // Found pattern at (i ‐ j);
41 j = ne[j];
42 }
43 if (text[i] == pattern[j])
44 i ++ , j ++ ;
45 else { // 如果不等于的话，使用前缀表得到最小移动位置
46 j = ne[j];
47 if (j == ‐1) // 如果是0表示直接从下一个字符开始匹配
48 i ++ , j ++ ;
49 }
50 }
51 }
52
53 int main() {
54 // m 是文本串的长度，n 是模式串的长度
55 scanf("%d %s", &n, pattern);
56 scanf("%d %s", &m, text);
57 /*
58 * n = 9, m = 19;
59 * strcpy(text, "ABABABCABAABABAABAB");
60 * strcpy(pattern, "ABABCABAA");
61 */
62 kmp_search();
63 return 0;
64 }
5.4 z 函数 (扩展 KMP)
5.4.1 EKMP.cpp
1 //因为个人习惯，在灯笼代码的基础上作了些修改 2 #include <cstdio>
3 #include <cstdlib>
4 #include <cstring>
56 void prefix_table(char pattern[], int prefix[]) {
7 int len = strlen(pattern);
8 prefix[0] = 0;
9 int ptr = 0;
10
11 int i = 1;
12 while (i < len) {
13
14 }
15 }
16
17 int main() {
18 char pattern[] = "ABABCABAA";
19 char text[] = "ABABABCABAABABAABAB";
20
21 return 0;
22 }
5.5 AC 自动机
5.5.1 ACautomaton.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐ACautomaton.cpp
4 * 创建日期：2021年03月19日 ‐‐‐‐ 19时49分 5 * 题 目：hdu2222 keywords search
6 * 算 法：AC自动机 7 * 描 述：第一行测试用例数，每个用例包括一个整数N，表示关键字个数 8 * 下面有N个关键词N <= 10000，每个关键词只包括小写字母，长度不超过 9 * 50，最后一行是文本，长度不大于1000000
10 * 在输出的文本中能找到多少关键词
11 *
Nanchang university ACM template 第 92 页
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <map>
16 #include <queue>
17 #include <cstring>
18 using namespace std;
19 const int maxn = 1000005;
20 const int sigma_size = 26; //字符集
21 const int maxnode = 1000005;
22 int res;
23 bool used[maxn];
24 /*
25 * 数组定义的字典树
26 * ch[i][j]保存结点i的那个编号为j的子结点
27 * ch[i][0] == 0表示结点i的子结点a不存在
28 */
29 int ch[maxnode][sigma_size+5];
30 int dict[maxnode];
31 int idx(char c) {return c ‐ 'a';}
32
33 /* _
34 * |_| root
35 * /|\
36 * / | \
37 * / | \
38 * [t] t a i [i]
39 * / \ \
40 * / \ \
41 * / \ \
42 * [to] o e [te] n [in]
43 * /|\ \
44 * / | \ \
45 * / | \ \
46 * a d n n [inn]
47 * [tea] [ted] [ten]
48 */
49
50 struct Trie {
51 int pos;
52 Trie() { pos = 1; memset(ch[0], 0, sizeof(ch[0])); memset(used, 0, sizeof(used)); }
53 void insert(char *s) {
54 int p = 0; //查字典，前缀的位置pos
55 int n = strlen(s);
56 for(int i = 0; i < n; i++) {
57 int c = idx(s[i]); //c = ch ‐ 'a'
58 if(!ch[p][c]) {
59 memset(ch[pos], 0, sizeof(ch[pos]));
60 dict[pos] = 0;
61 ch[p][c] = pos++;
62 }
63 p = ch[p][c];
64 }
65 dict[p]++;
66 }
67 };
68
69 /*Aho‐Corasick automaton*/
70 int last[maxn], f[maxn];
71 /*递归打印以结点j结尾的所有字符串*/
72 void print(int j) {
73 if (j && !used[j]) {
74 res += dict[j];
75 used[j] = 1;
76 print(last[j]);
77 }
78 }
79
80 /*
81 * 计算失配函数
Nanchang university ACM template 第 93 页
82 * BFS顺序递推
83 * 在字典树ch中添加失配边
84 */
85 void getFail() {
86 queue<int> quu;
87 f[0] = 0;
88 for (int c = 0; c < sigma_size; ++c) {
89 int p = ch[0][c];
90 if (p) {
91 f[p] = 0;
92 quu.push(p);
93 last[p] = 0;
94 }
95 }
96 while (!quu.empty()) {
97 int r = quu.front();
98 quu.pop();
99 for (int c = 0; c < sigma_size; ++c) { //遍历字母
100 int p = ch[r][c];
101 if (!p) {
102 ch[r][c] = ch[f[r]][c];
103 continue;
104 }
105 quu.push(p);
106 int v = f[r];
107 while(v && !ch[v][c])
108 v = f[v];
109 f[p] = ch[v][c];
110 last[p] = dict[f[p]] ? f[p] : last[f[p]];
111 }
112 }
113 }
114
115 /*在文本串T中找模板*/
116 void find_T(char* T) {
117 int n = strlen(T);
118 int p = 0;
119 for (int i = 0; i < n; ++i) {
120 int c = idx(T[i]);
121 p = ch[p][c];
122 if (dict[p])
123 print(p);
124 else if (last[p])
125 print(last[p]);
126 }
127 }
128
129 char pattern[55];
130 char text[1000005];
131 int main() {
132 freopen("in.txt", "r", stdin);
133 freopen("out.txt", "w", stdout);
134 int t;
135 scanf("%d", &t);
136 while(t‐‐) {
137 int n;
138 scanf("%d", &n);
139 Trie trie;
140 res = 0;
141 for(int i = 0; i < n; i++) {
142 scanf("%s", pattern);
143 trie.insert(pattern);
144 }
145 getFail();
146 scanf("%s", text);
147 find_T(text);
148 printf("%d\n", res);
149 }
150 return 0;
151 }
Nanchang university ACM template 第 94 页
5.5.2 Trie 图.cpp
1 #include <cstdio>
2 #include <cstring>
3 const int maxn = 1e4 + 5, maxm = 1e6 + 5, maxs = 55;
4 int n;
5 int tr[maxn * maxs][26], cnt[maxn * maxs], idx;
6 char str[maxm];
7 int q[maxn * maxs], ne[maxn * maxs];
8 #define NEXTLINE puts("");
9 #define bug puts("<‐‐>");
10 #define p(x) printf("‐‐ %d\n", (x));
11
12 void insert() {
13 int p = 0;
14 for (int i = 0; str[i]; ++ i) {
15 int u = str[i] ‐ 'a';
16 if (!tr[p][u])
17 tr[p][u] = ++ idx;
18 p = tr[p][u];
19 }
20 cnt[p] ++ ;
21 }
22
23 void build() {
24 int hh = 0, tt = ‐1;
25 for (int i = 0; i < 26; ++ i)
26 if (tr[0][i]) {
27 ne[tr[0][i]] = 0;
28 q[ ++ tt] = tr[0][i];
29 }
30 while (hh <= tt) {
31 int t = q[hh ++ ]; // 父结点
32 for (int i = 0; i < 26; ++ i) {
33 int c = tr[t][i]; // 当前结点
34 if (!c) { // 当前结点不存在
35 tr[t][i] = tr[ne[t]][i];
36 }
37 else {
38 ne[c] = tr[ne[t]][i];
39 q[ ++ tt] = c;
40 }
41 }
42 }
43 }
44
45 int ACautomaton() {
46 int res = 0;
47 for (int i = 0, j = 0; str[i]; ++ i) {
48 int c = str[i] ‐ 'a';
49 j = tr[j][c]; // j 是父结点
50 int u = j;
51 while (u) {
52 res += cnt[u];
53 cnt[u] = 0;
54 u = ne[u];
55 }
56 }
57 return res;
58 }
59
60 int main() {
61 int t; scanf("%d", &t);
62 while (t ‐‐ ) {
63 memset(tr, 0, sizeof tr);
64 memset(cnt, 0, sizeof cnt);
65 memset(ne, 0, sizeof ne);
Nanchang university ACM template 第 95 页
66 idx = 0;
67 scanf("%d", &n);
68 for (int i = 0; i < n; ++ i) {
69 scanf("%s", str);
70 insert();
71 }
72 build();
73 scanf("%s", str);
74 int res = ACautomaton();
75 printf("%d\n", res);
76 }
77 return 0;
78 }
5.5.3 搜索关键词.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：搜索关键词.cpp
4 * 创建日期：2021年11月03日 星期三 22时06分59秒 5 * 题 目：hdu 2222 AcWing 1282 搜索关键词 6 * 算 法：AC自动机 7 * 描 述：给定 n 个长度不超过 50 的由小写英文字母组成的单词，
8 * 以及一篇长为 m 的文章，问有多少个单词在文章中出现了。
9 * 1 1 she he say shr her text
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <cstring>
15 const int maxn = 1e4 + 5, maxm = 1e6 + 5, maxs = 55;
16 int n;
17 int tr[maxn * maxs][26], cnt[maxn * maxs], idx;
18 char str[maxm];
19 int q[maxn * maxs], ne[maxn * maxs]; // Fail[]
20 #define NEXTLINE puts("");
21 #define bug puts("<‐‐>");
22 #define p(x) printf("‐‐ %d\n", (x));
23
24 void insert() {
25 int p = 0;
26 for (int i = 0; str[i]; ++ i) {
27 int u = str[i] ‐ 'a';
28 if (!tr[p][u])
29 tr[p][u] = ++ idx;
30 p = tr[p][u];
31 }
32 cnt[p] ++ ;
33 }
34
35 /*
36 * +
37 * s / \ h
38 * / \
39 * ne = 0 1 4 ne = 0
40 * h / \ e
41 * / \
42 * ne = 4 2 5 ne = 0
43 * e /
44 * /
45 * ne = 5 3
46 *
47 * 当 t = 2 时，也就是停在sh位置，会遍历它的所有后继结点
48 * 这时找到 c = tr[t]['e' ‐ 'a'] = tr[2][4] = 3
49 *
50 * j = ne[t] = ne[2] = 4，j 是当前结点 3 的 next，就是因为 'e'
51 * 的上面的子串的最长后继已经找到了，没必要从头开始找
52 *
53 * 接下来就是判断是否有 tr[j][i]，这里的 i 就是 'e' ‐ 'a'，也就代表了 'e'
Nanchang university ACM template 第 96 页
54 *
55 * 发现有 tr[j][i] = tr[4][4] = 5，那么 j = tr[j][i], ne[c] = ne[3] = j = 5
56 * 没发现的话，j 最后会变成 0，ne[c] = 0，指向根结点
57 */
58
59 void build() {
60 int hh = 0, tt = ‐1; // 宽度优先搜索
61 for (int i = 0; i < 26; ++ i)
62 if (tr[0][i]) {
63 ne[tr[0][i]] = 0; // 因为初始ne就是0，这句没必要
64 q[ ++ tt] = tr[0][i];
65 }
66 while (hh <= tt) {
67 int t = q[hh ++ ];
68 for (int i = 0; i < 26; ++ i) {
69 int c = tr[t][i];
70 if (!c)
71 continue;
72 int j = ne[t]; // 当前结点的上一个结点，的next
73 // 当前结点代表的字母是i
74 while (j && !tr[j][i]) // 也就是next下面是否有同样的i
75 j = ne[j];
76 if (tr[j][i])
77 j = tr[j][i];
78 ne[c] = j;
79 q[ ++ tt] = c;
80 }
81 }
82 }
83
84 int ACautomaton() {
85 int res = 0;
86 for (int i = 0, j = 0; str[i]; ++ i) {
87 int c = str[i] ‐ 'a'; // 当前字符
88 while (j && !tr[j][c])
89 j = ne[j];
90 if (tr[j][c])
91 j = tr[j][c];
92 int u = j;
93 while (u) {
94 res += cnt[u];
95 cnt[u] = 0;
96 u = ne[u];
97 }
98 }
99 return res;
100 }
101
102 int main() {
103 int t; scanf("%d", &t);
104 while (t ‐‐ ) {
105 memset(tr, 0, sizeof tr);
106 memset(cnt, 0, sizeof cnt);
107 memset(ne, 0, sizeof ne);
108 idx = 0;
109 scanf("%d", &n);
110 for (int i = 0; i < n; ++ i) {
111 scanf("%s", str);
112 insert(); // 建立 trie
113 }
114 build(); // 建立 next
115 scanf("%s", str);
116 int res = ACautomaton();
117 printf("%d\n", res);
118 }
119 return 0;
120 }
Nanchang university ACM template 第 97 页
5.6 后缀数组 SA
5.6.1 后缀数组的使用.cpp
1 #include <cstdio>
2 #include <string>
3 #include <iostream>
4 using namespace std;
56 /*在text中查找子串pattern，sa是text的后缀数组*/
7 //原字符串中从第sa[0]位置开始的后缀子串在字典序中排列第0 8 int find(string text, string pattern, int* sa) {
9 int i = 0;
10 int j = text.length();
11 /*而分发查找*/
12 while (j ‐ i >= 1) {
13 int k = (i + j) / 2;
14 if (text.compare(sa[k], pattern.length(), pattern) < 0)
15 i = k;
16 else
17 j = k;
18 }
19 /*找到了，返回pattern在text中的位置*/
20 if (text.compare(sa[j], pattern.length(), pattern) == 0)
21 return sa[j];
22 return ‐1;
23 }
24
25 int main() {
26 string text = "vamamadn";
27 string pattern = "ad";
28 int sa[] = {5, 3, 1, 6, 4, 2, 7, 0}; //sa是text的后缀数组，假设已经得到
29 int location = find(text, pattern, sa);
30 cout << location << ":" << &text[location] << endl << endl;
31 return 0;
32 }
5.6.2 sort 函数求 sa 数组.cpp
1 #include <cstdio>
2 #include <algorithm>
3 #include <cstring>
4 using namespace std;
5 const int maxn = 200005;
6 char text[maxn];
7 int sa[maxn];
8 int rk[maxn];
9 int tmp[maxn + 1];
10 int n, k;
11
12 bool comp_sa(int i, int j) {
13 if (rk[i] != rk[j])
14 return rk[i] < rk[j];
15 else {
16 int ri = i + k <= n ? rk[i + k] : ‐1;
17 int rj = j + k <= n ? rk[j + k] : ‐1;
18 return ri < rj;
19 }
20 }
21
22 void calc_sa() {
23 for (int i = 0; i <= n; ++i) {
24 rk[i] = text[i];
25 sa[i] = i;
26 }
27 for (k = 1; k <= n; k *= 2) {
28 sort(sa, sa+n, comp_sa);
29 tmp[sa[0]]= 0;
30 for (int i = 0; i < n; ++i)
Nanchang university ACM template 第 98 页
31 tmp[sa[i+1]] = tmp[sa[i]] + (comp_sa(sa[i], sa[i+1]) ? 1 : 0);
32 for (int i = 0; i < n; ++i)
33 rk[i] = tmp[i];
34 }
35 }
36
37 int main() {
38 while (scanf("%s", text) != EOF) {
39 n = strlen(text);
40 calc_sa();
41 for (int i = 0; i < n; ++i)
42 printf("%d ", sa[i]);
43 printf("\n");
44 }
45 return 0;
46 }
5.6.3 基数排序求 sa 数组.cpp
1 #include <cstdio>
2 #include <algorithm>
3 #include <cstring>
4 using namespace std;
5 const int maxn = 200005;
6 char text[maxn];
7 int sa[maxn];
8 int rk[maxn];
9 int cnt[maxn];
10 int t1[maxn];
11 int t2[maxn];
12 int height[maxn];
13 int n;
14
15 void calc_sa() {
16 int m = 127;
17 int *x = t1;
18 int *y = t2;
19 for (int i = 0; i < m; ++i) cnt[i] = 0;
20 for (int i = 0; i < n; ++i) cnt[x[i] = text[i]]++;
21 for (int i = 1; i < m; ++i) cnt[i] += cnt[i‐1];
22 for (int i = n‐1; i >= 0; ‐‐i) sa[‐‐cnt[x[i]]] = i;
23 for (int k = 1; k <= n; k *= 2) {
24 int p = 0;
25 for (int i = n‐k; i < n; ++i) y[p++] = i;
26 for (int i = 0; i < n; ++i)
27 if (sa[i] >= k)
28 y[p++] = sa[i] ‐ k;
29 for (int i = 0; i < m; ++i) cnt[i] = 0;
30 for (int i = 0; i < n; ++i) cnt[x[y[i]]]++;
31 for (int i = 1; i < m; ++i) cnt[i] += cnt[i‐1];
32 for (int i = n‐1; i >= 0; ‐‐i) sa[‐‐cnt[x[y[i]]]] = y[i];
33 swap(x, y);
34 p = 1;
35 x[sa[0]] = 0;
36 for (int i = 1; i < n; ++i)
37 x[sa[i]] =
38 y[sa[i‐1]] == y[sa[i]] && y[sa[i‐1] + k] == y[sa[i] + k] ? p‐1 : p++;
39 if (p >= n) break;
40 m = p;
41 }
42 }
43
44 int main() {
45 while (scanf("%s", text) != EOF) {
46 n = strlen(text);
47 calc_sa();
48 for (int i = 0; i < n; ++i)
49 printf("%d ", sa[i]);
50 printf("\n");
Nanchang university ACM template 第 99 页
51 }
52 return 0;
53 }
5.6.4 最长公共子串.cpp
1 #include <cstdio>
2 #include <cstring>
3 #include <algorithm>
4 using namespace std;
5 const int maxn = 200005;
6 char text[maxn];
7 int sa[maxn];
8 int rk[maxn];
9 int cnt[maxn];
10 int t1[maxn];
11 int t2[maxn];
12 int height[maxn];
13 int n;
14
15 void calc_sa() {
16 int m = 127;
17 int *x = t1;
18 int *y = t2;
19 for (int i = 0; i < m; ++i) cnt[i] = 0;
20 for (int i = 0; i < n; ++i) cnt[x[i] = text[i]]++;
21 for (int i = 1; i < m; ++i) cnt[i] += cnt[i‐1];
22 for (int i = n‐1; i >= 0; ‐‐i) sa[‐‐cnt[x[i]]] = i;
23 for (int k = 1; k <= n; k *= 2) {
24 int p = 0;
25 for (int i = n‐k; i < n; ++i) y[p++] = i;
26 for (int i = 0; i < n; ++i)
27 if (sa[i] >= k)
28 y[p++] = sa[i] ‐ k;
29 for (int i = 0; i < m; ++i) cnt[i] = 0;
30 for (int i = 0; i < n; ++i) cnt[x[y[i]]]++;
31 for (int i = 1; i < m; ++i) cnt[i] += cnt[i‐1];
32 for (int i = n‐1; i >= 0; ‐‐i) sa[‐‐cnt[x[y[i]]]] = y[i];
33 swap(x, y);
34 p = 1;
35 x[sa[0]] = 0;
36 for (int i = 1; i < n; ++i)
37 x[sa[i]] =
38 y[sa[i‐1]] == y[sa[i]] && y[sa[i‐1] + k] == y[sa[i] + k] ? p‐1 : p++;
39 if (p >= n) break;
40 m = p;
41 }
42 }
43
44 /*求辅助数组height[]*/
45 /*定义height[]为sa[i‐1]和sa[i]也就是排名相邻的两个后缀的最长公共前缀长度*/
46 void getheight(int n) {
47 int k = 0;
48 for (int i = 0; i < n; ++i)
49 rk[sa[i]] = i;
50 for (int i = 0; i < n; ++i) {
51 if (k)
52 k‐‐;
53 int j = sa[rk[i]‐1];
54 while (text[i+k] == text[j+k])
55 k++;
56 height[rk[i]] = k;
57 }
58 }
59
60 int main() {
61 int len1;
62 int res;
63 while (scanf("%s", text) != EOF) {
Nanchang university ACM template 第 100 页
64 n = strlen(text);
65 len1 = n;
66 text[n] = '$'; //用$分割两个字符串
67 scanf("%s", text + n + 1); //将第2个字符串和第1个字符串合并
68 n = strlen(text);
69 calc_sa();
70 getheight(n);
71 res = 0;
72 for (int i = 0; i < n; ++i)
73 //找最大的height[i]，并且它对应的sa[i‐1]和sa[i]分别属于前后两个字符串
74 if (height[i] > res &&
75 ((sa[i‐1] < len1 && sa[i] >= len1) || (sa[i‐1] >= len1 && sa[i] < len1)))
76 res = height[i];
77 printf("%d\n", res);
78 }
79 }
5.7 Manacher
5.7.1 Manacher.cpp
1 #include <cstdio>
2 #include <string>
3 #include <iostream>
4 #include <vector>
5 #include <algorithm>
6 using namespace std;
7 #define bug printf("<‐‐‐‐‐‐>\n");
89 vector<int> radius, let; /*回文子串半径*/
10 string expa_str; /*扩展后的串*/
11 /*原串、最长回文子串开始位置、最长回文子串长度*/
12 void Manacher(const string &str, int &pos, int &max_len) {
13 int orig_len = str.length(); /*原串长度*/
14 int expa_len = (orig_len + 1) << 1; /*扩展串长度*/
15 max_len = 0;
16 radius.resize(expa_len + 1);
17 expa_str.resize(expa_len + 1);
18 //@#0#1#2#3#4#5#6#7#8#9#$
19 expa_str[0] = '@';
20 expa_str[1] = '#';
21 /*expa_len是扩展串的长度减一，不过串从零开始*/
22 expa_str[expa_len] = '$';
23 for (int i = 1; i <= orig_len; ++i) {
24 /*偶位置对应原串字符*/
25 expa_str[i << 1] = str[i‐1];
26 /*不更改奇位置，只更改偶位置*/
27 expa_str[i << 1 | 1] = '#';
28 }
29 radius[1] = 1; /*显然回文子串半径大于等于1*/
30 //本应该计算到enpa_len + 1的，但那个位置是'#'，不需要计算了
31 for (int max_R = 0, center = 0, i = 2; i < expa_len; ++i) {
32 /*根据i探查到的位置是否超过了最右回文子串的右边界，初始化i的回文半径，核心操作*/
33 radius[i] = i < max_R ? min(max_R‐i, radius[2*center‐i]) : 1;
34 /*暴力拓展中心在i位置的最长回文子串半径radius[i]*/
35 while (expa_str[i‐radius[i]] == expa_str[i+radius[i]])
36 ++radius[i];
37 /*更新最右回文子串的右边界*/
38 if (radius[i] + i > max_R) {
39 max_R = radius[i] + i;
40 center = i;
41 }
42 /*更新最长回文子串的位置与长度*/
43 if (radius[i] ‐ 1 > max_len) {
44 /*原串的最长回文子串*/
45 max_len = radius[i] ‐ 1;
46 /*原串的最长回文子串的起点*/
47 pos = (center ‐ radius[i] + 1) >> 1;
48 }
Nanchang university ACM template 第 101 页
49 }
50 }
51
52 //odd为false，字符串为奇回文串
53 //以x为中心的最长回文子串的长度
54 //如果为偶回文串，则以x, x+1中心为中心的最长回文子串的长度
55 int start_mid(int x, bool odd) {
56 return odd ? radius[(x+1) << 1] ‐ 1 : radius[(x+1) << 1 | 1] ‐ 1;
57 }
58
59 //知道回文左边界，且在Manacher函数运行结束后使用
60 int start_left(int x, string str) {
61 //let[i]表示以x为起点，的最长回文子串的中心位置
62 int expand_len = (str.length() + 1) << 1;
63 //let数组在扩展之后的字符串上，以位置i为起点的最长回文子串的中心在哪里
64 let.resize(expand_len + 1);
65 //计算维护以每个位置为起点的最长回文串
66 for (int i = 0; i <= expand_len; i++)
67 let[i] = 0;
68 for (int i = 2; i < expand_len; i++)
69 if (let[i ‐ radius[i] + 1] < i + 1)
70 let[i ‐ radius[i] + 1] = i + 1;
71 for (int i = 1; i <= expand_len; i++)
72 if (let[i] < let[i ‐ 1])
73 let[i] = let[i ‐ 1];
74 //返回以x为起点的最长回文子串的长度
75 return let[(x + 1) << 1] ‐ ((x + 1) << 1);
76 }
77
78 int main() {
79 //string str = "0123456789";
80 string str = "DDDDBBDBA|BCBAAABBAAABCB|DB";
81 string subStr;
82 int pos;
83 int max_len;
84 Manacher(str, pos, max_len);
85 printf("pos = %d\n", pos);
86 printf("max_len = %d\n", max_len);
87 cout << "subStr = " << str.substr(pos, max_len) << endl;
88 printf("length = %d\n", start_left(pos, str));
89 printf("length = %d\n", start_mid(pos+max_len/2‐1, false));
90 return 0;
91 }6 数学问题
6.1 数学公式
6.1.1 数学公式.md
1 # 数学公式
23 ## 组合数
4 ‐ $C_n^m = \frac{n \times (n‐1) \times (n‐2) \times \cdots \times (n‐m+1)}{m!}$
56 ## 约数个数
7 ‐ $cnt = ({\alpha}_1 + 1) + ({\alpha}_2 + 1) + ({\alpha}_3 + 1) + \dots + ({\alpha}_n + 1)$
89 ## 约数之和
10
11 ‐ $(p_1^0 + p_1^1 + p_1^2 + \dots + {p_1}^{{\alpha}_1}) \times (p_2^0 + p_2^1 + p_2^2 + \dots + {p_2}^{{\
alpha}_2}) \times \dots \times (p_n^0 + p_n^1 + p_n^2 + \dots + {p_n}^{{\alpha}_n})$
12
13 ## 等比数列之和
14
15 ‐ $S_n = \frac{a_1 (1 ‐ q^n)}{1 ‐ q} (q \neq 1)$
Nanchang university ACM template 第 102 页
6.2 位运算
6.2.1 lowbit.cpp
1 #include <cstdio>
2 #define lowbit(x) ((x) & ‐(x))
34 int main() {
5 printf("%d\n", lowbit(12)); // 1100
6 return 0;
7 }
6.2.2 二进制状态压缩.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐二进制状态压缩.cpp
4 * 创建日期：2021年05月08日 ‐‐‐‐ 22时44分 5 * 题 目：CH 0103
6 * 算 法：旅行商问题，哈密顿路径 7 * 描 述：0~n‐1这n个点，从点0开始行走到点n‐1结束，每个点都要经过 8 * 且每个点到另外一个点有权重，问最小的花费是多少 9 * 发现：
10 * 假设已经经过了0, 1, 2, 3这四个点，由于要从0开始，那么会有3! = 6种方式
11 * 0 ‐> 1 ‐> 2 ‐> 3 18
12 * 0 ‐> 2 ‐> 1 ‐> 3 20
13 * ...
14 * 在上面的两种方案里，对于后面的点的选择，一定不会选择第二种路径
15 * 因为我们只需要在经过相同的点且最后的位置相同的行走方式中找到
16 * 权重和最小的那种方式就行了，不管在这些点中是如何行走的，不会影响到
17 * 后面点的选择
18 * 1. 哪些点被用过
19 * 2. 现在停在哪些点上
20 *
21 * dp[state][j] = dp[state_k][k] + weight[k][j];
22 * state_k是state去掉j的集合，state_k要包含点k
23 * 状态压缩，用一个数二进制中哪些是1来表示这个点被经过
24 * 0, 1, 4 ‐> 10011
25 *
26 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
27
28 #include <cstdio>
29 #include <cstring>
30 const int maxn = 20;
31 #define _min(a, b) (a < b ? a : b)
32 /*
33 * dp[i][j]中i的二进制为1的点已经被经过，当前处于点j
34 * 如dp[7][1]中7的二进制为0111，则有点0、点1、点2都已经被经过，当前位于点1
35 * 状态转移方程：dp[i][j] = min(dp[i][j], dp[i ^ (1<<j)][k] + weight[k][j]);
36 * 既然状态为i的点都被经过，而当前位于点j，显然上一个状态是dp[i ^ (1<<j)][k] (k是状态i中非j的点)
37 */
38 int dp[1 << maxn][maxn];
39 int weight[maxn][maxn];
40
41 int hamilton(int n) {
42 memset(dp, 0x3f, sizeof(dp));
43 dp[1][0] = 0; //起始点为0，所以点0到点0的距离是0
44 for (int i = 1; i < (1 << n); ++i)
45 for (int j = 0; j < n; ++j) //枚举当前所在的点
46 if ((i >> j) & 1) //判断路径i中是否包括当前点j,如果包括当前点，则可以进行状态转移
47 for (int k = 0; k < n; ++k) //要完成点k到点j的转移，所以要来枚举k
48 if (i ‐ (1<<j) >> k & 1) //只有去除掉点j后路线中仍然包含点k才能说明路线是在点k的基础上向点j转移 的
49 dp[i][j] = _min(dp[i][j], dp[i‐(1<<j)][k] + weight[k][j]);
50 return dp[(1 << n)‐1][n‐1]; //由于题目要求计算从点n到点n‐1的路径长度，所以(1<<n)‐1的二进制形式为111...111[共有 (n‐1)个1]
51 }
52
53 int main() {
Nanchang university ACM template 第 103 页
54 int n;
55 scanf("%d", &n);
56 for (int i = 0; i < n; ++i)
57 for (int j = 0; j < n; ++j)
58 scanf("%d", &weight[i][j]);
59 int res = hamilton(n);
60 printf("%d\n", res);
61 return 0;
62 }
6.2.3 整数除以 2.cpp
1 #include <cstdio>
2 int main() {
3 int i = ‐3;
4 printf("%d\n", i / 2); //得到‐1，说明C++编译器实现为除以2向0取整 5 return 0;
6 }
6.3 快速幂
6.3.1 快速幂.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：快速幂.cpp
4 * 创建日期：2021年10月08日 星期五 22时59分30秒 5 * 题 目：AcWing 0875 快速幂 6 * 算 法：快速幂 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 typedef long long ll;
13 int MOD;
14
15 int binpow(int base, int expo) {
16 ll res = 1;
17 while (expo) {
18 if (expo & 1)
19 res = (1LL * res * base) % MOD;
20 base = (1LL * base * base) % MOD;
21 // 也就是base分别是2, 4, 8, 16, ...
22 expo >>= 1;
23 }
24 return res;
25 }
26
27 int main() {
28 int n; scanf("%d", &n);
29 while (n ‐‐ ) {
30 int a, b, p;
31 scanf("%d %d %d", &a, &b, &p);
32 MOD = p;
33 printf("%lld\n", binpow(a, b));
34 }
35 return 0;
36 }
6.3.2 快速幂测试.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：快速幂.cpp
4 * 创建日期：2021年03月10日 ‐‐‐‐ 21时43分
Nanchang university ACM template 第 104 页 5 * 算 法：快速幂 6 * 描 述：使用了模板template
7 * 8 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
9
10 #include <cstdio>
11 const int mod = 99991;
12
13 // 计算 a^b % m
14 // 1.17秒
15 long long binaryPow(long long a, long long b, long long m) {
16 if (b == 0) return 1;
17
18 if (b % 2 == 1)
19 return a * binaryPow(a, b ‐ 1, m) % m;
20 else {
21 long long mul = binaryPow(a, b / 2, m);
22 return mul * mul % m;
23 }
24 }
25
26 //0.45秒
27 long long binPow(long long base, long long expo) {
28 long long res = 1;
29 while (expo != 0) {
30 if (expo & 1)
31 res = (1LL * res * base) % mod;
32 base = (1LL * base * base) % mod;
33 expo >>= 1;
34 }
35 return res;
36 }
37
38 /*
39 *template<typename T>
40 *T binPow(T base, T expo) {
41 * if (!expo) return 1;
42 * if (expo % 2)
43 * return base * binPow(base, expo ‐ 1) % mod;
44 * else
45 * return binPow(base, expo / 2) % mod * binPow(base, expo / 2) % mod;
46 *}
47 */
48
49 template<typename T>
50 T binPow(T base, T expo) {
51 T res = 1;
52 while (expo != 0) {
53 if (expo & 1)
54 res = (1LL * res * base) % mod;
55 base = (1LL * base * base) % mod;
56 expo >>= 1;
57 }
58 return res;
59 }
60
61 int main() {
62 long long base = 23, expo = 19898283988388888;
63 long long res;
64 for (int i = 0; i < 1000000; ++i)
65 //res = binaryPow(base, expo, mod);
66 res = binPow(base, expo);
67 printf("%lld\n", res);
68 return 0;
69 }
6.3.3 矩阵快速幂.cpp
1 #include <cstdio>
Nanchang university ACM template 第 105 页 2 #include <cstring>
3 const int maxn = 2; // 定义矩阵的阶 4 const int MOD = 99991;
56 struct Matrix {
7 int m[maxn][maxn];
8 Matrix() {
9 memset(m, 0, sizeof(m));
10 }
11 };
12
13 /*矩阵乘法*/
14 Matrix Multi(Matrix a, Matrix b) {
15 Matrix res;
16 for (int i = 0; i < maxn; ++i)
17 for (int j = 0; j < maxn; ++j)
18 for (int k = 0; k < maxn; ++k)
19 res.m[i][j] = (res.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD;
20 return res;
21 }
22
23 /*矩阵快速幂*/
24 Matrix fastm(Matrix a, int n) {
25 Matrix res;
26 for (int i = 0; i < maxn; ++i)
27 res.m[i][i] = 1;
28 while (n) {
29 if (n & 1)
30 res = Multi(res, a);
31 a = Multi(a, a);
32 n >>= 1;
33 }
34 return res;
35 }
6.4 进制转换
6.4.1 进制转换.cpp
1 /*除了十进制的数用一个int型变量直接存储之外，其他进制的数都用vector容器存储*/
2 #include <cstdio>
3 #include <vector>
4 #include <cmath>
5 using namespace std;
6 // B：bit 二进制 7 // T：ternary 三进制 8 // Q：quaternary 四进制 9 // O：octonary 八进制
10 // D：decimal 十进制
11 // H：hexadecimal 十六进制
12
13 // 将一个P进制的数转换为D进制的数
14 int anytoD(vector<int> num_P, int base_P) {
15 int num_D = 0;
16 for (int i = 0; i < (int)num_P.size(); ++i)
17 num_D += (num_P[i] * pow(base_P, i));
18 return num_D;
19 }
20
21 // 将一个D进制的数转换为C进制的数
22 vector<int> numto;
23 void Dtoany(int num_D, int base_C) {
24 do {
25 numto.push_back(num_D % base_C);
26 num_D /= base_C;
27 }while (num_D != 0);
28 }
29
30 int main() {
Nanchang university ACM template 第 106 页
31 int num = 101110011;
32 int base_P = 2;
33 vector<int> num_P;
34 while (num) {
35 num_P.push_back(num % 10);
36 num /= 10;
37 }
38 int base_C = 8;
39 int num_D = anytoD(num_P, base_P);
40 Dtoany(num_D, base_C);
41 for (auto it = numto.end()‐1; it != numto.begin()‐1; ‐‐it)
42 printf("%d", *it);
43 return 0;
44 }
6.4.2 进制转换.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：进制转换.cpp
4 * 创建日期：2020年08月10日 5 * 描 述：板子 6 * 7 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
89 //将其他进制的数转换为十进制
10 #include <cstdio>
11
12 /**
13 * 一个函数，将一个字符串转化为十进制数
14 * 这里不知道数字字符个数,有大小写字母
15 * 12345
16 * 1 * 10 + 2
17 * 12 * 10 + 3
18 * 123 * 10 + 4
19 * 1234 * 10 + 5
20 * .....
21 */
22 int Conversion(char str[], int len) {
23 int unit = 0;
24 for (int i = 0; i < len; i++) {
25 if (str[i] >= 'A' && str[i] <= 'Z')
26 unit = 62 * unit + (str[i] ‐ 'A');
27 else if (str[i] >= 'a' && str[i] <= 'z')
28 unit = 62 * unit + (str[i] ‐ 'a') + 26;
29 else
30 unit = 62 * unit + (str[i] ‐ '0') + 52;
31 }
32 return unit;
33 }
34
35 int main() {
36 char str[] = "BCD";
37 int unit = Conversion(str, 3);
38 printf("%d\n", unit);
39 return 0;
40 }
6.5 高精度计算
6.5.1 factN.java
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：_01fact_N.java
4 * 创建日期：2021年03月10日 ‐‐‐‐ 20时35分 5 * 题 目：hdu1042
Nanchang university ACM template 第 107 页 6 * 算 法：高精度计算 7 * 描 述：输入：N(0 <= N <= 10000) 输出：N! 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 import java.math.BigInteger;
12 import java.util.*;
13
14 public class _01fact_N {
15 public static void main(String[] args) {
16 Scanner input = new Scanner(System.in);
17 while (input.hasNextInt()) { //判断是否仍有int型输入
18 int n = input.nextInt(); //输入int型变量n
19 BigInteger res = BigInteger.ONE;
20 for (int i = 1; i <= n; ++i)
21 res = res.multiply(BigInteger.valueOf(i)); //BigInteger.valueOf(i)强制类型转换
22 System.out.println(res);
23 }
24 }
25 }
6.5.2 二进制方法实现 64 位整数乘法.cpp
1 #include <cstdio>
2 typedef long long ll;
3 ll mod;
45 ll binTimes(ll l1, ll l2) {
6 ll res = 0;
7 while (l2) {
8 if (l2 & 1)
9 res = (res + l1) % mod;
10 l1 = (l1 * 2) % mod;
11 l2 >>= 1;
12 }
13 return res;
14 }
15
16 int main() {
17 ll a, b;
18 scanf("%lld %lld %lld", &a, &b, &mod);
19 ll res = binTimes(a, b);
20 printf("%lld\n", res);
21 return 0;
22 }
6.5.3 暴躁 py.py
1 n = eval(input())
2 res = 1
34 # 以换行结束输入
5 for i in range(n):
6 x = eval(input())
7 res = res * x
89 print(res)
6.5.4 高精度乘法.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：06‐高精度乘法.cpp
4 * 创建日期：2021年08月06日 星期五 16时25分58秒 5 * 题 目：AcWing 0793 高精度乘法 6 * 算 法：高精度乘法
Nanchang university ACM template 第 108 页 7 * 描 述：给定两个非负整数(不含前导 0) A 和 B，计算 A * B 8 * 使用了string输入乘数，其实也可以使用数组存储，代码改一下就可以了 9 *
10 * 模板化就模板化吧，挺简洁的
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <iostream>
16 #include <string>
17 #include <vector>
18 using namespace std;
19 #define NEXTLINE cout << endl;
20
21 // C = A * b, A >= 0, b >= 0
22 vector<int> mul(vector<int> &A, int b) {
23 vector<int> C;
24 // 太模板化了，可以拆开写，结束条件是 i < A.size()
25 // 这时 t 可能不为0，那就写一个while (t) {c.pb(t % 10); t /= 10}
26 for (int i = 0, t = 0; i < A.size() || t; ++i) {
27 if (i < A.size()) // 这句要要相应的改
28 t += A[i] * b;
29 C.push_back(t % 10);
30 t /= 10;
31 }
32 // 去除前导零
33 while (C.size() > 1 && C.back() == 0)
34 C.pop_back();
35 return C;
36 }
37
38 int main() {
39 ios::sync_with_stdio(false);
40 cin.tie(NULL), cout.tie(NULL);
41
42 string n1;
43 int b;
44 cin >> n1 >> b;
45 vector<int> A;
46
47 // vector 推入的第一个位置是个位
48 for (int i = n1.length() ‐ 1; i >= 0; ‐‐i)
49 A.push_back(n1[i] ‐ '0');
50
51 auto C = mul(A, b);
52 for (int i = C.size() ‐ 1; i >= 0; ‐‐i)
53 cout << C[i];
54 NEXTLINE;
55 return 0;
56 }
6.5.5 高精度减法.cpp
1 #include <cstdio>
2 #include <vector>
3 #include <string>
4 #include <iostream>
5 #include <algorithm>
6 using namespace std;
7 #define NEXTLINE cout << endl;
89 // C = A ‐ B, 满足A >= B, A >= 0, B >= 0
10 vector<int> sub(vector<int> &A, vector<int> &B) {
11 vector<int> C;
12 for (int i = 0, t = 0; i < A.size(); ++i) {
13 t = A[i] ‐ t;
14 if (i < B.size())
15 t ‐= B[i];
16 C.push_back((t + 10) % 10);
Nanchang university ACM template 第 109 页
17 t < 0 ? t = 1 : t = 0;
18 }
19
20 while (C.size() > 1 && C.back() == 0)
21 C.pop_back();
22 return C;
23 }
24
25 int main() {
26 ios::sync_with_stdio(false);
27 cin.tie(NULL), cout.tie(NULL);
28
29 string n1, n2;
30 cin >> n1 >> n2;
31 vector<int> A, B;
32
33 for (int i = n1.length() ‐ 1; i >= 0; ‐‐i)
34 A.push_back(n1[i] ‐ '0');
35 for (int i = n2.length() ‐ 1; i >= 0; ‐‐i)
36 B.push_back(n2[i] ‐ '0');
37
38 //判断A < B, 则swap
39 if (n1.length() < n2.length() || (n1.length() == n2.length() && n1 < n2))
40 swap(A, B);
41
42 auto C = sub(A, B);
43
44 if (n1.length() < n2.length() || (n1.length() == n2.length() && n1 < n2))
45 cout << "‐";
46 for (int i = C.size() ‐ 1; i >= 0; ‐‐i)
47 cout << C[i];
48 NEXTLINE;
49 return 0;
50 }
6.5.6 高精度加法.cpp
1 #include <cstdio>
2 #include <vector>
3 #include <string>
4 #include <iostream>
5 #define NEXTLINE cout << endl;
6 using namespace std;
78 // C = A + B, A >= 0, B >= 0 9 vector<int> add(vector<int> &A, vector<int> &B) {
10 if (A.size() < B.size())
11 return add(B, A);
12
13 vector<int> C;
14 int t = 0;
15 for (int i = 0; i < A.size(); ++i) {
16 t += A[i];
17 if (i < B.size())
18 t += B[i];
19 C.push_back(t % 10);
20 t /= 10;
21 }
22
23 if (t)
24 C.push_back(t);
25 return C;
26 }
27
28 int main() {
29 ios::sync_with_stdio(false);
30 cin.tie(NULL), cout.tie(NULL);
31
32 string n1, n2;
Nanchang university ACM template 第 110 页
33 vector<int> A, B;
34 cin >> n1 >> n2; //n1 = 123456
35
36 // A = [6, 5, 4, 3, 2, 1];
37 for (int i = n1.length() ‐ 1; i >= 0; ‐‐i)
38 A.push_back(n1[i] ‐ '0');
39 for (int i = n2.length() ‐ 1; i >= 0; ‐‐i)
40 B.push_back(n2[i] ‐ '0');
41
42 auto C = add(A, B);
43 for (int i = C.size() ‐ 1; i >= 0; ‐‐i)
44 cout << C[i];
45 NEXTLINE;
46 return 0;
47 }
6.5.7 高精度除法.cpp
1 #include <cstdio>
2 #include <string>
3 #include <iostream>
4 #include <vector>
5 #include <algorithm>
6 using namespace std;
7 #define NEXTLINE cout << endl;
89 // A / b = C ... r, A >= 0, b > 0
10 vector<int> div(vector<int> &A, int b, int &r) {
11 vector<int> C;
12 r = 0;
13 for (int i = A.size() ‐ 1; i >= 0; ‐‐i) {
14 r = r * 10 + A[i];
15 C.push_back(r / b);
16 r %= b;
17 }
18
19 reverse(C.begin(), C.end());
20 while (C.size() > 1 && C.back() == 0)
21 C.pop_back();
22 return C;
23 }
24
25 int main() {
26 ios::sync_with_stdio(false);
27 cin.tie(NULL), cout.tie(NULL);
28
29 string n1;
30 int b;
31 cin >> n1 >> b;
32 vector<int> A;
33
34 for (int i = n1.length() ‐ 1; i >= 0; ‐‐i)
35 A.push_back(n1[i] ‐ '0');
36
37 int r;
38 auto C = div(A, b, r);
39 for (int i = C.size() ‐ 1; i >= 0; ‐‐i)
40 cout << C[i];
41 cout << endl << r << endl;
42 // NEXTLINE;
43 return 0;
44 }
6.6 数论
6.6.1 素数
6.6.1.1 埃氏筛法.cpp
Nanchang university ACM template 第 111 页 1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：埃氏筛法.cpp
4 * 创建日期：2021年08月04日 星期三 00时17分10秒 5 * 题 目：AcWing 0868 筛质数 6 * 算 法：<++>
7 * 描 述：
8 * 一个质数定理：[1, n]中有(n/lnn)个质数 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 const int maxn = 1e6;
14 //存储1 ~ 1e6内的所有素数
15 int primes[maxn], cnt;
16 //对1 ~ 1e6内的数标记，未被筛掉的素数标记为false
17 bool sifter[maxn];
18
19 void get_primes(int n) {
20 for (int i = 2; i <= n; ++i)
21 if (sifter[i] == false) {
22 primes[cnt++] = i;
23 for (int j = i + i; j <= n; j += i)
24 sifter[j] = true;
25 }
26 }
27
28 int main() {
29 int n; scanf("%d", &n);
30 get_primes(n);
31 printf("%d\n", cnt);
32 return 0;
33 }
6.6.1.2 欧拉筛法.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：欧拉筛法.cpp
4 * 创建日期：2021年08月04日 星期三 00时44分47秒 5 * 题 目：AcWing 0868 筛质数 6 * 算 法：欧拉筛法 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 1e6;
13 //存储1 ~ n内的所有素数
14 int primes[maxn], cnt;
15 //最终为false的数是素数
16 bool sifter[maxn];
17
18 void get_primes(int n) {
19 //从2开始，判断i是否为素数
20 for (int i = 2; i <= n; ++i) {
21 if (sifter[i] == false)
22 primes[cnt++] = i;
23
24 for (int j = 0; primes[j] <= n / i; ++ j) {
25 // 每一个倍数标记为不是素数
26 sifter[primes[j] * i] = true;
27
28 // primes[j]为i的最小素因子，分析下一个i
29 if (i % primes[j] == 0)
30 break;
31 }
32 }
33 }
Nanchang university ACM template 第 112 页
34
35 int main() {
36 int n; scanf("%d", &n);
37 get_primes(n);
38 printf("%d\n", cnt);
39 return 0;
40 }
41
42 /* *
43 * n = 4;
44 *
45 * i = 2, 未筛去, primes[0] = 2
46 * j = 0, primes[j] = 2 <= 4 / 2，4被筛去, i % primes[j] == 2 % 2 == 0, break
47 * i = 3, 未筛去, primes[1] = 3
48 * j = 0, primes[j] = 2 > 4 / 3，break
49 * i = 4, 已筛去
50 *
51 * 这里为什么i % primes[j] == 0, 就要break呢？
52 * 如果不break，4*3 = 12就要被筛去，实际上12会在i = 6, primes[j] = primes[1] = 2，6*2 = 12被筛去
53 * 2是12的最小素因子，比如100的最小素因子是2，所以100会在50 * 2时筛选掉，避免重复筛选
54 * 合数的所有最小因子都是素数，此算法用到这一点
55 */
6.6.1.3 试除法判定素数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：试除法判定素数.cpp
4 * 创建日期：2021年08月03日 星期二 13时59分14秒 5 * 题 目：AcWing 0866 试除法判定素数 6 * 算 法：试除法判定素数 7 * 描 述：给定 n 个正整数 ai，判定每个数是否是质数 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12
13 bool is_prime(int n) {
14 if (n < 2)
15 return false;
16 for (int i = 2; i <= n / i; ++i)
17 if (n % i == 0)
18 return false;
19 return true;
20 }
21
22 int main() {
23 int n; scanf("%d", &n);
24 for (int i = 0; i < n; ++i) {
25 int num; scanf("%d", &num);
26 if (is_prime(num))
27 printf("Yes\n");
28 else
29 printf("No\n");
30 }
31 return 0;
32 }
6.6.2 最大公约数
6.6.2.1 最大公约数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年09月29日 星期三 16时35分55秒 5 * 题 目：AcWing 0872 最大公约数 6 * 算 法：欧几里德算法(辗转相除法) 7 * 描 述：给定 n 对正整数 ai,bi，请你求出每对数的最大公约数
Nanchang university ACM template 第 113 页 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12
13 // gcd(a, b) = gcd(b, a mod b)
14 int gcd(int a, int b) {
15 return b ? gcd(b, a % b) : a;
16 }
17
18 int main() {
19 int n; scanf("%d", &n);
20 while (n ‐‐) {
21 int a, b;
22 scanf("%d %d", &a, &b);
23 printf("%d\n", gcd(a, b));
24 }
25 return 0;
26 }
6.6.3 欧拉函数
6.6.3.1 欧拉函数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：欧拉函数.cpp
4 * 创建日期：2021年09月29日 星期三 17时48分21秒 5 * 题 目：AcWing 0873 欧拉函数 6 * 算 法：欧拉函数 7 * 描 述：给定 n 个正整数 ai，请你求出每个数的欧拉函数 8 * 若在算数基本定理中，N = pa1 * pa2 * ... * pam，则：
9 * ￾ (N) = N × (p1−1)/p1 × (p2−1)/p2 × … × (pm−1)/pm
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 int main() {
15 int n; scanf("%d", &n);
16 while (n ‐‐) {
17 int a; scanf("%d", &a);
18 int res = a;
19 for (int i = 2; i <= a / i; ++ i) {
20 if (a % i == 0) {
21 res = res / i * (i ‐ 1);
22 while (a % i == 0)
23 a /= i;
24 }
25 }
26 if (a > 1)
27 res = res / a * (a ‐ 1);
28 printf("%d\n", res);
29 }
30 return 0;
31 }
6.6.3.2 筛法求欧拉函数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：筛法求欧拉函数.cpp
4 * 创建日期：2021年09月29日 星期三 17时58分25秒 5 * 题 目：AcWing 0874 筛法求欧拉函数 6 * 算 法：<++>
7 * 描 述：给定一个正整数 n，求 1￾n 中每个数的欧拉函数之和 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
Nanchang university ACM template 第 114 页
12 const int maxn = 1e6 + 5;
13 typedef long long ll;
14 int primes[maxn], cnt;
15 int phi[maxn];
16 bool sifter[maxn];
17
18 ll get_eulers(int n) {
19 phi[1] = 1;
20 for (int i = 2; i <= n; ++ i) {
21 if (sifter[i] == false) {
22 primes[cnt ++ ] = i;
23 phi[i] = i ‐ 1;
24 }
25 for (int j = 0; primes[j] <= n / i; ++ j) {
26 sifter[primes[j] * i] = true;
27 if (i % primes[j] == 0) {
28 /**
29 * i * primes[j] 比 i 多一个质因子 primes[j]
30 * 所以根据欧拉公式，N 变化了，且需要多乘一个 (1 ‐ 1/primes[j])
31 * 但是，又因为 i % primes[j] == 0，所以，第一句是错的，看似多乘了
32 * 一个质因子，实际上，i 本身就有这个 primes[j] 的质因子
33 * 因为 N 由 i 变成 i * primes[j]
34 * 根据欧拉公式，phi[i * primes[j]] = primes[j] * phi[i];
35 */
36 phi[i * primes[j]] = primes[j] * phi[i];
37 break;
38 }
39 else {
40 // 否则就多乘一个 1 ‐ 1 / primes[j] 嘛
41 // phi[i * primes[j]] = primes[j] * phi[i] / primes[j] * (primes[j] ‐ 1);
42 phi[i * primes[j]] = phi[i] * (primes[j] ‐ 1);
43 }
44 }
45 }
46
47 ll res = 0;
48 for (int i = 1; i <= n; ++ i)
49 res += phi[i];
50 return res;
51 }
52
53 int main() {
54 int n; scanf("%d", &n);
55 printf("%lld\n", get_eulers(n));
56 return 0;
57 }
6.6.4 类欧几里德算法
6.6.4.1 扩展欧几里德算法.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：扩展欧几里德算法.cpp
4 * 创建日期：2021年10月09日 星期六 19时18分35秒 5 * 题 目：AcWing 0877 扩展欧几里德算法 6 * 算 法：扩展欧几里德算法 7 * 描 述：求 ax + by = gcd(a, b) 任意一个解 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12
13 int gcd(int a, int b) {
14 return b ? gcd(b, a % b) : a;
15 }
16
17 int exgcd(int a, int b, int &x, int &y) {
18 if (!b) {
19 x = 1, y = 0;
Nanchang university ACM template 第 115 页
20 return a;
21 }
22 int d = exgcd(b, a % b, y, x);
23 y ‐= a / b * x;
24 return d;
25 }
26
27 int main() {
28 int n; scanf("%d", &n);
29 while (n ‐‐ ) {
30 int a, b, x, y;
31 scanf("%d %d", &a, &b);
32 exgcd(a, b, x, y);
33 printf("%d %d\n", x, y);
34 }
35 return 0;
36 }
6.6.5 乘法逆元
6.6.5.1 递推.cpp
1 #include<cstdio>
2 int inv[100001];
3 int mod = 99991;
45 //在(mod 99991)的意义下，2 ‐ 10000分别对应的逆元 6 void Inv() {
7 inv[1] = 1;
8 for (int i = 2; i < 10000; ++i) {
9 inv[i] = ‐ mod/i * inv[mod%i] % mod;
10 inv[i] = (mod + inv[i]) % mod;
11 /*inv[i] = (mod ‐ mod/i) * inv[mod%i] % mod;*/ /*会溢出*/
12 }
13 }
14
15 int main() {
16 Inv();
17 for (int i = 0; i < 20; ++i)
18 printf("%d ", inv[i]);
19 return 0;
20 }
6.6.5.2 终极递推.cpp
1 #include <cstdio>
2 typedef long long ll;
3 const int maxn = 1e7;
4 ll inv[maxn];
5 ll mod = 999983;
67 //生成一个表 8 void Inv() {
9 inv[1] = 1;
10 for (int i = 2; i < maxn; ++i)
11 inv[i] = (mod ‐ mod/i) % mod * inv[mod%i] % mod;
12 }
13
14 //求base的逆元
15 ll InvKB(ll base) {
16 if (base == 1)
17 return 1;
18 return InvKB(mod%base) * (mod‐mod/base) % mod;
19 }
20
21 int main() {
22 Inv();
23 for (int i = 0; i < 20; ++i)
24 printf("%lld ", inv[i]);
Nanchang university ACM template 第 116 页
25
26 printf("%lld\n", InvKB(9));
27 return 0;
28 }
6.6.5.3 快速幂求逆元-费马小定理.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：快速幂求逆元.cpp
4 * 创建日期：2021年10月09日 星期六 17时54分32秒 5 * 题 目：AcWing 0876 快速幂求逆元 6 * 算 法：费马小定理，快速幂 7 * 描 述：不与 MOD 互质的数没有在 (mod MOD) 下的逆元 8 * 所以快速幂要求 MOD 一定是一个素数，而扩展欧几里德算法只要求 9 * gcd(a, MOD) = 1，两数互质，MOD 不一定是素数
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 typedef long long ll;
15 int MOD;
16
17 int binpow(int base, int expo) {
18 ll res = 1;
19 while (expo) {
20 if (expo & 1)
21 res = (1LL * res * base) % MOD;
22 base = (1LL * base * base) % MOD;
23 // 也就是base分别是2, 4, 8, 16, ...
24 expo >>= 1;
25 }
26 return res;
27 }
28
29 // 返回0表示无解
30 int inv(int x) {
31 return binpow(x, MOD ‐ 2);
32 }
33
34 int main() {
35 int n; scanf("%d", &n);
36 while (n ‐‐ ) {
37 int a, p; // 求a在(mod p)下的逆元
38 scanf("%d %d", &a, &p);
39 MOD = p;
40 int inverse = inv(a);
41 // p = 2 情况特殊
42 if (a % p) printf("%d\n", inverse);
43 else puts("impossible");
44 }
45 return 0;
46 }
6.6.5.4 扩展欧几里德算法求逆元.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：扩展欧几里德算法求逆元.cpp
4 * 创建日期：2021年10月11日 星期一 17时43分47秒 5 * 题 目：<++>
6 * 算 法：扩展欧几里德算法 7 * 描 述：前提条件: a 与 MOD 互质，如果 MOD 本身就是就是素数 8 * 就不用考虑这个问题 9 *
10 * ax \equiv 1 (mod MOD) x 就是 a 的逆元，逆元就是这样定义的
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
Nanchang university ACM template 第 117 页
13
14 #include <cstdio>
15 int MOD;
16
17 // ll
18 int exgcd(int a, int b, int &x, int &y) {
19 if (!b) {
20 x = 1, y = 0;
21 return a;
22 }
23 int d = exgcd(b, a % b, y, x);
24 y ‐= a / b * x;
25 return d;
26 }
27
28 int inv(int a) {
29 int x, y;
30 int gcd = exgcd(a, MOD, x, y); // 此时得到的x是方程的一个解，但不一定是方程的最小正整数解，x可能为负
31 gcd += 1;
32 // exgcd(a, mod, x, y);
33 return (x % MOD + MOD) % MOD; // (x % m + m) % m 是方程最小正整数解，也就是a模m的逆元
34 }
35
36 int main() {
37 MOD = 99991;
38 for (int i = 2; i < 20; ++ i)
39 printf("%d ", inv(i)); // 求解 i 在 (mod MOD) 下的逆元
40 return 0;
41 }
6.6.6 线性同余方程
6.6.6.1 线性同余方程.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：线性同余方程.cpp
4 * 创建日期：2021年10月11日 星期一 00时29分07秒 5 * 题 目：AcWing 0878 线性同余方程 6 * 算 法：线性同余方程 扩展欧几里德算法 7 * 描 述：求满足 a * x \equiv b (mod m) 的一个解 8 * 转化为 ax + my = b，求x，这个式子有解的充要条件是 gcd(a, m) | b 9 *
10 * 扩展欧几里德算法求的是 ax + my = d (d = gcd(a, b)
11 * 这里要求 ax + my = b 所以等式两边同时扩大 d/b 倍
12 * ‐> (d/b)(ax + my) = d
13 * ax' + my' = d
14 * 最后求出的 x = x' * b/d
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
17
18 #include <cstdio>
19 typedef long long ll;
20
21 int exgcd(int a, int b, int &x, int &y) {
22 if (!b) {
23 x = 1, y = 0;
24 return a;
25 }
26 int d = exgcd(b, a % b, y, x);
27 y ‐= a / b * x;
28 return d;
29 }
30
31 int main() {
32 int n; scanf("%d", &n);
33 while (n ‐‐ ) {
34 int a, b, m;
35 scanf("%d %d %d", &a, &b, &m);
36 int x, y;
Nanchang university ACM template 第 118 页
37 int d = exgcd(a, m, x, y);
38 if (b % d)
39 puts("impossible");
40 else
41 printf("%lld\n", (ll)x * (b / d) % m);
42 }
43 return 0;
44 }
6.6.7 中国剩余定理
6.6.7.1 表达整数的奇怪方式-模数不一定互质.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年10月11日 星期一 21时08分01秒 5 * 题 目：AcWing 0204 表达整数的奇怪方式 6 * 算 法：中国剩余定理 7 * 描 述：下面是推导过程 8 * 看推导过程 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using namespace std;
15 typedef long long ll;
16 const int maxn = 25 + 5;
17
18 ll exgcd(ll a, ll b, ll &x, ll &y) {
19 if (!b) {
20 x = 1, y = 0;
21 return a;
22 }
23 ll d = exgcd(b, a % b, y, x);
24 y ‐= a / b * x;
25 return d;
26 }
27
28 // Chinese Remainder Theorem
29 // k: 方程个数，n: 除数数组，a: 余数数组
30 ll CRT(int k, ll n[], ll a[]) {
31 bool has_result = true;
32 ll n1 = n[0], a1 = a[0];
33 for (int i = 1; i < k; ++ i) {
34 int n2 = n[i], a2 = a[i];
35 ll k1, k2; // k1', k2'
36 ll gcd = exgcd(n1, n2, k1, k2);
37 if ((a2 ‐ a1) % gcd)
38 return ‐1;
39 k1 = k1 * (a2 ‐ a1) / gcd;
40 // 此句不需要，因为只要知道 k1 就知道 x 了
41 // k2 = k2 * (a2 ‐ a1) / gcd;
42 ll t = n2 / gcd;
43 k1 = (k1 % t + t) % t;
44 a1 = n1 * k1 + a1;
45 n1 = abs(n1 / gcd * n2); // lcm
46 }
47 return (a1 % n1 + n1) % n1;
48 }
49
50 int main() {
51 int n; scanf("%d", &n);
52 ll a[maxn], m[maxn]; // 除数数组a[]，余数数组m[]
53 for (int i = 0; i < n; ++ i)
54 scanf("%lld %lld", &a[i], &m[i]);
55 ll res = CRT(n, a, m);
56 printf("%lld\n", res);
57 return 0;
Nanchang university ACM template 第 119 页
58 }
6.6.7.2 表达整数的奇怪方式-模数互质.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：表达整数的奇怪方式.cpp
4 * 创建日期：2021年10月11日 星期一 17时08分43秒 5 * 题 目：AcWing 0204 表达整数的奇怪方式 6 * 算 法：中国剩余定理 7 * 算法描述：
8 * x \equiv a1 (mod n1) 9 * x \equiv a2 (mod n2)
10 * x \equiv a3 (mod n3)
11 * ...
12 * x \equiv ak (mod nk)
13 *
14 * 中国剩余定理：给出上面的 a1~ak，n1~nk，求出 x
15 *
16 * 由于 ni 不一定是素数，所以需要使用扩展欧几里德算法求逆元
17 *
18 * 算法流程：1. 计算所有模数的积 n = n1 * n2 * n3 * ... * nk
19 * 2. 对于第 i 个方程：
20 * 1. 计算 mi = n / ni
21 * 2. 计算 mi 在模 ni 意义下的逆元 mi^‐1
22 * 3. 计算 ci = mi * mi^‐1 (不要对 ni 取模)
23 * 3. 方程组的唯一解为 x = a1*c1%n + a2*c2%n + ... + ak*ck%n;
24 *
25 * 题目描述：
26 * 给定 2n 个整数，a1, a2, ... an 和 m1, m2, ... mn，求最小的
27 * 非负整数 x 满足
28 * x \equiv mi (mod ai)
29 *
30 * 输入样例：
31 * 2
32 * 8 7
33 * 11 9
34 *
35 * x mod 8 = 7
36 * x mod 11 = 9
37 * ‐> x = 31
38 *
39 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
40
41 #include <cstdio>
42 typedef long long ll;
43 const int maxn = 25 + 5;
44
45 ll exgcd(ll a, ll b, ll &x, ll &y) {
46 if (!b) {
47 x = 1, y = 0;
48 return a;
49 }
50 ll d = exgcd(b, a % b, y, x);
51 y ‐= a / b * x;
52 return d;
53 }
54
55 // Chinese Remainder Theorem
56 // k: k 方程个数
57 // n[]: n 数组(除数)
58 // a[]: a 数组(余数)
59 ll CRT(int k, ll n[], ll a[]) {
60 ll prod_n = 1, res = 0;
61 for (int i = 0; i < k; ++ i)
62 prod_n *= n[i];
63 for (int i = 0; i < k; ++ i) {
64 ll mi = prod_n / n[i];
65 // 计算 mi 在模 ni 意义下的逆元 inv_mi
Nanchang university ACM template 第 120 页
66 ll inv_mi, y;
67 exgcd(mi, n[i], inv_mi, y);
68 ll ci = mi * inv_mi;
69 res = (res + a[i] * ci % prod_n) % prod_n;
70 }
71 return (res % prod_n + prod_n) % prod_n;
72 }
73
74 int main() {
75 int n; scanf("%d", &n);
76 ll a[maxn], m[maxn];
77 for (int i = 0; i < n; ++ i)
78 scanf("%lld %lld", &a[i], &m[i]);
79 ll res = CRT(n, a, m);
80 printf("%lld\n", res);
81 return 0;
82 }
6.6.8 分解质因数
6.6.8.1 分解质因数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：分解质因数.cpp
4 * 创建日期：2021年08月04日 星期三 00时03分26秒 5 * 题 目：AcWing 0867 分解质因数 6 * 算 法：试除法分解质因数 7 * 描 述：使用试除法分解质因数 8 * n中至多只包含一个大于sqrt(n)的质因子 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #define NEXTLINE puts("");
14
15 void divide(int n) {
16 // 从小到大枚举，i是底数，expo是指数
17 for (int i = 2; i <= n / i; ++i)
18 if (n % i == 0) {
19 int expo = 0;
20 while (n % i == 0) {
21 n /= i;
22 expo ++ ;
23 }
24 printf("%d %d\n", i, expo);
25 }
26 if (n > 1)
27 printf("%d %d\n", n, 1);
28 }
29
30 int main() {
31 int n; scanf("%d", &n);
32 for (int i = 0; i < n; ++i) {
33 int num; scanf("%d", &num);
34 divide(num);
35 NEXTLINE;
36 }
37 return 0;
38 }
6.6.9 约数
6.6.9.1 约数个数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年09月28日 星期二 21时24分53秒
Nanchang university ACM template 第 121 页 5 * 结束日期：2021年09月28日 星期二 22时37分59秒 6 * 题 目：AcWing 0970 约数个数 7 * 算 法：<++>
8 * 描 述：给定 n 个正整数 ai，请你输出这些数的乘积的约数个数 9 * 答案对 1e9 + 7 取模
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <unordered_map>
15 using namespace std;
16 typedef long long ll;
17 const int MOD = 1e9 + 7;
18
19 int main() {
20 int n; scanf("%d", &n);
21 unordered_map<int, int> primes;
22 while (n ‐‐) {
23 int a; scanf("%d", &a);
24 for (int i = 2; i <= a / i; ++ i) {
25 while (a % i == 0) {
26 a /= i;
27 primes[i] ++ ;
28 }
29 }
30 if (a > 1)
31 primes[a] ++ ;
32 }
33 ll res = 1;
34 for (auto prime : primes)
35 res = res * (prime.second + 1) % MOD;
36 printf("%lld\n", res);
37 return 0;
38 }
6.6.9.2 约数之和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：约数之和.cpp
4 * 创建日期：2021年09月29日 星期三 16时24分18秒 5 * 题 目：AcWing 0871 约数之和 6 * 算 法：<++>
7 * 描 述：给定 n 个正整数 ai，请你输出这些数的乘积的约数之和 8 * 答案对 109+7 取模。
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <unordered_map>
14 using namespace std;
15 typedef long long ll;
16 const int MOD = 1e9 + 7;
17
18 int main() {
19 int n; scanf("%d", &n);
20 unordered_map<int, int> primes;
21 while (n ‐‐) {
22 int a; scanf("%d", &a);
23 for (int i = 2; i <= a / i; ++ i) {
24 while (a % i == 0) {
25 a /= i;
26 primes[i] ++ ;
27 }
28 }
29 if (a > 1)
30 primes[a] ++ ;
31 }
32 ll res = 1;
Nanchang university ACM template 第 122 页
33 for (auto prime : primes) {
34 int p = prime.first, a = prime.second;
35 ll t = 1;
36 while (a ‐‐)
37 t = (t * p + 1) % MOD;
38 res = res * t % MOD;
39 }
40 printf("%lld\n", res);
41 return 0;
42 }
6.6.9.3 试除法求约数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年09月28日 星期二 18时28分47秒 5 * 结束日期：2021年09月28日 星期二 18时37分09秒 6 * 题 目：AcWing 0869 试除法求约数 7 * 算 法：<++>
8 * 描 述：给定 n 个正整数 ai，对于每个整数 ai， 9 * 请你按照从小到大的顺序输出它的所有约数。
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <vector>
15 #include <algorithm>
16 using namespace std;
17 #define NEXTLINE puts("");
18
19 vector<int> get_divisors(int n) {
20 vector<int> res;
21 for (int i = 1; i <= n / i; ++ i)
22 if (n % i == 0) {
23 res.push_back(i);
24 if (n / i != i)
25 res.push_back(n / i);
26 }
27 sort(res.begin(), res.end());
28 return res;
29 }
30
31 int main() {
32 int n; scanf("%d", &n);
33 while (n ‐‐) {
34 int a; scanf("%d", &a);
35 vector<int> res = get_divisors(a);
36 for (auto it = res.begin(); it != res.end(); ++ it)
37 printf("%d ", *it);
38 NEXTLINE;
39 }
40 return 0;
41 }
6.7 多项式
6.7.1 快速傅里叶变换
6.7.1.1 Cooley-Tukey.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Cooley‐Tukey.cpp
4 * 创建日期：2021年07月23日 星期五 12时07分52秒 5 * 题 目：<++>
6 * 算 法：快速傅里叶变换 7 * 描 述：nlOgn的时间下得到两个序列的和的序列 8 * [2 3 4], [2 3 4] ‐‐> [4 5 5 6 6 6 7 7 8]
Nanchang university ACM template 第 123 页 9 * 如果是差的序列，那么先加上一个偏移量
10 * [2 3 4], [‐4 ‐3 ‐2]
11 * ‐‐ +5 ‐‐> [2 3 4], [1, 2, 3]
12 * ‐‐‐‐‐‐‐‐> [3 4 4 5 5 5 6 6 7]
13 * ‐‐ ‐5 ‐‐> [‐2 ‐1 ‐1 0 0 0 1 1 2]
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <algorithm>
19 #include <cmath>
20 using namespace std;
21 const int maxn = 1 << 10; // 定义maxn时一定要让maxn是2的指数
22 const double PI = acos(‐1.0);
23 int a[maxn], b[maxn];
24 #define bug printf("<‐‐>");
25 #define NEXTLINE puts("");
26
27 struct Complex {
28 double r, i; // 一定注意，使用%f输出
29 Complex() {}
30 Complex(double _r, double _i) : r (_r), i (_i) {}
31 inline void real(const double& x) {r = x;}
32 inline double real() {return r;}
33 inline Complex operator + (const Complex& rhs) const {
34 return Complex (r + rhs.r, i + rhs.i) ;
35 }
36 inline Complex operator ‐ (const Complex& rhs) const {
37 return Complex (r ‐ rhs.r, i ‐ rhs.i);
38 }
39 inline Complex operator * (const Complex& rhs) const {
40 return Complex (r*rhs.r ‐ i*rhs.i, r*rhs.i + i*rhs.r);
41 }
42 inline void operator /= (const double& x) {
43 r /= x, i /= x ;
44 }
45 inline void operator *= (const Complex& rhs) {
46 *this = Complex (r*rhs.r ‐ i*rhs.i, r*rhs.i + i*rhs.r);
47 }
48 inline void operator += (const Complex& rhs) {
49 r += rhs.r, i += rhs.i;
50 }
51 inline Complex conj() { // 共轭复数
52 return Complex (r, ‐i) ;
53 }
54 };
55
56 struct FastFourierTransform {
57 // 自己封装的复数类
58 Complex omega[maxn], omegaInverse[maxn];
59
60 void init(const int& n) {
61 for (int i = 0; i < n; ++i) {
62 omega[i] = Complex(cos(2*PI / n*i), sin(2*PI / n*i));
63 omegaInverse[i] = omega[i].conj();
64 }
65 }
66
67 void transform(Complex *a, const int& n, const Complex* omega) {
68 for (int i = 0, j = 0; i < n; ++i) {
69 if (i > j)
70 swap(a[i], a[j]);
71 for (int l = n >> 1; (j ^= l) < l; l >>= 1);
72 }
73
74 for (int l = 2; l <= n; l <<= 1) {
75 int m = l / 2;
76 for (Complex *p = a; p != a + n; p += l)
77 for (int i = 0; i < m; ++i) {
78 Complex t = omega[n / l * i] * p [m + i];
Nanchang university ACM template 第 124 页
79 p[m + i] = p[i] ‐ t;
80 p[i] += t;
81 }
82 }
83 }
84
85 // 由系数表达式离散为点值表达式
86 void dft(Complex *a, const int& n) {
87 transform(a, n, omega);
88 }
89
90 // 由点值表达式转化为系数表达式
91 void idft(Complex *a, const int& n) {
92 transform(a, n, omegaInverse);
93 for (int i = 0; i < n; ++i)
94 a[i] /= n;
95 }
96 } fft;
97
98 int main() {
99 /*
100 * 这是两个多项式的系数：
101 * A(x) = 5 + 2x + 3x^2
102 * B(x) = 2 + 6x + x^2
103 * 下面的len1，len2分别是两个多项式最大项的最高次幂+1
104 * FFT中len一定要是2^k这种形式，否则在进行分治时会左右不均失败
105 */
106 a[0] = 5; a[1] = 2; a[2] = 3;
107 b[0] = 2; b[1] = 6; b[2] = 1;
108 int len1 = 3, len2 = 3;
109 int len = 1;
110 while (len < len1 * 2 || len < len2 * 2)
111 len <<= 1;
112 fft.init(len); // 初始化\omega
113
114 Complex x1[maxn], x2[maxn]; // 存储两个多项式的系数，幂由低到高
115 // 将原本的系数用复数表达，实部是0.0
116 for (int i = 0; i < len; ++i) {
117 x1[i].r = a[i]; x1[i].i = 0.0;
118 x2[i].r = b[i]; x2[i].i = 0.0;
119 }
120 // 由系数表达式离散为点值表达式
121 fft.dft(x1, len); fft.dft(x2, len);
122 // O(n)时间算出结果的点值表达式
123 for (int i = 0; i < len; ++i)
124 x1[i] = x1[i] * x2[i];
125 // 根据结果的点值表达式得到系数表达式
126 fft.idft(x1, len);
127
128 int res[maxn]; // 用不用这个存无所谓，存一下吧，和开头的系数也是数组统一
129 for (int i = 0; i < len; ++i)
130 res[i] = (int)(x1[i].r + 0.5);
131 // 可能高位上系数为0，我们给它预留的位置还是比较多的，它没用完
132 while (len && res[len‐1] == 0)
133 ‐‐len;
134 // 结果就是C(x) = 10 + 34x + 23x^2 + 20x^3 + 3x^4
135 for (int i = 0; i < len; ++i)
136 printf("%d ", res[i]);
137 NEXTLINE
138 return 0;
139 }
6.8 生成函数
6.8.1 普通生成函数
6.8.1.1 递归求整数划分.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 *
Nanchang university ACM template 第 125 页 3 * 文件名称：01‐hdu1082‐递归求整数划分.cpp
4 * 创建日期：2021年03月12日 ‐‐‐‐ 11时05分 5 * 题 目：hdu1028
6 * 算 法：递归 7 * 描 述：题目是1 <= n <= 120所以会TLE
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 /**
13 * 将n划分成最大数不超过m的划分数
14 * 比如当n == 4时
15 * 划分有5种{1, 1, 1, 1}, {1, 1, 2}, {2, 2}, {1, 3}, {4}
16 * 如果有条件限制，比如将4划分成不超过2的划分数
17 * 则只有3种{1, 1, 1, 1}, {1, 1, 2}, {2, 2}
18 *
19 * 不过还是难以置信，怎么想到会有两个参数，难想到
20 * 而且想不到通过比较n与m的大小分支
21 */
22 int part(int n, int m) {
23 if (n == 1 || m == 1) //结束条件，如果无论n == 1还是m == 1，都只有一种情况
24 return 1;
25 else if (n < m) //如果n < m也做不到划分比n大的数
26 return part(n, n);
27 /*
28 * 如果n == m，显然有part(n, n‐1) + 1
29 * +1是因为要不就是划分不超过n ‐ 1的数
30 * 要不就是划分等于n的数，而划分等于n的划分{n}只有一种划分
31 */
32 else if (n == m)
33 return part(n, n‐1) + 1;
34 /*
35 * 特殊情况讨论完就是一般情况
36 * 划分数中要不就是至少有一个m
37 * 要不就是没有m，那么就是m‐1
38 */
39 else
40 return part(n‐m, m) + part(n, m‐1);
41 }
42
43 int main() {
44 int n;
45 while (scanf("%d", &n))
46 printf("%d\n", part(n, n));
47 return 0;
48 }
6.8.1.2 DP 求整数划分.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐DP求整数划分.cpp
4 * 创建日期：2021年03月12日 ‐‐‐‐ 11时16分 5 * 题 目：hud1028
6 * 算 法：动态规划 7 * 描 述：与递归的代码类似 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 200;
13 int dp[maxn][maxn];
14 void part() {
15 for (int n = 1; n <= maxn; ++n)
16 for (int m = 1; m <= maxn; ++m) {
17 if (n == 1 || m == 1)
18 dp[n][m] = 1;
19 else if (n < m)
20 dp[n][m] = dp[n][n];
Nanchang university ACM template 第 126 页
21 else if (n == m)
22 dp[n][m] = dp[n][m‐1] + 1;
23 else
24 dp[n][m] = dp[n][m‐1] + dp[n‐m][m];
25 }
26 }
27
28 int main() {
29 int n;
30 part();
31 while (scanf("%d", &n))
32 printf("%d\n", dp[n][n]);
33 return 0;
34 }
6.8.1.3 生成函数求整数划分.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：03‐生成函数求整数划分.cpp
4 * 创建日期：2021年03月13日 ‐‐‐‐ 03时33分 5 * 题 目：hdu1028
6 * 算 法：生成函数 7 * 描 述：如果说一定要至少用一张2分的邮票，那就在j循环那里加上 8 * if (k == 3 && j == 0) continue; 9 * 以此类推
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 const int maxn = 200;
15 int c1[maxn+1]; //记录展开后第X^n项的系数，即划分n的种类数有c1[n]种
16 int c2[maxn+1]; //记录临时计算结果
17 void part() {
18 for (int i = 0; i <= maxn; ++i) //初始化，即第一部分(1 + x + x^2 + ...)的系数都是1
19 c1[i] = 1, c2[i] = 0;
20 /*
21 * 从第2部分(1 + x^2 + x^4 + ...)开始展开
22 * 也就是说我有面值1分的邮票，有面值2分的邮票，... 有面值200分的邮票，但是面值200分的邮票只有一张
23 * 不过也不会题目也不会出到200，因为到123就溢出了
24 * 如果题目面值小一点，即可认为邮票是可以重复贴的
25 */
26 for (int k = 2; k <= maxn; ++k) {
27 for (int i = 0; i <= maxn; ++i)
28 //k = 2时，i循环第1部分(1 + x + x^2 + ...)，j循环第2部分(1 + x^2 + x^4 + ...)
29 for (int j = 0; j + i <= maxn; j += k)
30 c2[i+j] += c1[i];
31 for (int i = 0; i <= maxn; ++i) {
32 c1[i] = c2[i];
33 c2[i] = 0;
34 }
35 }
36 }
37
38 int main() {
39 part();
40 for (int i = 0; i < 122; ++i)
41 printf("%d\n", c1[i]);
42 return 0;
43 }
6.8.2 指数生成函数
6.8.2.1 排列组合.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐排列组合.cpp
4 * 创建日期：2021年03月12日 ‐‐‐‐ 22时16分
Nanchang university ACM template 第 127 页 5 * 题 目：hdu1521 排列组合 6 * 算 法：指数型母函数 7 * 描 述：有n种物品，并且知道每种物品的数量，求从中选出m件物品 8 * 的排列数，例如有两种物品A, B，并且数量都是1,从中选两件物品 9 * 则排列有"AB"和"BA"两种
10 *
11 * 输入：每组输入数据有两行，第一行是两个数n和m(1 <= m, n <= 10)
12 * 表示物品数；第二行有n个数，分别表示这n件物品的数量
13 *
14 * 输出：对应每组数据输出排列数(任何运算不会超过2^31的范围)
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
6.9 线性代数
6.9.1 高斯消元
6.9.1.1 高斯消元解异或线性方程组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：高斯消元解异或线性方程组.cpp
4 * 创建日期：2021年10月13日 星期三 00时06分27秒 5 * 题 目：AcWing 0884 高斯消元解异或线性方程组 6 * 算 法：高斯消元 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using namespace std;
14 const int maxn = 105;
15 int n;
16 int a[maxn][maxn];
17
18 int guass() {
19 int r, c;
20 for (r = c = 0; c < n; ++ c) {
21 int temp = r;
22 for (int i = r; i < n; ++ i)
23 if (a[i][c]) {
24 temp = i;
25 break;
26 }
27 if (!a[temp][c])
28 continue;
29 for (int i = c; i < n + 1; ++ i)
30 swap(a[r][i], a[temp][i]);
31 for (int i = r + 1; i < n; ++ i)
32 if (a[i][c])
33 for (int j = c; j < n + 1; ++ j)
34 a[i][j] ^= a[r][j];
35 r ++ ;
36 }
37 if (r < n) {
38 for (int i = r; i < n; ++ i)
39 if (a[i][n])
40 return 2;
41 return 1;
42 }
43 for (int i = n ‐ 1; i >= 0; ‐‐ i)
44 for (int j = i + 1; j < n; ++ j)
45 a[i][n] ^= a[i][j] & a[j][n];
46 return 0;
47 }
48
49 int main() {
50 scanf("%d", &n);
51 for (int i = 0; i < n; ++ i)
Nanchang university ACM template 第 128 页
52 for (int j = 0; j < n + 1; ++ j)
53 scanf("%d", &a[i][j]);
54 int t = guass();
55 if (t == 0)
56 for (int i = 0; i < n; ++ i)
57 printf("%d\n", a[i][n]);
58 else if (t == 1)
59 puts("Multiple sets of solutions");
60 else
61 puts("No solution");
62 return 0;
63 }
6.9.1.2 高斯消元解线性方程组.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：高斯消元解线性方程组.cpp
4 * 创建日期：2021年10月12日 星期二 23时16分11秒 5 * 题 目：AcWing 0883 高斯消元解线性方程组 6 * 算 法：高斯消元 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cmath>
13 #include <algorithm>
14 using namespace std;
15 const int maxn = 105;
16 int n;
17 double a[maxn][maxn]; // Augmented matrix 增广矩阵
18 const double eps = 1e‐6;
19
20 inline int sgn(double x) { // 判断x是否等于0
21 if (fabs(x) < eps) return 0;
22 else return x < 0 ? ‐1 : 1;
23 }
24
25 /**
26 * 枚举每一列
27 * 1. 找到绝对值最大的一行
28 * 2. 将该行换到最上面
29 * 3. 将该行的第一个数变成1
30 * 4. 将下面所有行的第 c 列清成0
31 */
32
33 // 0: 唯一解，1: 无穷组解，2: 无解
34 int guess() {
35 int r, c; // 枚举第 r(ow) 行，第 c(olumn) 列
36 for (c = 0, r = 0; c < n; ++ c) {
37 int temp = r;
38 // 找到当前列绝对值最大的一行
39 for (int i = r; i < n; ++ i)
40 if (fabs(a[i][c]) > fabs(a[temp][c]))
41 temp = i;
42 // 如果找到的当前列最大的一行是0，表示这一列全是0，就不用将该行换到上面了
43 if (sgn(fabs(a[temp][c])) == 0)
44 continue;
45
46 for (int i = c; i < n + 1; ++ i)
47 swap(a[r][i], a[temp][i]);
48 for (int i = n; i >= c; ‐‐ i)
49 a[r][i] /= a[r][c];
50 for (int i = r + 1; i < n; ++ i)
51 if (sgn(abs(a[i][c])) != 0)
52 for (int j = n; j >= c; ‐‐ j)
53 a[i][j] ‐= a[r][j] * a[i][c];
54 r ++ ;
Nanchang university ACM template 第 129 页
55 }
56 if (r < n) {
57 for (int i = r; i < n; ++ i)
58 if (sgn(fabs(a[i][n])) != 0)
59 return 2;
60 return 1;
61 }
62 for (int i = n ‐ 1; i >= 0; ‐‐ i)
63 for (int j = i + 1; j < n; ++ j)
64 a[i][n] ‐= a[i][j] * a[j][n];
65 return 0;
66 }
67
68 int main() {
69 scanf("%d", &n);
70 for (int i = 0; i < n; ++ i)
71 for (int j = 0; j < n + 1; ++ j) // n + 1
72 scanf("%lf", &a[i][j]);
73 int t = guess();
74 if (t == 0)
75 for (int i = 0; i < n; ++ i)
76 printf("%.2lf\n", a[i][n]);
77 else if (t == 1)
78 puts("Infinite group solutions");
79 else
80 puts("No solution");
81 return 0;
82 }
6.10 组合数学
6.10.1 排列组合
6.10.1.1 求组合数 I.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：求组合数I.cpp
4 * 创建日期：2021年10月13日 星期三 14时25分48秒 5 * 题 目：AcWing 0885 求组合数I 6 * 算 法：组合数 7 * 描 述：给定 n 组询问，每组询问给定两个整数 a，b， 8 * 请你输出 C_a^b mod (1e9 +7) 的值 9 * 0 < n < 100000
10 * 0 < a, b < 2000
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 const int maxn = 2000 + 5;
16 const int MOD = 1e9 + 7;
17 int c[maxn][maxn];
18
19 void init() {
20 // 使用递推公式预处理组合数
21 for (int a = 0; a < maxn; ++ a)
22 for (int b = 0; b <= a; ++ b) {
23 if (!b)
24 c[a][b] = 1;
25 else
26 c[a][b] = (c[a ‐ 1][b] + c[a ‐ 1][b ‐ 1]) % MOD;
27 }
28 }
29
30 int main() {
31 init();
32 int n; scanf("%d", &n);
33 for (int i = 0; i < n; ++ i) {
34 int a, b;
35 scanf("%d %d", &a, &b);
Nanchang university ACM template 第 130 页
36 printf("%d\n", c[a][b]);
37 }
38 return 0;
39 }
6.10.1.2 求组合数 II.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：求组合数II.cpp
4 * 创建日期：2021年10月13日 星期三 16时35分18秒 5 * 题 目：AcWing 0886 求组合数II
6 * 算 法：组合数 7 * 描 述：给定 n 组询问，每组询问给定两个整数 a，b， 8 * 请你输出 C_a^b mod (1e9 +7) 的值 9 * 0 < n < 10000
10 * 0 < a, b < 1e5
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 // 同样是预处理，这次处理的是阶乘
15 // C_a^b = a! / ((a ‐ b)! * b!)
16 #include <cstdio>
17 typedef long long ll;
18 typedef long long LL;
19 const int MOD = 1e9 + 7;
20 const int maxn = 1e5 + 5;
21 int fact[maxn], inv_fact[maxn];
22
23 int binpow(int base, int expo) {
24 int res = 1;
25 while (expo) {
26 if (expo & 1)
27 res = (1LL * res * base) % MOD;
28 base = (1LL * base * base) % MOD;
29 expo >>= 1;
30 }
31 return res;
32 }
33
34 int inv(int x) {
35 return binpow(x, MOD ‐ 2);
36 }
37
38 void init() {
39 fact[0] = 1, inv_fact[0] = 1;
40 for (int i = 1; i < maxn; ++ i) {
41 fact[i] = (LL)fact[i ‐ 1] * i % MOD;
42 inv_fact[i] = (LL)inv_fact[i ‐ 1] * inv(i) % MOD;
43 }
44 }
45
46 int main() {
47 init();
48 int n; scanf("%d", &n);
49 for (int i = 0; i < n; ++ i) {
50 int a, b;
51 scanf("%d %d", &a, &b);
52 printf("%d\n", (LL)fact[a] * inv_fact[a ‐ b] % MOD * inv_fact[b] % MOD);
53 }
54 return 0;
55 }
6.10.1.3 求组合数 III.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：求组合数III.cpp
Nanchang university ACM template 第 131 页 4 * 创建日期：2021年10月13日 星期三 16时52分04秒 5 * 题 目：AcWing 0887 求组合数III
6 * 算 法：组合数 7 * 描 述：给定 n 组询问，每组询问给定三个整数 a, b, p 8 * 其中 p 是质数，请你输出 C_a^b % p 的值。
9 * 0 <= n <= 21
10 * 1 <= b < a <= 1e18
11 * 1 <= p <= 1e5
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 /**
16 * C_a^b % p = C_{a/p}^{b/p} * C_{a%p}^{b%p} % p;
17 */
18
19 #include <cstdio>
20 typedef long long ll;
21 int p;
22 int MOD;
23
24 int binpow(int base, int expo) {
25 int res = 1;
26 while (expo) {
27 if (expo & 1)
28 res = (1LL * res * base) % MOD;
29 base = (1LL * base * base) % MOD;
30 expo >>= 1;
31 }
32 return res;
33 }
34
35 int inv(int x) {
36 return binpow(x, MOD ‐ 2);
37 }
38
39 int C(int a, int b) {
40 int res = 1;
41 for (int i = 1, j = a; i <= b; ++ i, ‐‐ j) {
42 res = (ll)res * j % p;
43 res = (ll)res * inv(i) % p;
44 }
45 return res;
46 }
47
48 int lucas(ll a, ll b) {
49 if (a < p && b < p)
50 return C(a, b);
51 else
52 return (ll)C(a % p, b % p) * lucas(a / p, b / p) % p;
53 }
54
55 int main() {
56 int n; scanf("%d", &n);
57 while (n ‐‐ ) {
58 ll a, b;
59 scanf("%lld %lld %d", &a, &b, &p);
60 MOD = p;
61 printf("%d\n", lucas(a, b));
62 }
63 return 0;
64 }
6.10.1.4 求组合数 IV.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：求组合数IV.cpp
4 * 创建日期：2021年10月13日 星期三 17时44分06秒 5 * 题 目：AcWing 0888 求组合数IV
Nanchang university ACM template 第 132 页 6 * 算 法：组合数 7 * 描 述：输入 a, b，求 C_a^b 的值 8 * 注意结果可能很大，需要使用高精度计算。
9 *
10 * 1. 得到质数表
11 * 2. 将结果分解质因子
12 *
13 * a! 中素因子 p 的个数是 cnt = a / p + a / p^2 + a / p^3 + ...
14 *
15 * 3. 高精度乘法
16 *
17 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
18
19 #include <cstdio>
20 #include <vector>
21 using namespace std;
22 const int maxn = 5000 + 5;
23 int primes[maxn], cnt;
24 int sum[maxn];
25 bool sifter[maxn];
26 #define NEXTLINE puts("");
27
28 void get_primes(int n) {
29 for (int i = 2; i <= n; ++ i) {
30 if (sifter[i] == false)
31 primes[cnt ++ ] = i;
32 for (int j = 0; primes[j] <= n / i; ++ j) {
33 sifter[primes[j] * i] = true;
34 if (i % primes[j] == 0)
35 break;
36 }
37 }
38 }
39
40 // n! 中包含的素因子 p 的个数
41 int get(int n, int p) {
42 int res = 0;
43 while (n) {
44 res += n / p;
45 n /= p;
46 }
47 return res;
48 }
49
50 vector<int> mul(vector<int> a, int b) {
51 vector<int> c;
52 int t = 0;
53 for (int i = 0; i < a.size(); ++ i) {
54 t += a[i] * b;
55 c.push_back(t % 10);
56 t /= 10;
57 }
58 while (t) {
59 c.push_back(t % 10);
60 t /= 10;
61 }
62 return c;
63 }
64
65 int main() {
66 int a, b;
67 scanf("%d %d", &a, &b);
68 get_primes(a);
69 for (int i = 0; i < cnt; ++ i) {
70 int p = primes[i];
71 sum[i] = get(a, p) ‐ get(b, p) ‐ get(a ‐ b, p);
72 }
73 vector<int> res;
74 res.push_back(1);
75
Nanchang university ACM template 第 133 页
76 for (int i = 0; i < cnt; ++ i)
77 for (int j = 0; j < sum[i]; ++ j)
78 res = mul(res, primes[i]);
79
80 for (int i = res.size() ‐ 1; i >= 0; ‐‐ i)
81 printf("%d", res[i]);
82 NEXTLINE;
83 return 0;
84 }
6.10.2 卡特兰数
6.10.2.1 满足条件的 01 序列.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：满足条件的01序列.cpp
4 * 创建日期：2021年10月13日 星期三 22时19分09秒 5 * 题 目：AcWing 0889 满足条件的01序列 6 * 算 法：卡特兰数 7 * 描 述：给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 8 * 2n 的序列，求它们能排列成的所有序列中，
9 * 能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 const int MOD = 1e9 + 7;
15
16 int binpow(int base, int expo) {
17 int res = 1;
18 while (expo) {
19 if (expo & 1)
20 res = (1LL * res * base) % MOD;
21 base = (1LL * base * base) % MOD;
22 expo >>= 1;
23 }
24 return res;
25 }
26
27 int inv(int x) {
28 return binpow(x, MOD ‐ 2);
29 }
30
31 int main() {
32 int n; scanf("%d", &n);
33 int a = 2 * n, b = n;
34 int res = 1;
35 for (int i = a; i > a ‐ b; ‐‐ i)
36 res = 1LL * res * i % MOD;
37 for (int i = 1; i <= b; ++ i)
38 res = 1LL * res * inv(i) % MOD;
39 res = 1LL * res * inv(n + 1) % MOD;
40 printf("%d\n", res);
41 return 0;
42 }
6.10.3 斯特林数
6.10.3.1 Stirling.cpp
1 #ifndef _FEISTDLIB_POLY_
2 #define _FEISTDLIB_POLY_
34 /*
5 * This file is part of the fstdlib project. 6 * Version: Build v0.0.2
7 * You can check for details at https://github.com/FNatsuka/fstdlib
8 */
Nanchang university ACM template 第 134 页 9
10 #include <cstdio>
11 #include <vector>
12 #include <algorithm>
13 #include <cmath>
14
15 namespace fstdlib{
16
17 typedef long long ll;
18 int mod = 998244353, grt = 3;
19
20 class poly{
21 private:
22 std::vector<int> data;
23 void out(void){
24 for(int i = 0; i < (int)data.size(); ++i) printf("%d ", data[i]);
25 puts("");
26 }
27 public:
28 poly(std::size_t len = std::size_t(0)){data = std::vector<int>(len); }
29 poly(const std::vector<int> &b){data = b; }
30 poly(const poly &b){data = b.data; }
31 void resize(std::size_t len, int val = 0){data.resize(len, val); }
32 std::size_t size(void)const{return data.size(); }
33 void clear(void){data.clear(); }
34 #if __cplusplus >= 201103L
35 void shrink_to_fit(void){data.shrink_to_fit(); }
36 #endif
37 int &operator[](std::size_t b){return data[b]; }
38 const int &operator[](std::size_t b)const{return data[b]; }
39 poly operator*(const poly& h)const;
40 poly operator*=(const poly &h);
41 poly operator*(const int &h)const;
42 poly operator*=(const int &h);
43 poly operator+(const poly &h)const;
44 poly operator+=(const poly &h);
45 poly operator‐(const poly &h)const;
46 poly operator‐=(const poly &h);
47 poly operator<<(const std::size_t &b)const;
48 poly operator<<=(const std::size_t &b);
49 poly operator>>(const std::size_t &b)const;
50 poly operator>>=(const std::size_t &b);
51 poly operator/(const int &h)const;
52 poly operator/=(const int &h);
53 poly operator==(const poly &h)const;
54 poly operator!=(const poly &h)const;
55 poly operator+(const int &h)const;
56 poly operator+=(const int &h);
57 poly inv(void)const;
58 poly inv(const int &h)const;
59 friend poly sqrt(const poly &h);
60 friend poly log(const poly &h);
61 friend poly exp(const poly &h);
62 };
63
64 int qpow(int a, int b, int p = mod){
65 int res = 1;
66 while(b){if(b & 1) res = (ll)res * a % p; a = (ll)a * a % p, b >>= 1; }
67 return res;
68 }
69
70 std::vector<int> rev;
71 void dft_for_module(std::vector<int> &f, int n, int b){
72 static std::vector<int> w;
73 w.resize(n);
74 for(int i = 0; i < n; ++i) if(i < rev[i]) std::swap(f[i], f[rev[i]]);
75 for(int i = 2; i <= n; i <<= 1){
76 w[0] = 1, w[1] = qpow(grt, (mod ‐ 1) / i); if(b == ‐1) w[1] = qpow(w[1], mod ‐ 2);
77 for(int j = 2; j < i / 2; ++j) w[j] = (ll)w[j ‐ 1] * w[1] % mod;
78 for(int j = 0; j < n; j += i)
Nanchang university ACM template 第 135 页
79 for(int k = 0; k < i / 2; ++k){
80 int p = f[j + k], q = (ll)f[j + k + i / 2] * w[k] % mod;
81 f[j + k] = (p + q) % mod, f[j + k + i / 2] = (p ‐ q + mod) % mod;
82 }
83 }
84 }
85
86 poly poly::operator*(const poly &h)const{
87 int N = 1; while(N < (int)(size() + h.size() ‐ 1)) N <<= 1;
88 std::vector<int> f(this‐>data), g(h.data); f.resize(N), g.resize(N);
89 rev.resize(N);
90 for(int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? N >> 1 : 0);
91 dft_for_module(f, N, 1), dft_for_module(g, N, 1);
92 for(int i = 0; i < N; ++i) f[i] = (ll)f[i] * g[i] % mod;
93 dft_for_module(f, N, ‐1), f.resize(size() + h.size() ‐ 1);
94 for(int i = 0, inv = qpow(N, mod ‐ 2); i < (int)f.size(); ++i) f[i] = (ll)f[i] * inv % mod;
95 return f;
96 }
97
98 poly poly::operator*=(const poly &h){
99 return *this = *this * h;
100 }
101
102 poly poly::operator*(const int &h)const{
103 std::vector<int> f(this‐>data);
104 for(int i = 0; i < (int)f.size(); ++i) f[i] = (ll)f[i] * h % mod;
105 return f;
106 }
107
108 poly poly::operator*=(const int &h){
109 for(int i = 0; i < (int)size(); ++i) data[i] = (ll)data[i] * h % mod;
110 return *this;
111 }
112
113 poly poly::operator+(const poly &h)const{
114 std::vector<int> f(this‐>data);
115 if(f.size() < h.size()) f.resize(h.size());
116 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] + h[i]) % mod;
117 return f;
118 }
119
120 poly poly::operator+=(const poly &h){
121 std::vector<int> &f = this‐>data;
122 if(f.size() < h.size()) f.resize(h.size());
123 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] + h[i]) % mod;
124 return f;
125 }
126
127 poly poly::operator‐(const poly &h)const{
128 std::vector<int> f(this‐>data);
129 if(f.size() < h.size()) f.resize(h.size());
130 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] ‐ h[i] + mod) % mod;
131 return f;
132 }
133
134 poly poly::operator‐=(const poly &h){
135 std::vector<int> &f = this‐>data;
136 if(f.size() < h.size()) f.resize(h.size());
137 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] ‐ h[i] + mod) % mod;
138 return f;
139 }
140
141 poly poly::operator<<(const std::size_t &b)const{
142 std::vector<int> f(size() + b);
143 for(int i = 0; i < (int)size(); ++i) f[i + b] = data[i];
144 return f;
145 }
146
147 poly poly::operator<<=(const std::size_t &b){
148 return *this = (*this) << b;
Nanchang university ACM template 第 136 页
149 }
150
151 poly poly::operator>>(const std::size_t &b)const{
152 std::vector<int> f(size() ‐ b);
153 for(int i = 0; i < (int)f.size(); ++i) f[i] = data[i + b];
154 return f;
155 }
156
157 poly poly::operator>>=(const std::size_t &b){
158 return *this = (*this) >> b;
159 }
160
161 poly poly::operator/(const int &h)const{
162 std::vector<int> f(this‐>data); int inv = qpow(h, mod ‐ 2);
163 for(int i = 0; i < (int)f.size(); ++i) f[i] = (ll)f[i] * inv % mod;
164 return f;
165 }
166
167 poly poly::operator/=(const int &h){
168 int inv = qpow(h, mod ‐ 2);
169 for(int i = 0; i < (int)data.size(); ++i) data[i] = (ll)data[i] * inv % mod;
170 return *this;
171 }
172
173 poly poly::inv(void)const{
174 int N = 1; while(N < (int)(size() + size() ‐ 1)) N <<= 1;
175 std::vector<int> f(N), g(N), d(this‐>data);
176 d.resize(N), f[0] = qpow(d[0], mod ‐ 2);
177 for(int w = 2; w < N; w <<= 1){
178 for(int i = 0; i < w; ++i) g[i] = d[i];
179 rev.resize(w << 1);
180 for(int i = 0; i < w * 2; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? w : 0);
181 dft_for_module(f, w << 1, 1), dft_for_module(g, w << 1, 1);
182 for(int i = 0; i < w * 2; ++i) f[i] = (ll)f[i] * (2 + mod ‐ (ll)f[i] * g[i] % mod) % mod;
183 dft_for_module(f, w << 1, ‐1);
184 for(int i = 0, inv = qpow(w << 1, mod ‐ 2); i < w; ++i) f[i] = (ll)f[i] * inv % mod;
185 for(int i = w; i < w * 2; ++i) f[i] = 0;
186 }
187 f.resize(size());
188 return f;
189 }
190
191 poly poly::operator==(const poly &h)const{
192 if(size() != h.size()) return 0;
193 for(int i = 0; i < (int)size(); ++i) if(data[i] != h[i]) return 0;
194 return 1;
195 }
196
197 poly poly::operator!=(const poly &h)const{
198 if(size() != h.size()) return 1;
199 for(int i = 0; i < (int)size(); ++i) if(data[i] != h[i]) return 1;
200 return 0;
201 }
202
203 poly poly::operator+(const int &h)const{
204 poly f(this‐>data);
205 f[0] = (f[0] + h) % mod;
206 return f;
207 }
208
209 poly poly::operator+=(const int &h){
210 return *this = (*this) + h;
211 }
212
213 poly poly::inv(const int &h)const{
214 poly f(*this);
215 f.resize(h);
216 return f.inv();
217 }
218
Nanchang university ACM template 第 137 页
219 int modsqrt(int h, int p = mod){
220 return 1;
221 }
222
223 poly sqrt(const poly &h){
224 int N = 1; while(N < (int)(h.size() + h.size() ‐ 1)) N <<= 1;
225 poly f(N), g(N), d(h); d.resize(N), f[0] = modsqrt(d[0]);
226 for(int w = 2; w < N; w <<= 1){
227 g.resize(w);
228 for(int i = 0; i < w; ++i) g[i] = d[i];
229 f = (f + f.inv(w) * g) / 2;
230 f.resize(w);
231 }
232 f.resize(h.size());
233 return f;
234 }
235
236 poly log(const poly &h){
237 poly f(h);
238 for(int i = 1; i < (int)f.size(); ++i) f[i ‐ 1] = (ll)f[i] * i % mod;
239 f[f.size() ‐ 1] = 0, f = f * h.inv(), f.resize(h.size());
240 for(int i = (int)f.size() ‐ 1; i > 0; ‐‐i) f[i] = (ll)f[i ‐ 1] * qpow(i, mod ‐ 2) % mod;
241 f[0] = 0;
242 return f;
243 }
244
245 poly exp(const poly &h){
246 int N = 1; while(N < (int)(h.size() + h.size() ‐ 1)) N <<= 1;
247 poly f(N), g(N), d(h);
248 f[0] = 1, d.resize(N);
249 for(int w = 2; w < N; w <<= 1){
250 f.resize(w), g.resize(w);
251 for(int i = 0; i < w; ++i) g[i] = d[i];
252 f = f * (g + 1 ‐ log(f));
253 f.resize(w);
254 }
255 f.resize(h.size());
256 return f;
257 }
258
259 struct comp{
260 long double x, y;
261 comp(long double _x = 0, long double _y = 0) : x(_x), y(_y) {}
262 comp operator*(const comp &b)const{return comp(x * b.x ‐ y * b.y, x * b.y + y * b.x); }
263 comp operator+(const comp &b)const{return comp(x + b.x, y + b.y); }
264 comp operator‐(const comp &b)const{return comp(x ‐ b.x, y ‐ b.y); }
265 comp conj(void){return comp(x, ‐y); }
266 };
267
268 const int EPS = 1e‐9;
269
270 template <typename FLOAT_T>
271 FLOAT_T fabs(const FLOAT_T &x){
272 return x > 0 ? x : ‐x;
273 }
274
275 template <typename FLOAT_T>
276 FLOAT_T sin(const FLOAT_T &x, const long double &EPS = fstdlib::EPS){
277 FLOAT_T res = 0, delt = x;
278 int d = 0;
279 while(fabs(delt) > EPS){
280 res += delt, ++d;
281 delt *= ‐ x * x / ((2 * d) * (2 * d + 1));
282 }
283 return res;
284 }
285
286 template <typename FLOAT_T>
287 FLOAT_T cos(const FLOAT_T &x, const long double &EPS = fstdlib::EPS){
288 FLOAT_T res = 0, delt = 1;
Nanchang university ACM template 第 138 页
289 int d = 0;
290 while(fabs(delt) > EPS){
291 res += delt, ++d;
292 delt *= ‐ x * x / ((2 * d) * (2 * d ‐ 1));
293 }
294 return res;
295 }
296
297 const long double PI = std::acos((long double)(‐1));
298
299 void dft_for_complex(std::vector<comp> &f, int n, int b){
300 static std::vector<comp> w;
301 w.resize(n);
302 for(int i = 0; i < n; ++i) if(i < rev[i]) std::swap(f[i], f[rev[i]]);
303 for(int i = 2; i <= n; i <<= 1){
304 w[0] = comp(1, 0), w[1] = comp(cos(2 * PI / i), b * sin(2 * PI / i));
305 for(int j = 2; j < i / 2; ++j) w[j] = w[j ‐ 1] * w[1];
306 for(int j = 0; j < n; j += i)
307 for(int k = 0; k < i / 2; ++k){
308 comp p = f[j + k], q = f[j + k + i / 2] * w[k];
309 f[j + k] = p + q, f[j + k + i / 2] = p ‐ q;
310 }
311 }
312 }
313
314 class arbitrary_module_poly{
315 private:
316 std::vector<int> data;
317 int construct_element(int D, ll x, ll y, ll z)const{
318 x %= mod, y %= mod, z %= mod;
319 return ((ll)D * D * x % mod + (ll)D * y % mod + z) % mod;
320 }
321 public:
322 int mod;
323 arbitrary_module_poly(std::size_t len = std::size_t(0), int module_value = 1e9 + 7){mod =
module_value; data = std::vector<int>(len); }
324 arbitrary_module_poly(const std::vector<int> &b, int module_value = 1e9 + 7){mod = module_value;
data = b; }
325 arbitrary_module_poly(const arbitrary_module_poly &b){mod = b.mod; data = b.data; }
326 void resize(std::size_t len, const int &val = 0){data.resize(len, val); }
327 std::size_t size(void)const{return data.size(); }
328 void clear(void){data.clear(); }
329 #if __cplusplus >= 201103L
330 void shrink_to_fit(void){data.shrink_to_fit(); }
331 #endif
332 int &operator[](std::size_t b){return data[b]; }
333 const int &operator[](std::size_t b)const{return data[b]; }
334 arbitrary_module_poly operator*(const arbitrary_module_poly& h)const;
335 arbitrary_module_poly operator*=(const arbitrary_module_poly &h);
336 arbitrary_module_poly operator*(const int &h)const;
337 arbitrary_module_poly operator*=(const int &h);
338 arbitrary_module_poly operator+(const arbitrary_module_poly &h)const;
339 arbitrary_module_poly operator+=(const arbitrary_module_poly &h);
340 arbitrary_module_poly operator‐(const arbitrary_module_poly &h)const;
341 arbitrary_module_poly operator‐=(const arbitrary_module_poly &h);
342 arbitrary_module_poly operator<<(const std::size_t &b)const;
343 arbitrary_module_poly operator<<=(const std::size_t &b);
344 arbitrary_module_poly operator>>(const std::size_t &b)const;
345 arbitrary_module_poly operator>>=(const std::size_t &b);
346 arbitrary_module_poly operator/(const int &h)const;
347 arbitrary_module_poly operator/=(const int &h);
348 arbitrary_module_poly operator==(const arbitrary_module_poly &h)const;
349 arbitrary_module_poly operator!=(const arbitrary_module_poly &h)const;
350 arbitrary_module_poly inv(void)const;
351 arbitrary_module_poly inv(const int &h)const;
352 friend arbitrary_module_poly sqrt(const arbitrary_module_poly &h);
353 friend arbitrary_module_poly log(const arbitrary_module_poly &h);
354 };
355
356 arbitrary_module_poly arbitrary_module_poly::operator*(const arbitrary_module_poly& h)const{
Nanchang university ACM template 第 139 页
357 int N = 1; while(N < (int)(size() + h.size() ‐ 1)) N <<= 1;
358 std::vector<comp> f(N), g(N), p(N), q(N);
359 const int D = std::sqrt(mod);
360 for(int i = 0; i < (int)size(); ++i) f[i].x = data[i] / D, f[i].y = data[i] % D;
361 for(int i = 0; i < (int)h.size(); ++i) g[i].x = h[i] / D, g[i].y = h[i] % D;
362 rev.resize(N);
363 for(int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? N >> 1 : 0);
364 dft_for_complex(f, N, 1), dft_for_complex(g, N, 1);
365 for(int i = 0; i < N; ++i){
366 p[i] = (f[i] + f[(N ‐ i) % N].conj()) * comp(0.50, 0) * g[i];
367 q[i] = (f[i] ‐ f[(N ‐ i) % N].conj()) * comp(0, ‐0.5) * g[i];
368 }
369 dft_for_complex(p, N, ‐1), dft_for_complex(q, N, ‐1);
370 std::vector<int> r(size() + h.size() ‐ 1);
371 for(int i = 0; i < (int)r.size(); ++i)
372 r[i] = construct_element(D, p[i].x / N + 0.5, (p[i].y + q[i].x) / N + 0.5, q[i].y / N + 0.5);
373 return arbitrary_module_poly(r, mod);
374 }
375
376 arbitrary_module_poly arbitrary_module_poly::operator*=(const arbitrary_module_poly &h){
377 return *this = *this * h;
378 }
379
380 arbitrary_module_poly arbitrary_module_poly::operator*(const int &h)const{
381 std::vector<int> f(this‐>data);
382 for(int i = 0; i < (int)f.size(); ++i) f[i] = (ll)f[i] * h % mod;
383 return arbitrary_module_poly(f, mod);
384 }
385
386 arbitrary_module_poly arbitrary_module_poly::operator*=(const int &h){
387 for(int i = 0; i < (int)size(); ++i) data[i] = (ll)data[i] * h % mod;
388 return *this;
389 }
390
391 arbitrary_module_poly arbitrary_module_poly::operator+(const arbitrary_module_poly &h)const{
392 std::vector<int> f(this‐>data);
393 if(f.size() < h.size()) f.resize(h.size());
394 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] + h[i]) % mod;
395 return arbitrary_module_poly(f, mod);
396 }
397
398 arbitrary_module_poly arbitrary_module_poly::operator+=(const arbitrary_module_poly &h){
399 if(size() < h.size()) resize(h.size());
400 for(int i = 0; i < (int)h.size(); ++i) data[i] = (data[i] + h[i]) % mod;
401 return *this;
402 }
403
404 arbitrary_module_poly arbitrary_module_poly::operator‐(const arbitrary_module_poly &h)const{
405 std::vector<int> f(this‐>data);
406 if(f.size() < h.size()) f.resize(h.size());
407 for(int i = 0; i < (int)h.size(); ++i) f[i] = (f[i] + mod ‐ h[i]) % mod;
408 return arbitrary_module_poly(f, mod);
409 }
410
411 arbitrary_module_poly arbitrary_module_poly::operator‐=(const arbitrary_module_poly &h){
412 if(size() < h.size()) resize(h.size());
413 for(int i = 0; i < (int)h.size(); ++i) data[i] = (data[i] + mod ‐ h[i]) % mod;
414 return *this;
415 }
416
417 arbitrary_module_poly arbitrary_module_poly::operator<<(const std::size_t &b)const{
418 std::vector<int> f(size() + b);
419 for(int i = 0; i < (int)size(); ++i) f[i + b] = data[i];
420 return arbitrary_module_poly(f, mod);
421 }
422
423 arbitrary_module_poly arbitrary_module_poly::operator<<=(const std::size_t &b){
424 return *this = (*this) << b;
425 }
426
Nanchang university ACM template 第 140 页
427 arbitrary_module_poly arbitrary_module_poly::operator>>(const std::size_t &b)const{
428 std::vector<int> f(size() ‐ b);
429 for(int i = 0; i < (int)f.size(); ++i) f[i] = data[i + b];
430 return arbitrary_module_poly(f, mod);
431 }
432
433 arbitrary_module_poly arbitrary_module_poly::operator>>=(const std::size_t &b){
434 return *this = (*this) >> b;
435 }
436
437 arbitrary_module_poly arbitrary_module_poly::inv(void)const{
438 int N = 1; while(N < (int)(size() + size() ‐ 1)) N <<= 1;
439 arbitrary_module_poly f(1, mod), g(N, mod), h(*this), f2(1, mod);
440 f[0] = qpow(data[0], mod ‐ 2, mod), h.resize(N), f2[0] = 2;
441 for(int w = 2; w < N; w <<= 1){
442 g.resize(w);
443 for(int i = 0; i < w; ++i) g[i] = h[i];
444 f = f * (f * g ‐ f2) * (mod ‐ 1);
445 f.resize(w);
446 }
447 f.resize(size());
448 return f;
449 }
450
451 arbitrary_module_poly arbitrary_module_poly::inv(const int &h)const{
452 arbitrary_module_poly f(*this);
453 f.resize(h);
454 return f.inv();
455 }
456
457 arbitrary_module_poly arbitrary_module_poly::operator/(const int &h)const{
458 int inv = qpow(h, mod ‐ 2, mod);
459 std::vector<int> f(this‐>data);
460 for(int i = 0; i < (int)f.size(); ++i) f[i] = (ll)f[i] * inv % mod;
461 return arbitrary_module_poly(f, mod);
462 }
463
464 arbitrary_module_poly arbitrary_module_poly::operator/=(const int &h){
465 int inv = qpow(h, mod ‐ 2, mod);
466 for(int i = 0; i < (int)size(); ++i) data[i] = (ll)data[i] * inv % mod;
467 return *this;
468 }
469
470 arbitrary_module_poly arbitrary_module_poly::operator==(const arbitrary_module_poly &h)const{
471 if(size() != h.size() || mod != h.mod) return 0;
472 for(int i = 0; i < (int)size(); ++i) if(data[i] != h[i]) return 0;
473 return 1;
474 }
475
476 arbitrary_module_poly arbitrary_module_poly::operator!=(const arbitrary_module_poly &h)const{
477 if(size() != h.size() || mod != h.mod) return 1;
478 for(int i = 0; i < (int)size(); ++i) if(data[i] != h[i]) return 1;
479 return 0;
480 }
481
482 arbitrary_module_poly sqrt(const arbitrary_module_poly &h){
483 int N = 1; while(N < (int)(h.size() + h.size() ‐ 1)) N <<= 1;
484 arbitrary_module_poly f(1, mod), g(N, mod), d(h);
485 f[0] = modsqrt(h[0], mod), d.resize(N);
486 for(int w = 2; w < N; w <<= 1){
487 g.resize(w);
488 for(int i = 0; i < w; ++i) g[i] = d[i];
489 f = (f + f.inv(w) * g) / 2;
490 f.resize(w);
491 }
492 f.resize(h.size());
493 return f;
494 }
495
496 arbitrary_module_poly log(const arbitrary_module_poly &h){
Nanchang university ACM template 第 141 页
497 arbitrary_module_poly f(h);
498 for(int i = 1; i < (int)f.size(); ++i) f[i ‐ 1] = (ll)f[i] * i % f.mod;
499 f[f.size() ‐ 1] = 0, f = f * h.inv(), f.resize(h.size());
500 for(int i = (int)f.size() ‐ 1; i > 0; ‐‐i) f[i] = (ll)f[i ‐ 1] * qpow(i, f.mod ‐ 2, f.mod) % f.mod;
501 f[0] = 0;
502 return f;
503 }
504 typedef arbitrary_module_poly m_poly;
505 }
506
507 #endif
508 using namespace fstdlib;
509 int n;
510 const int maxn = 1e6;
511 int fact[maxn];
512 int ifact[maxn];
513 typedef long long ll;
514 int main() {
515 scanf("%d", &n);
516 fact[0] = 1;
517 for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i ‐ 1] * i % mod;
518 exgcd(fact[n], mod, ifact[n], ifact[0]),
519 ifact[n] = (ifact[n] % mod + mod) % mod;
520 for (int i = n ‐ 1; i >= 0; ‐‐i) ifact[i] = (ll)ifact[i + 1] * (i + 1) % mod;
521 poly f(n + 1), g(n + 1);
522 for (int i = 0; i <= n; ++i)
523 g[i] = (i & 1 ? mod ‐ 1ll : 1ll) * ifact[i] % mod,
524 f[i] = (ll)qpow(i, n) * ifact[i] % mod;
525 f *= g, f.resize(n + 1);
526 for (int i = 0; i <= n; ++i) printf("%d ", f[i]);
527 return 0;
528 }
6.10.4 康托展开
6.10.4.1 八数码.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：八数码.cpp
4 * 创建日期：2021年11月25日 星期四 11时27分52秒 5 * 题 目：AcWing 0179 八数码 6 * 算 法：BFS + cantor 也可以使用astar，代码在 搜索 ‐> A* 7 * 描 述：将输入的一个八数码通过移动 x 来转换为初始八数码 8 * 9 * 1 2 3 1 2 3
10 * x 4 6 ‐> 4 5 6
11 * 7 5 8 7 8 x
12 *
13 * u : 向上
14 * d : 向下
15 * l : 向左
16 * r : 向右
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <unordered_map>
22 #include <queue>
23 #include <cstring>
24 #include <algorithm>
25 using namespace std;
26 int grid[10], over[10], n = 9;
27 int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; // 阶乘
28 const int dx[] = {0, ‐1, 0, 1};
29 const int dy[] = {‐1, 0, 1, 0};
30 // const char conv[] = "lurd";
31 const char conv[] = "rdlu";
32 unordered_map<int, int> used;
33 // 从 pre.second.first 到 pre.first 的变换是 pre.second.second
Nanchang university ACM template 第 142 页
34 unordered_map<int, pair<int, char>> pre;
35 #define NEXTLINE puts("");
36 #define bug puts("<‐‐>");
37
38 /*
39 * n 个数，这个 str 不是字符串类型，而是一个数组
40 * 里面是 0 ‐ 8 这 9 个数
41 * 康托展开公式：res = a[n] * (n ‐ 1)! + a[n ‐ 1] * (n ‐ 2)! + ... + a[1] * 0!;
42 * 这里的 a[i] 表示的是第 i 个位置上的数在 i 后面的数中排第几
43 */
44 int Contor(int* sequ, int n) {
45 int res = 0;
46 for (int i = 0; i < n; ++ i) {
47 int cnt = 0;
48 for (int j = i + 1; j < n; ++ j)
49 if (sequ[i] > sequ[j])
50 cnt ++ ;
51 res += cnt * fact[n ‐ i ‐ 1];
52 }
53 return res + 1;
54 }
55
56 // 只能返回 [1, n] 的排列，也容易转换为指定的集合
57 int* revContor(int ranking, int n) {
58 ranking = ranking ‐ 1; // 有 ranking ‐ 1 个排列比目标序列要小
59 bool used[10];
60 static int permutation[10];
61 memset(used, false, sizeof used);
62 memset(permutation, ‐1, sizeof permutation);
63
64 for (int i = 0; i < n; ++ i) {
65 int r = ranking / fact[n ‐ i ‐ 1];
66 ranking = ranking % fact[n ‐ i ‐ 1];
67
68 for (int j = 1; j <= n; ++ j)
69 if (!used[j] && !(r ‐‐ )) {
70 used[j] = true;
71 permutation[i] = j;
72 break;
73 }
74 }
75 // sequ 排个序
76 // 如果 permutaion[i] = 1，需要指定集合的话，就输出 sequ[permutation[i] ‐ 1];
77 return permutation;
78 }
79
80 bool BFS(int rankbegin, int rankover) {
81 queue<int> q;
82 q.push(rankbegin); // 初始的 Contor 值存入队列中
83 used[rankbegin] ++ ;
84 while (q.size()) {
85 int t = q.front(); q.pop(); // 队顶的 Contor 值
86 if (t == rankover)
87 return true;
88 int *g = revContor(t, n);
89 int x, y, idx;
90 for (int i = 0; i < 9; ++ i)
91 if (g[i] == 9) {
92 idx = i;
93 // 从 0 开始
94 x = i / 3;
95 y = i % 3;
96 // printf("‐‐ %d %d %d\n", i, x, y);
97 }
98 /*
99 * for (int i = 0; i < 9; ++ i) {
100 * printf("%d ", g[i]);
101 * if (i == 2 || i == 5 || i == 8)
102 * NEXTLINE;
103 * }
Nanchang university ACM template 第 143 页
104 */
105 for (int i = 0; i < 4; ++ i) {
106 int nx = x + dx[i],
107 ny = y + dy[i];
108 if (nx < 0 || nx >= 3 || ny < 0 || ny >= 3)
109 continue;
110 int newidx = nx * 3 + ny;
111 swap(g[idx], g[newidx]);
112 int ranking = Contor(g, n);
113 swap(g[idx], g[newidx]);
114 if (used.count(ranking))
115 continue;
116 // printf("‐‐ %d %d %d\n", newidx, nx, ny);
117 q.push(ranking);
118 pre[ranking] = {t, char(conv[i])};
119 used[ranking] ++ ;
120 }
121 // NEXTLINE;
122 }
123 return false;
124 }
125
126 int main() {
127 #ifndef ONLINE_JUDGE
128 freopen("in.txt", "r", stdin);
129 freopen("out.txt", "w", stdout);
130 #endif
131 for (int i = 0; i < 9; ++ i) {
132 char ch[2]; scanf("%s", ch);
133 grid[i] = *ch == 'x' ? 9 : (int)(*ch ‐ '0');
134 }
135 for (int i = 0; i < 9; ++ i)
136 over[i] = i + 1;
137 int rankover = Contor(over, n); // 结束时的 Contor
138 int rankbegin = Contor(grid, n); // 初始的 Contor
139 if (BFS(rankover, rankbegin)) {
140 while (rankbegin != rankover) {
141 char ch = pre[rankbegin].second;
142 printf("%c", ch);
143 rankbegin = pre[rankbegin].first;
144 }
145 NEXTLINE;
146 }
147 else
148 puts("unsolvable");
149 return 0;
150 }
6.10.4.2 康托展开-vector.cpp
1 #include <cstdio>
2 #include <vector>
3 using namespace std;
4 #define NEXTLINE puts("");
5 const int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
67 int Contor(const vector<int>& permutation) {
8 int num = 0;
9 int len = permutation.size();
10 for (int i = 0; i < len; ++ i) {
11 int cnt = 0;
12 for (int j = i + 1; j < len; ++ j)
13 if (permutation[i] > permutation[j])
14 cnt ++ ;
15 num += cnt * fact[len ‐ i ‐ 1];
16 }
17 return num + 1;
18 }
19
Nanchang university ACM template 第 144 页
20 vector<int> revContor(int ranking, int n) {
21 ranking = ranking ‐ 1; // 有 ranking ‐ 1 个排列比目标序列要小
22 vector<bool> used(n + 1, false);
23 vector<int> permutation(n, ‐1);
24
25 for (int i = 0; i < n; ++ i) {
26 int r = ranking / (fact[n ‐ i ‐ 1]);
27 ranking = ranking % (fact[n ‐ i ‐ 1]);
28
29 for (int j = 1; j <= n; ++ j)
30 if (!used[j] && !(r ‐‐ )) {
31 used[j] = true;
32 permutation[i] = j;
33 break;
34 }
35 }
36 // sequ 排个序
37 // 如果 permutaion[i] = 1，需要指定集合的话，就输出 sequ[permutation[i] ‐ 1];
38 return permutation;
39 }
40
41 int main() {
42 vector<int> vec;
43 int n; scanf("%d", &n);
44 for (int i = 0; i < n; ++ i) {
45 int _; scanf("%d", &_);
46 vec.push_back(_);
47 }
48 int ranking = Contor(vec);
49 printf("%d\n", ranking);
50
51 vector<int> res = revContor(ranking, n);
52 for (auto i : res)
53 printf("%d ", i);
54 NEXTLINE;
55 return 0;
56 }
6.10.4.3 康托展开数组.cpp
1 #include <cstdio>
2 #include <cstring>
3 #include <vector>
4 using namespace std;
5 const int maxn = 10;
6 #define NEXTLINE puts("");
7 int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; // 阶乘 89 /*
10 * 返回长度为 n 的这个序列在这 n 个数的全排列中是第几位
11 * 1, 2, 3, 4, 5, ..., n 是第一位
12 * n, n ‐ 1, ..., 3, 2, 1 是最后一位，也是第 A_n^n 位
13 * 康托展开公式：res = a[n] * (n ‐ 1)! + a[n ‐ 1] * (n ‐ 2)! + ... + a[1] * 0!;
14 * 这里的 a[i] 表示的是第 i 个位置上的数在 i 后面的数中排第几
15 */
16 int Contor(int* sequ, int n) {
17 int res = 0;
18 for (int i = 0; i < n; ++ i) {
19 int cnt = 0;
20 for (int j = i + 1; j < n; ++ j)
21 if (sequ[i] > sequ[j])
22 cnt ++ ;
23 res += cnt * fact[n ‐ i ‐ 1];
24 }
25 return res + 1;
26 }
27
28 // 只能返回 [1, n] 的排列，也容易转换为指定的集合
29 int* revContor(int ranking, int n) {
Nanchang university ACM template 第 145 页
30 ranking = ranking ‐ 1; // 有 ranking ‐ 1 个排列比目标序列要小
31 bool used[maxn];
32 static int permutation[maxn];
33 memset(used, false, sizeof used);
34 memset(permutation, ‐1, sizeof permutation);
35
36 for (int i = 0; i < n; ++ i) {
37 int r = ranking / fact[n ‐ i ‐ 1];
38 ranking = ranking % fact[n ‐ i ‐ 1];
39
40 for (int j = 1; j <= n; ++ j)
41 if (!used[j] && !(r ‐‐ )) {
42 used[j] = true;
43 permutation[i] = j;
44 break;
45 }
46 }
47 // sequ 排个序
48 // 如果 permutaion[i] = 1，需要指定集合的话，就输出 sequ[permutation[i] ‐ 1];
49 return permutation;
50 }
51
52 int main() {
53 int a[maxn], n;
54 scanf("%d", &n);
55 for (int i = 0; i < n; ++ i)
56 scanf("%d", &a[i]);
57 int ranking = Contor(a, n);
58 printf("%d\n", ranking);
59 int *rank_sequ;
60 rank_sequ = revContor(ranking, n);
61 for (int i = 0; i < n; ++ i)
62 printf("%d ", rank_sequ[i]);
63 NEXTLINE;
64 return 0;
65 }
6.10.5 容斥原理
6.10.5.1 能被整除的数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：能被整除的数.cpp
4 * 创建日期：2021年10月14日 星期四 17时55分02秒 5 * 题 目：AcWing 0890 能被整除的数 6 * 算 法：容斥原理 7 * 描 述：给定一个整数 n 和 m 个不同的质数 p1, p2, ..., pm
8 * 求[1, n]中能被 p1, p2, ..., pm 中至少一个数整除的整数有多少个 9 * 1 <= m <= 16
10 * 1 <= n, pi <= 1e9
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 const int maxn = 20;
16 int p[maxn];
17 typedef long long ll;
18
19 int main() {
20 int n, m;
21 scanf("%d %d", &n, &m);
22 for (int i = 0; i < m; ++ i)
23 scanf("%d", &p[i]);
24 int res = 0;
25 // inclusion‐exclusion principle
26 // 使用二进制的方式枚举每种选法
27 for (int i = 1; i < 1 << m; ++ i) {
28 // t: 所有质数的乘积
29 // cnt: 这个二进制数中位为1的个数
Nanchang university ACM template 第 146 页
30 int t = 1, cnt = 0;
31 for (int j = 0; j < m; ++ j)
32 if (i >> j & 1) {
33 cnt ++ ;
34 if ((ll)t * p[j] > n) {
35 t = ‐1;
36 break;
37 }
38 t *= p[j];
39 }
40 if (t != ‐1) {
41 if (cnt % 2)
42 res += n / t;
43 else
44 res ‐= n / t;
45 }
46 }
47 printf("%d\n", res);
48 return 0;
49 }
6.11 斐波那契数列
6.11.1 Fibonacci.c
1 #include <stdio.h>
23 int Fibonacci(int n) {
4 if (n == 1 || n == 0)
5 return 1;
6 else
7 return Fibonacci(n ‐ 1) + Fibonacci(n ‐ 2);
8 } 9
10 int main() {
11 //n的值再高可能递归太深，出不来
12 int n = 41;
13 printf("%d\n", Fibonacci(n));
14 return 0;
15 }
6.11.2 Fibonacci.cpp
1 #include <cstdio>
2 #include <cmath>
3 #include <vector>
4 using namespace std;
56 template<typename T>
7 T Fibo0(T n) {
8 if (n <= 1) return 1;
9 else return Fibo(n‐1) + Fibo(n‐2);
10 }
11
12 template<typename T>
13 T Fibo1(T n) {
14 if (n <= 1) return 1;
15
16 std::vector<int> table(n + 1);
17 table[0] = table[1] = 1;
18 for (int i = 2; i <= n; ++i)
19 table[i] = table[i‐1] + table[i‐2];
20 return table.back();
21 }
22
23 template<typename T>
24 T Fibo2(T n) {
Nanchang university ACM template 第 147 页
25 const double sqrt5 = std::sqrt(5);
26 const double phi = (1 + sqrt5) / 2;
27 return (T)(std::pow(phi, n+1) / sqrt5 + 0.5);
28 }
29
30 template<typename T>
31 T Fibo3(T n) {
32 static std::vector<T> arr;
33 if (n <= 1) return 1;
34 else if (n >= (T)arr.size())
35 arr.resize(n+1);
36
37 if (!arr[n])
38 arr[n] = Fibo3(n‐1) + Fibo3(n‐2);
39 return arr[n];
40 }
41
42 int main() {
43 for (int i = 0; i < 10; ++i)
44 printf("%d ", Fibo1(i));
45
46 printf("\n");
47 for (int i = 0; i < 10; ++i)
48 printf("%d ", Fibo2(i));
49
50 printf("\n");
51 for (int i = 0; i < 10; ++i)
52 printf("%d ", Fibo3(i));
53
54 printf("\n");
55 return 0;
56 }
6.12 博弈论
6.12.1 Bash-Game-sg.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Bash‐Game‐sg.cpp
4 * 创建日期：2021年03月19日 ‐‐‐‐ 10时17分 5 * 题 目：hdu1846
6 * 算 法：sg函数 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 const int maxn = 1005;
14 int n; //石子数量
15 int m; //一次最多可拿多少石子
16 int sg[maxn];
17 int st[maxn]; //后继结点
18
19 void SG() {
20 memset(sg, 0, sizeof(sg));
21 for (int i = 1; i <= n; ++i) {
22 memset(st, 0, sizeof(st));
23 for (int j = 1; j <= m && i‐j >= 0; ++j)
24 st[sg[i‐j]] = 1; //把i的后继结点(i‐1, i‐2, i‐3, ... , i‐j)放到集合st中
25 for (int j = 0; j <= n; ++j) //计算sg[i]
26 if (!st[j]) {
27 sg[i] = j;
28 break;
29 }
30 }
31 }
32
Nanchang university ACM template 第 148 页
33 int main() {
34 int c;
35 scanf("%d", &c);
36 while (c‐‐) {
37 scanf("%d %d", &n, &m);
38 SG();
39 /*sg != 0 先手胜；sg == 0 后手胜*/
40 /*if sg != 0 胜*/
41 sg[n] ? printf("first\n") : printf("second\n");
42 }
43 return 0;
44 }
6.12.2 Nim-Game-sg.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐Nim‐Game‐sg.cpp
4 * 创建日期：2021年03月19日 ‐‐‐‐ 14时46分 5 * 题 目：hdu1848
6 * 算 法：sg函数 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 const int maxn = 1005;
14 int sg[maxn];
15 int st[maxn];
16 int fibo[15] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987};
17
18 /*预计算每堆有0~1005石子时的sg函数*/
19 void SG() {
20 for (int i = 0; i <= maxn; ++i) {
21 sg[i] = i;
22 memset(st, 0, sizeof(st));
23 for (int j = 0; j < 15 && fibo[j] <= i; ++j) {
24 st[sg[i‐fibo[j]]] = 1; //把i的后继结点(i‐fibo[1], i‐fibo[2], ... , i‐fibo[j])放到集合st中
25 for (int j = 0; j <= i; ++j)
26 if (!st[j]) {
27 sg[i] = j;
28 break;
29 }
30 }
31 }
32 }
33
34 int main() {
35 SG();
36 int n, m, p;
37 while (scanf("%d %d %d", &n, &m, &p) && n + m + p) {
38 if (sg[n] ^ sg[m] ^ sg[p])
39 printf("Fibo\n");
40 else
41 printf("Nacci\n");
42 }
43 return 0;
44 }
6.12.3 wythoff-Game.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：03‐wythoff‐Game.cpp
4 * 创建日期：2021年03月19日 ‐‐‐‐ 14时59分 5 * 题 目：hdu1527
Nanchang university ACM template 第 149 页 6 * 算 法：博弈论 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cmath>
13 #include <algorithm>
14 using namespace std;
15 double gold = (1 + sqrt(5)) / 2; //黄金分割 = 1.61803398...
16
17 int main() {
18 int n, m;
19 while (scanf("%d %d", &n, &m)) {
20 int mini = min(n, m);
21 int maxi = max(n, m);
22 double k = double(maxi ‐ mini);
23 int test = (int)(k * gold); //乘以黄金分割数，然后取整
24 /*test == mini 先手败*/
25 test == mini ? printf("0\n") : printf("1\n");
26 }
27 return 0;
28 }
6.12.4 Nim 游戏.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Nim游戏.cpp
4 * 创建日期：2021年10月15日 星期五 00时10分07秒 5 * 题 目：AcWing 0891 Nim游戏 6 * 算 法：博弈论 7 * 描 述： 给定 n 堆石子，两位玩家轮流操作，每次操作可以从 8 * 任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），
9 * 最后无法进行操作的人视为失败。
10 * 问如果两人都采用最优策略，先手是否必胜。
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 int main() {
16 int n; scanf("%d", &n);
17 int res = 0;
18 while (n ‐‐ ) {
19 int _;
20 scanf("%d", &_);
21 res ^= _;
22 }
23 if (res)
24 puts("Yes");
25 else
26 puts("No");
27 return 0;
28 }
6.12.5 Nim 游戏.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：台阶‐Nim游戏.cpp
4 * 创建日期：2021年10月15日 星期五 00时24分32秒 5 * 题 目：AcWing 0892 台阶‐Nim游戏 6 * 算 法：博弈论 7 * 描 述：只看奇数台阶石子，就是经典的Nim游戏 8 * 对手拿偶数台阶的石子，那就把刚才拿下的石子再往下拿，
9 * 保证奇数台阶的石子数不变
10 * 对手拿奇数台阶石子，那就也拿奇数台阶石子，使之异或为零
Nanchang university ACM template 第 150 页
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 int main() {
16 int n; scanf("%d", &n);
17 int idx = 1;
18 int res = 0;
19 while (n ‐‐ ) {
20 int _; scanf("%d", &_);
21 if (idx & 1)
22 res ^= _;
23 idx ++ ;
24 }
25 if (res)
26 puts("Yes");
27 else
28 puts("No");
29 return 0;
30 }
6.12.6 Nim 游戏.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：拆分‐Nim游戏.cpp
4 * 创建日期：2021年10月15日 星期五 21时42分41秒 5 * 题 目：AcWing 0894 拆分‐Nim游戏 6 * 算 法：博弈论 sg函数 7 * 描 述：
8 * 给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子 9 * 然后放入两堆规模更小的石子（新堆规模可以为 0
10 * 且两个新堆的石子总数可以大于取走的那堆石子数）
11 * 最后无法进行操作的人视为失败。
12 * 问如果两人都采用最优策略，先手是否必胜。
13 *
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
15
16 #include <cstdio>
17 #include <cstring>
18 #include <unordered_set>
19 using namespace std;
20 const int maxn = 100 + 5;
21 int f[maxn];
22
23 int sg(int x) {
24 if (f[x] != ‐1)
25 return f[x];
26 unordered_set<int> S;
27 // 分成两堆
28 for (int i = 0; i < x; ++ i)
29 for (int j = 0; j <= i; ++ j)
30 S.insert(sg(i) ^ sg(j));
31 // mex
32 for (int i = 0; ; ++ i)
33 if (S.count(i) == 0)
34 return f[x] = i;
35 }
36
37 int main() {
38 memset(f, ‐1, sizeof f);
39 int n; scanf("%d", &n);
40 int res = 0;
41 for (int i = 0; i < n; ++ i) {
42 int _; scanf("%d", &_);
43 res ^= sg(_);
44 }
45 if (res == 0)
46 puts("No");
Nanchang university ACM template 第 151 页
47 else
48 puts("Yes");
49 return 0;
50 }
6.12.7 Nim 游戏-sg 函数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：集合‐Nim游戏‐sg函数.cpp
4 * 创建日期：2021年10月15日 星期五 12时47分50秒 5 * 题 目：AcWing 0893 集合‐Nim游戏 6 * 算 法：博弈论 sg函数 7 * 描 述：
8 * 给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。 9 * 现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，
10 * 每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。
11 * 问如果两人都采用最优策略，先手是否必胜。
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 #include <cstring>
17 #include <unordered_set>
18 using namespace std;
19 const int maxn = 105, maxm = 1e4 + 5;
20 int n, m;
21 int s[maxn];
22 int used[maxm];
23
24 int sg(int x) {
25 if (used[x] != ‐1)
26 return used[x];
27 // 哈希表存储所有能到的局面
28 unordered_set<int> S;
29 for (int i = 0; i < m; ++ i) {
30 int sum = s[i];
31 if (x >= sum)
32 S.insert(sg(x ‐ sum));
33 }
34 for (int i = 0; ; ++ i)
35 if (!S.count(i))
36 return used[x] = i;
37 }
38
39 int main() {
40 // 集合 S 中的数的个数
41 scanf("%d", &m);
42 for (int i = 0; i < m; ++ i)
43 scanf("%d", &s[i]);
44 memset(used, ‐1, sizeof used);
45 scanf("%d", &n);
46 int res = 0;
47 for (int i = 0; i < n; ++ i) {
48 int x; scanf("%d", &x);
49 res ^= sg(x);
50 }
51 if (res == 0)
52 puts("No");
53 else
54 puts("Yes");
55 return 0;
56 }
Nanchang university ACM template 第 152 页 7 数据结构
7.1 栈
7.1.1 模拟栈.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年07月28日 星期三 21时51分40秒 5 * 题 目：AcWing 0828 模拟栈 6 * 算 法：栈 7 * 描 述：<++>
8 * 实现一个栈，栈初始为空，支持四种操作：
9 * ‐ push x – 向栈顶插入一个数 x；
10 * ‐ pop – 从栈顶弹出一个数；
11 * ‐ empty – 判断栈是否为空；
12 * ‐ query – 查询栈顶元素。
13 *
14 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
15
16 #include <cstdio>
17 #include <cstring>
18 const int maxn = 1e5 + 5;
19 int stk[maxn], tt = 0;
20
21 // 插入：stk[++tt] = x;
22 // 弹出：stk[tt‐‐] = x;
23 // 为什么stk[0]这个位置不用呢？把它留着作为边界，或者在stk[0]这个位置放一个特殊的值
24
25 int main() {
26 int t; scanf("%d", &t);
27 char op[10];
28 while (t‐‐) {
29 scanf("%s", op);
30 if (!strcmp(op, "push")) {
31 int x; scanf("%d", &x);
32 stk[++tt] = x;
33 }
34 else if (!strcmp(op, "pop")) {
35 tt‐‐;
36 }
37 else if (!strcmp(op, "empty")) {
38 printf(tt ? "NO\n" : "YES\n");
39 }
40 else if (!strcmp(op, "query")) {
41 printf("%d\n", stk[tt]);
42 }
43 }
44 return 0;
45 }
7.1.2 表达式求值.cpp
1 #include <cstdio>
2 #include <stack>
3 #include <string>
4 #include <algorithm>
5 #include <cctype>
6 #include <iostream>
7 #include <unordered_map>
8 using namespace std;
9
10 stack<int> num;
11 stack<char> op;
12
13 void eval() {
14 auto b = num.top(); num.pop();
15 auto a = num.top(); num.pop();
Nanchang university ACM template 第 153 页
16 auto c = op.top(); op.pop();
17 int x;
18 if (c == '+') x = a + b;
19 else if (c == '‐') x = a ‐ b;
20 else if (c == '*') x = a * b;
21 else x = a / b;
22 num.push(x);
23 }
24
25 int main() {
26 unordered_map<char, int> pr{{'+', 1}, {'‐', 1}, {'*', 2}, {'/', 2}};
27 string str;
28 cin >> str;
29 for (int i = 0; i < (int)str.length(); ++i) {
30 auto c = str[i];
31 if (isdigit(c)) {
32 int x = 0, j = i;
33 while (j < str.size() && isdigit(str[j]))
34 x = x * 10 + str[j++] ‐ '0';
35 i = j ‐ 1;
36 num.push(x);
37 }
38 else if (c == '(')
39 op.push(c);
40 else if (c == ')') {
41 while (op.top() != '(')
42 eval();
43 op.pop();
44 }
45 else {
46 while (op.size() && pr[op.top()] >= pr[c])
47 eval();
48 op.push(c);
49 }
50 }
51 while (op.size())
52 eval();
53 cout << num.top();
54 return 0;
55 }
7.2 队列
7.2.1 模拟队列.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年07月29日 星期四 00时24分27秒 5 * 题 目：AcWing 0829 模拟队列 6 * 算 法：队列 7 * 描 述：
8 * 栈可能会出现边界问题，所以可能在栈底放一个特殊元素 9 * 而队列不会出现这样的边界
10 * 为了使这两个数据结构插入元素时都使用++tt，所以队列的tt初始为‐1
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <cstring>
16 const int maxn = 1e5 + 5;
17 int q[maxn], hh = 0, tt = ‐1;
18
19 // 插入：q[++tt] = x;
20 // 弹出：hh++;
21
22 int main() {
23 int t; scanf("%d", &t);
24 char op[10];
Nanchang university ACM template 第 154 页
25 while (t‐‐) {
26 scanf("%s", &op);
27 if (!strcmp(op, "push")) {
28 int x; scanf("%d", &x);
29 q[ ++ tt] = x;
30 }
31 else if (!strcmp(op, "pop")) {
32 hh ++ ;
33 }
34 else if (!strcmp(op, "empty")) {
35 // if (hh <= tt) 不为空
36 printf(hh > tt ? "YES\n" : "NO\n");
37 }
38 else if (!strcmp(op, "query")) {
39 printf("%d\n", q[hh]);
40 }
41 }
42 return 0;
43 }
7.3 链表 + 邻接表
7.3.1 双链表.cpp
7.3.2 邻接表.cpp
7.3.3 链式前向星.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：04‐邻接表.cpp
4 * 创建日期：2021年04月14日 ‐‐‐‐ 16时30分 5 * 题 目：算法竞赛 6 * 算 法：邻接表 7 * 描 述：这种的邻接表和一般的邻接表不一样，这个是按输入的倒序 8 * 存储的 9 * 如果从h[x]开始搜索，得到的是最后一次加入到链表x的边tot
10 * ve[tot]，ed[tot]存储的是与x相连的节点和权值，然后进行操作
11 * i = ne[i]，此时i是x结点上一次添加的边，所以是倒序打印
12 *
13 * !一定要有memset(h, ‐1, sizeof h)，因为你的tot是从0开始的
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <cstring>
19 const int maxn = 1e5 + 5;
20 int ve[maxn], ed[maxn], ne[maxn], h[maxn];
21 int tot;
22
23 //加入有向边(x, y)，权值为z
24 void add(int x, int y, int z) {
25 ve[tot] = y;
26 ed[tot] = z;
27 ne[tot] = h[x];
28 h[x] = tot++;
29 }
30
31 int main() {
32 // freopen("in.txt", "r", stdin);
33 int n, m;
34 memset(h, ‐1, sizeof h); // 这条链表的最后一个是‐1
35 scanf("%d %d", &n, &m);
36 for (int i = 0; i < m; ++i) {
Nanchang university ACM template 第 155 页
37 int x, y, z;
38 scanf("%d %d %d", &x, &y, &z);
39 add(x, y, z);
40 }
41 printf("<‐‐>\n");
42 for (int x = 1; x <= n; ++x)
43 //访问从x出发的所有边
44 for (int i = h[x]; i != ‐1; i = ne[i]) {
45 int y = ve[i];
46 int z = ed[i];
47 printf("%d %d %d\n", x, y, z);
48 }
49 return 0;
50 }
51 /*
52 6 7
53 4 3 1
54 4 6 1
55 3 6 1
56 3 2 1
57 1 2 1
58 6 1 1
59 6 5 1
60 */
7.3.4 单链表.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年07月26日 星期一 22时02分51秒 5 * 题 目：Acwing 0826 单链表 6 * 算 法：单链表 7 * 描 述：因为数组下标是从0开始的，所以下标是k‐1的数是第k个插入的 8 * 实现一个单链表，链表初始为空，支持三种操作：
9 * ‐ 向链表头插入一个数；
10 * ‐ 删除第 k 个插入的数后面的数；
11 * ‐ 在第 k 个插入的数后插入一个数。
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 1e5 + 5;
17
18 // head是头指针的下标
19 int head, e[maxn], ne[maxn];
20 // 也是相当于一个指针，一开始这个链表是空的，如果要往里面新建结点，就需要知道哪个结点是空的，idx指向的位置就是空的位
置，将idx位置的结点填入数据之后，将idx向后移动一位，继续指向一个空的结点
21 int idx;
22
23 void init() {
24 head = ‐1; idx = 0;
25 }
26
27 /**
28 * head ‐> node1 ‐> node2 ‐> ... ‐> nodek
29 * ^
30 * | 要在这里插入一个结点(头结点处，头插法)
31 */
32 void add_to_head(int x) {
33 e[idx] = x;
34 ne[idx] = head;
35 head = idx;
36 idx++;
37 }
38
39 /**
40 * head ‐> node1 ‐> node2 ‐> ... ‐> nodek ‐> ...
41 * ^
Nanchang university ACM template 第 156 页
42 * 在下标是k的结点后面插入一个结点 |
43 *
44 * 错了，不是上面这个操作，图画错了，不是第k个结点后面，是数组下标为k的后面
45 * 没错，仔细体会，因为idx只有递增且每次加一，数组下标为k的结点就是第k个插入的
46 */
47 void add(int k, int x) {
48 e[idx] = x;
49 ne[idx] = ne[k];
50 ne[k] = idx;
51 idx++;
52 }
53
54 // 将下标为k的点后面的点删除
55 // 这里没有特判头节点删除的情况，题目中要是出现了remove(head)，需要在代码中判断
56 void remove(int k) {
57 ne[k] = ne[ne[k]];
58 }
59
60 int main() {
61 init();
62 int m; scanf("%d", &m);
63 while (m‐‐) {
64 getchar();
65 char ch; scanf("%c", &ch);
66 int x, k;
67 if (ch == 'H') {
68 scanf("%d", &x);
69 add_to_head(x);
70 }
71 else if (ch == 'D') {
72 scanf("%d", &k);
73 if (k == 0) {
74 head = ne[head];
75 continue;
76 }
77 remove(k ‐ 1);
78 }
79 else if (ch == 'I') {
80 scanf("%d %d", &k, &x);
81 add(k ‐ 1, x);
82 }
83 }
84 int i = head;
85 while (i != ‐1) {
86 printf("%d ", e[i]);
87 i = ne[i];
88 }
89 return 0;
90 }
7.4 堆
7.4.1 二叉堆
7.4.1.1 对顶堆.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：对顶堆.cpp
4 * 创建日期：2021年06月02日 星期三 22时21分50秒 5 * 题 目：AcWing 0106 动态中位数 6 * 算 法：对顶堆 7 * 描 述：维护一个动态中位数 8 * 一般堆用he(heap)表示，大根堆用hE表示 9 * 哈希用ha(hash)表示
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <queue>
Nanchang university ACM template 第 157 页
15 #include <vector>
16 using namespace std;
17 #define NEXTLINE puts("");
18
19 int main() {
20 // t组数，m是各组编号，n是各组数据个数
21 int t, m, n;
22 scanf("%d", &t);
23 while (t‐‐) {
24 priority_queue<int> hE; // hE为大根堆
25 priority_queue<int, vector<int>, greater<int>> he; // he为小根堆
26 scanf("%d %d", &m, &n);
27 printf("%d %d\n", m, (n + 1) / 2);
28 int cnt = 0;
29 for (int i = 1; i <= n; ++i) {
30 int _;
31 scanf("%d", &_);
32 he.push(_);
33 if (hE.size() && hE.top() > he.top()) {
34 int a = he.top(),
35 b = hE.top();
36 he.pop(), hE.pop();
37 he.push(b), hE.push(a);
38 }
39 while (he.size() > hE.size()) {
40 hE.push(he.top());
41 he.pop();
42 }
43 if (i & 1)//奇数
44 printf("%d%c", hE.top(), ++cnt % 10 == 0 ? '\n' : ' ');//每10个数换一行
45 }
46 if (cnt % 10)
47 NEXTLINE
48 }
49 return 0;
50 }
7.4.1.2 模拟堆.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：模拟堆.cpp
4 * 创建日期：2021年08月09日 星期一 10时41分38秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：从1开始，树的基本知识 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 // h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
12 // ph[k]存储第k个插入的点在堆中的位置
13 // hp[k]存储堆中下标是k的点是第几个插入的
14 #include <cstdio>
15 #include <cstring>
16 #include <algorithm>
17 using namespace std;
18 const int maxn = 1e5 + 5;
19 int he[maxn], tot, idx;
20 int ph[maxn], hp[maxn];
21
22 void heap_swap(int a, int b) {
23 swap(ph[hp[a]], ph[hp[b]]);
24 swap(hp[a], hp[b]);
25 swap(he[a], he[b]);
26 }
27
28 void down(int u) {
29 int minidx = u;
30 if (u * 2 <= tot && he[u * 2] < he[minidx])
Nanchang university ACM template 第 158 页
31 minidx = u * 2;
32 if (u * 2 + 1 <= tot && he[u * 2 + 1] < he[minidx])
33 minidx = u * 2 + 1;
34 if (u != minidx) {
35 heap_swap(u, minidx);
36 down(minidx);
37 }
38 }
39
40 void up(int u) {
41 while (u / 2 && he[u / 2] > he[u]) {
42 heap_swap(u / 2, u);
43 u /= 2;
44 }
45 }
46
47 int main() {
48 int n; scanf("%d", &n);
49 while (n‐‐) {
50 char op[10];
51 int k, x;
52 scanf("%s", op);
53 if (!strcmp(op, "I")) { // 插入一个数
54 scanf("%d", &x);
55 tot ++ ;
56 idx ++ ;
57 ph[idx] = tot, hp[tot] = idx;
58 he[tot] = x;
59 up(tot);
60 }
61 else if (!strcmp(op, "PM")) // 输出当前集合最小值
62 printf("%d\n", he[1]);
63 else if (!strcmp(op, "DM")) { // 删除当前集合最小值
64 heap_swap(1, tot);
65 tot‐‐;
66 down(1);
67 }
68 else if (!strcmp(op, "D")) { // 删除第k个插入的数
69 scanf("%d", &k);
70 k = ph[k];
71 heap_swap(k, tot);
72 tot‐‐;
73 down(k), up(k);
74 }
75 else {
76 scanf("%d %d", &k, &x); // 修改第k个插入的数，将其变为x
77 k = ph[k];
78 he[k] = x;
79 down(k), up(k);
80 }
81 }
82 return 0;
83 }
7.5 并查集
7.5.1 合并集合.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月08日 星期日 17时48分14秒 5 * 题 目：AcWing 0836 合并集合 6 * 算 法：并茶集 7 * 描 述：路径压缩，按秩合并代码比这个长，而且效率低 8 * M a b，将编号为 a 和 b 的两个数所在的集合合并 9 * Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中
10 *
11 * 0 <= n, m <= 1e5
Nanchang university ACM template 第 159 页
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 1e5 + 5;
17 int n, m;
18 int fa[maxn];
19
20 // 返回x的祖宗结点 + 路径压缩
21 int find(int x) {
22 if (fa[x] == x)
23 return x;
24 return fa[x] = find(fa[x]);
25 }
26
27 int main() {
28 scanf("%d %d", &n, &m);
29 for (int i = 1; i <= n; ++i) // 灯笼的init()函数，根据题目要求选择从下标1开始还是0开始
30 fa[i] = i;
31 while (m‐‐) {
32 char op[2];
33 int a, b;
34 scanf("%s %d %d", op, &a, &b);
35 if (op[0] == 'M')
36 fa[find(a)] = find(b); // 灯笼的union_vert()函数，给a的祖宗认个爹
37 else if (op[0] == 'Q') {
38 if (find(a) == find(b))
39 puts("Yes");
40 else
41 puts("No");
42 }
43 }
44 return 0;
45 }
7.5.2 食物链.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02.cpp
4 * 创建日期：2021年08月08日 星期日 21时21分15秒 5 * 题 目：AcWing 0240 食物链 6 * 算 法：并查集 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 5e4 + 5;
13 int fa[maxn]; // 父节点
14 int d[maxn]; // 距离根节点的距离
15
16 // 并查集查询操作，维护一个d数组
17 int find(int x) {
18 if (fa[x] != x) {
19 int u = find(fa[x]);
20 d[x] += d[fa[x]];
21 fa[x] = u;
22 }
23 return fa[x];
24 }
25
26 int main() {
27 int n, m;
28 scanf("%d %d", &n, &m);
29 for (int i = 1; i <= n; ++i)
30 fa[i] = i;
31 int res = 0;
32 while (m‐‐) {
Nanchang university ACM template 第 160 页
33 int s, x, y;
34 scanf("%d %d %d", &s, &x, &y);
35 if (x > n || y > n)
36 res++;
37 else {
38 int rootx = find(x), rooty = find(y);
39 if (s == 1) {
40 if (rootx == rooty && (d[x] ‐ d[y]) % 3) // 说明都已经在集合中
41 res++;
42 else if (rootx != rooty) {
43 fa[rootx] = rooty;
44 d[rootx] = d[y] ‐ d[x];
45 }
46 }
47 else {
48 if (rootx == rooty && (d[x] ‐ d[y] ‐ 1) % 3)
49 res++;
50 else if (rootx != rooty) {
51 fa[rootx] = rooty;
52 d[rootx] = d[y] + 1 ‐ d[x];
53 }
54 }
55 }
56 }
57 printf("%d\n", res);
58 return 0;
59 }
7.6 数状数组
7.6.1 一个简单的整数问题.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：一个简单的整数问题.cpp
4 * 创建日期：2021年11月16日 星期二 16时34分00秒 5 * 题 目：AcWing 0242 一个简单的整数问题 6 * 算 法：树状数组 7 * 描 述：长度为 n 的数组，m 个指令 8 * ‐ C l r d [l, r] 中的数都加上 d 9 * ‐ Q x 查询第 x 个数的值
10 *
11 * 区间修改，单点查询
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 1e5 + 5;
17 int n, m;
18 int a[maxn];
19 typedef long long ll;
20 ll tr[maxn]; // 实际上是差分数组
21 #define lowbit(x) ((x) & ‐(x))
22
23 void add(int x, int c) {
24 for (int i = x; i <= n; i += lowbit(i))
25 tr[i] += c;
26 }
27
28 ll sum(int x) {
29 ll res = 0;
30 for (int i = x; i; i ‐= lowbit(i))
31 res += tr[i];
32 return res;
33 }
34
35 int main() {
36 scanf("%d %d", &n, &m);
37 for (int i = 1; i <= n; ++ i)
Nanchang university ACM template 第 161 页
38 scanf("%d", &a[i]);
39 // 就是直接的初始化，在第i个位置放上(a[i] ‐ a[i ‐ 1]);
40 // 是建树的过程
41 for (int i = 1; i <= n; ++ i)
42 add(i, a[i] ‐ a[i ‐ 1]);
43 while (m ‐‐ ) {
44 char op[2];
45 int l;
46 scanf("%s %d", op, &l);
47 if (*op == 'C') {
48 int r, d;
49 scanf("%d %d", &r, &d);
50 add(l, d);
51 if (r + 1 <= n)
52 add(r + 1, ‐d);
53 }
54 else if (*op == 'Q') {
55 int x = l;
56 printf("%lld\n", sum(x));
57 }
58 }
59 return 0;
60 }
7.6.2 一个简单的整数问题 2.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年10月05日 星期二 21时58分37秒 5 * 题 目：AcWing 0243 一个简单的整数问题 6 * 算 法：线段树 7 * 描 述：
8 * 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：
9 * ‐ C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。
10 * ‐ Q l r，表示询问数列中第 l￾ r 个数的和。
11 * 对于每个询问，输出一个整数表示答案。
12 *
13 * ‐ 区间最大连续子段和 区间和
14 * ‐ 最大数 区间最大数
15 * ‐ 区间最大公约数 区间加
16 * ‐ 本题 区间加 + 区间和
17 * ‐ 区间加 ‐‐‐> 差分
18 *
19 * 差分 diff[i]
20 *
21 * 第i个数 arr[i] = diff[1] + diff[2] + ... + diff[i]
22 *
23 * 前x项的和 sum = arr[1] + arr[2] + ... + arr[i]
24 *
25 * arr1 = diff1
26 * arr2 = diff1 diff2
27 * arr3 = diff1 diff2 diff3
28 * ... = ...
29 * arrx = diff1 diff2 diff3 ... diffx
30 *
31 * |
32 * V
33 *
34 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
35 * | diff1 diff2 diff3 ... diffx | ‐> 这个矩形的左下三角形区域为所求
36 * |‐‐‐‐‐‐‐| |
37 * arr1 ‐> | diff1 | diff2 diff3 ... diffx |
38 * | |‐‐‐‐‐‐‐| |
39 * arr2 ‐> | diff1 diff2 | diff3 ... diffx |
40 * | |‐‐‐‐‐‐‐| |
41 * arr3 ‐> | diff1 diff2 diff3 | ... diffx |
42 * | ... |
43 * | ... |
Nanchang university ACM template 第 162 页
44 * | ... |
45 * | diff1 diff2 diff3 ... | diffx |
46 * | |‐‐‐‐‐‐‐|
47 * arrx ‐> | diff1 diff2 diff3 ... diffx |
48 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
49 *
50 * 也就是说，整个矩形区域减去右上三角形区域为所求
51 *
52 * (diff1 + diff2 + ... diffx) * (x + 1) ‐ (1*diff1 + 2*diff2 + ... x*diffx)
53 *
54 * 所以使用线段树维护一个差分 diffi 的前缀和
55 * 和一个 i * diffi 的前缀和
56 *
57 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
58
59 #include <cstdio>
60 int n, m;
61 const int maxn = 1e5 + 5;
62 int arr[maxn];
63 typedef long long ll;
64 ll tr1[maxn]; // 维护 diff[i] 的前缀和
65 ll tr2[maxn]; // 维护 diff[i] * i 的前缀和
66
67 int lowbit(int x) {
68 return x & ‐x;
69 }
70
71 void add(ll tr[], int x, ll c) {
72 for (int i = x; i <= n; i += lowbit(i))
73 tr[i] += c;
74 }
75
76 ll sum(ll tr[], int x) {
77 ll res = 0;
78 for (int i = x; i; i ‐= lowbit(i))
79 res += tr[i];
80 return res;
81 }
82
83 ll get_preS(int x) {
84 return sum(tr1, x) * (x + 1) ‐ sum(tr2, x);
85 }
86
87 int main() {
88 scanf("%d %d", &n, &m);
89 for (int i = 1; i <= n; ++ i)
90 scanf("%d", &arr[i]);
91 for (int i = 1; i <= n; ++ i) {
92 int diff = arr[i] ‐ arr[i ‐ 1];
93 add(tr1, i, diff);
94 add(tr2, i, (ll)diff * i);
95 }
96 while (m ‐‐ ) {
97 char op[2];
98 int l, r, d;
99 scanf("%s", op);
100 scanf("%d %d", &l, &r);
101 if (*op == 'C') {
102 scanf("%d", &d);
103 // arr[l] += d;
104 add(tr1, l, d), add(tr2, l, l * d);
105 // arr[r + 1] ‐= d;
106 add(tr1, r + 1, ‐d), add(tr2, r + 1, (r + 1) * ‐d);
107 }
108 else if (*op == 'Q') {
109 printf("%lld\n", get_preS(r) ‐ get_preS(l ‐ 1));
110 }
111 }
112 return 0;
113 }
Nanchang university ACM template 第 163 页
7.6.3 楼兰图腾.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：楼兰图腾.cpp
4 * 创建日期：2021年11月16日 星期二 13时46分47秒 5 * 题 目：AcWing 0241 楼兰图腾 6 * 算 法：树状数组 7 * 描 述：坐标轴上有 n 个点，
8 * v : (i, yi), (j, yj), (k, yk) 满足 1 <= i < j < k <= n 且 yi > yj, yj < yk
9 * ^ : (i, yi), (j, yj), (k, yk) 满足 1 <= i < j < k <= n 且 yi < yj, yj > yk
10 *
11 * 求出有多少个 v 和 ^
12 *
13 * [y1, yn] 是 [1, n] 的一个排列
14 *
15 * 实际上就是单点修改，区间查询
16 *
17 * a[x] += c
18 * query(l, r);
19 *
20 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
21
22 #include <cstdio>
23 #include <cstring>
24 const int maxn = 2e5 + 5;
25 int n, y[maxn], tr[maxn];
26 #define lowbit(x) ((x) & ‐(x))
27 typedef long long ll;
28
29 // 在位置 x 上加上 c
30 void add(int x, int c) {
31 for (int i = x; i <= n; i += lowbit(i))
32 tr[i] += c;
33 }
34
35 // 返回 x 的前缀和
36 int sum(int x) {
37 int res = 0;
38 for (int i = x; i; i ‐= lowbit(i))
39 res += tr[i];
40 return res;
41 }
42
43 // 在 [i] 的位置左边，有多少个数大于 y[i]
44 int greater[maxn], lower[maxn];
45
46 int main() {
47 scanf("%d", &n);
48 for (int i = 1; i <= n; ++ i)
49 scanf("%d", &y[i]);
50 for (int i = 1; i <= n; ++ i) {
51 greater[i] = sum(n) ‐ sum(y[i]);
52 lower[i] = sum(y[i] ‐ 1);
53 add(y[i], 1);
54 }
55 memset(tr, 0, sizeof tr);
56 ll res1 = 0, res2 = 0;
57 for (int i = n; i; ‐‐ i) {
58 res1 += greater[i] * (ll)(sum(n) ‐ sum(y[i]));
59 res2 += lower[i] * (ll)(sum(y[i] ‐ 1));
60 add(y[i], 1);
61 }
62 printf("%lld %lld\n", res1, res2);
63 return 0;
64 }
Nanchang university ACM template 第 164 页
7.6.4 迷一样的牛.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：迷一样的牛.cpp
4 * 创建日期：2021年11月16日 星期二 17时09分21秒 5 * 题 目：AcWing 0244 迷一样的牛 6 * 算 法：树状数组 7 * 描 述：n 头牛站成一列，输入的第一个数是牛的个数，下面 n ‐ 1 8 * 行数代表的是第 i + 1 头牛前面有多少个比它矮的牛的个数，输出身高 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 const int maxn = 1e5 + 5;
14 int n, h[maxn], res[maxn], tr[maxn];
15 #define lowbit(x) ((x) & ‐(x))
16
17 void add(int x, int c) {
18 for (int i = x; i <= n; i += lowbit(i))
19 tr[i] += c;
20 }
21
22 int sum(int x) {
23 int res = 0;
24 for (int i = x; i; i ‐= lowbit(i))
25 res += tr[i];
26 return res;
27 }
28
29 int main() {
30 scanf("%d", &n);
31 for (int i = 1; i <= n; ++ i) {
32 tr[i] = lowbit(i); // add(i, 1);
33 if (i != 1)
34 scanf("%d", &h[i]);
35 }
36 for (int i = n; i; ‐‐ i) {
37 int k = h[i] + 1;
38 int l = 1, r = n;
39 while (l < r) {
40 int mid = l + r >> 1;
41 if (sum(mid) < k)
42 l = mid + 1;
43 else
44 r = mid;
45 }
46 res[i] = l;
47 add(l, ‐1);
48 }
49 for (int i = 1; i <= n; ++ i)
50 printf("%d\n", res[i]);
51 return 0;
52 }
7.7 单调栈
7.7.1 直方图中最大矩形.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年07月31日 星期六 13时54分56秒 5 * 题 目：luogu SP1805 HISTOGRA ‐ LARGEST Rectangle in a Histogram
6 * 算 法：单调栈 7 * 描 述：Luogu题解 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
Nanchang university ACM template 第 165 页
11 #include <cstdio>
12 #include <cstring>
13 #include <cmath>
14 #include <algorithm>
15 typedef long long ll;
16 using namespace std;
17 const int maxn = 1e5 + 5;
18 int n, tt;
19 ll res;
20 // 直方体中矩形的高度，直方体中矩形的宽度
21 int a[maxn], width[maxn];
22 int stk[maxn];
23
24 int main() {
25 while(scanf("%d", &n) && n) {
26 res = 0; tt = 0;
27
28 for (int i = 1; i <= n; i++)
29 scanf("%d", &a[i]);
30 a[n+1] = 0;
31
32 for (int i = 1; i <= n+1; i++) {
33 if (a[i] > stk[tt]) {
34 stk[++tt] = a[i];
35 width[tt] = 1;
36 }
37 else {
38 int cnt = 0;
39 while (stk[tt] > a[i]) {
40 cnt += width[tt];
41 res = max(res, (ll)cnt * stk[tt]);
42 tt‐‐;
43 }
44 stk[++tt] = a[i];
45 width[tt] = cnt + 1;
46 }
47
48 }
49 printf("%lld\n", res);
50 }
51 return 0;
52 }
7.8 单调队列
7.8.1 最大子序列和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐最大子序列和.cpp
4 * 创建日期：2021年04月08日 ‐‐‐‐ 21时02分 5 * 题 目：ch1201
6 * 算 法：单调队列 7 * 描 述：给定一个长度为N的整数序列(可能有负数)，从中找出一段 8 * 长度不超过M的连续子序列，使得所有子序列中所有数的和最大 9 *
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 3e5 + 5;
17 int sum[maxn];
18 int quu[maxn];
19 int head = 0;
20 int tail = 0;
21 int res;
22
Nanchang university ACM template 第 166 页
23 int main() {
24 // freopen("in.txt", "r", stdin);
25 int n, m;
26 scanf("%d %d", &n, &m);
27 for (int i = 0; i < n; ++i) {
28 scanf("%d", &sum[i]);
29 if (i)
30 sum[i] += sum[i‐1];
31 }
32 for (int i = 0; i < n; ++i) {
33 while (head <= tail && i‐quu[i] > m) //超出M的范围
34 ++head;
35 res = max(res, sum[i] ‐ sum[quu[head]]);
36 //为了保证队列单调，要使quu[tail]的位置的前缀和小于sum[i]才行
37 while (head <= tail && sum[i] <= sum[quu[tail]])
38 ‐‐tail;
39 quu[++tail] = i;
40 }
41 printf("%d\n", res);
42 return 0;
43 }
7.8.2 滑动窗口.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年08月06日 星期五 20时19分44秒 5 * 题 目：AcWing 0154 滑动窗口 6 * 算 法：单调队列 7 * 描 述：给定一个1e6大小的数组，有一个大小为k的滑动窗口，它从 8 * 数组的最左边移动到最右边，输出窗口移动过程中的最大值与最小值 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 const int maxn = 1e6 + 5;
14 #define NEXTLINE puts("");
15 int quu[maxn], a[maxn];
16 int n, k;
17
18 void get_min() {
19 int hh = 0, tt = ‐1;
20 for (int i = 0; i < n; ++i) {
21 if (hh <= tt && quu[hh] < i ‐ k + 1) // 超出窗口范围
22 hh++;
23 // 队列中一定是单调递增的，前面的比后面大，那就会删去前面的
24 while (hh <= tt && a[quu[tt]] >= a[i])
25 tt‐‐;
26 quu[++tt] = i;
27 if (i >= k ‐ 1)
28 printf("%d ", a[quu[hh]]);
29 }
30 }
31
32 void get_max() {
33 int hh = 0, tt = ‐1;
34 for (int i = 0; i < n; ++i) {
35 if (hh <= tt && quu[hh] < i ‐ k + 1)
36 hh++;
37 while (hh <= tt && a[quu[tt]] <= a[i])
38 tt‐‐;
39 quu[++tt] = i;
40 if (i >= k ‐ 1)
41 printf("%d ", a[quu[hh]]);
42 }
43 }
44
45 int main() {
Nanchang university ACM template 第 167 页
46 scanf("%d %d", &n, &k); // n个数，窗口大小为k
47 for (int i = 0; i < n; ++i)
48 scanf("%d", &a[i]);
49
50 get_min();
51 NEXTLINE
52 get_max();
53 return 0;
54 }
7.9 线段树
7.9.1 模板
7.9.1.1 Segment-Tree(灯笼).cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Segment_Tree.cpp
4 * 创建日期：2021年04月23日 ‐‐‐‐ 21时06分 5 * 题 目：<++>
6 * 算 法：线段树 7 * 描 述：线段树结点中没有存储区间，但由于build, update, query
8 * 操作的参数都包含了start与end，所以相当于存储了区间 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 using namespace std;
14 const int maxn = 1000;
15 int arr[] = {1, 3, 5, 7, 9, 11};
16 int tree[maxn];
17 int n = 6; //数组中元素的个数
18
19 // build(0, 0, n‐1)，从根节点开始建树，从arr数组的start到end，node是树的结点
20 void build(int node, int start, int end) {
21 if (start == end)
22 tree[node] = arr[start];
23 else {
24 int mid = (start + end) / 2;
25 int left_node = 2 * node + 1;
26 int right_node = 2 * node + 2;
27
28 build(left_node, start, mid);
29 build(right_node, mid+1, end);
30
31 tree[node] = tree[left_node] + tree[right_node];
32 }
33 }
34
35 // update(0, 0, n‐1, idx, val)，arr[idx] = val
36 void update(int node, int start, int end, int idx, int val) {
37 if (start == end) {
38 arr[idx] = val;
39 tree[node] = val;
40 }
41 else {
42 int mid = (start + end) / 2;
43 int left_node = 2 * node + 1;
44 int right_node = 2 * node + 2;
45
46 if (idx <= mid)
47 update(left_node, start, mid, idx, val);
48 else
49 update(right_node, mid+1, end, idx, val);
50
51 tree[node] = tree[left_node] + tree[right_node];
52 }
53 }
54
Nanchang university ACM template 第 168 页
55 // query(0, 0, n‐1, L, R)，求arr[L], arr[L+1], ... arr[R]之间的和
56 int query(int node, int start, int end, int L, int R) {
57 printf("start = %d\n", start);
58 printf("end = %d\n", end);
59
60 if (R < start || L > end)
61 return 0;
62 else if (L <= start && R >= end)
63 return tree[node];
64 else if (start == end)
65 return tree[node];
66 else {
67 int mid = (start + end) / 2;
68 int left_node = 2 * node + 1;
69 int right_node = 2 * node + 2;
70 int sum_left = query(left_node, start, mid, L, R);
71 int sum_right = query(right_node, mid+1, end, L, R);
72 return sum_left + sum_right;
73 }
74 }
75
76 int main() {
77 build(0, 0, n‐1);
78 for (int i = 0; i <= 2*n+2; ++i)
79 printf("tree[%d] = %d\n", i, tree[i]);
80 printf("\n");
81
82 update(0, 0, n‐1, 4, 6);
83 for (int i = 0; i <= 2*n+2; ++i)
84 printf("tree[%d] = %d\n", i, tree[i]);
85 printf("\n");
86
87 int s = query(0, 0, n‐1, 2, 5);
88 printf("%d\n", s);
89 return 0;
90 }
7.9.1.2 区间修改.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：0058‐一个简单的整数问题.cpp
4 * 创建日期：2021年11月11日 星期四 13时28分11秒 5 * 题 目：AcWing 0243 一个简单的整数问题2 6 * 算 法：线段树 7 * 描 述：
8 * 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：
9 * ‐ C l r d，表示把 A[l], A[l+1], ..., A[r] 都加上 d。
10 * ‐ Q l r，表示询问数列中第 [l, r] 个数的和。
11 * 对于每个询问，输出一个整数表示答案。
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 1e5 + 5;
17 typedef long long ll;
18 int arr[maxn];
19
20 struct Node {
21 int l, r;
22 ll sum, add;
23 } tr[maxn * 4];
24
25 void pushup(int u) {
26 tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
27 }
28
29 void build(int u, int l, int r) {
30 if (l == r) {
Nanchang university ACM template 第 169 页
31 tr[u] = {l, r, arr[l], 0};
32 }
33 else {
34 tr[u].l = l, tr[u].r = r;
35 int mid = l + r >> 1;
36 build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
37 pushup(u);
38 }
39 }
40
41 void pushdown(int u) {
42 auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
43 if (root.add) {
44 left.add += root.add, left.sum += (ll)(left.r ‐ left.l + 1) * root.add;
45 right.add += root.add, right.sum += (ll)(right.r ‐ right.l + 1) * root.add;
46 root.add = 0;
47 }
48 }
49
50 void modify(int u, int l, int r, int d) {
51 if (l <= tr[u].l && tr[u].r <= r) {
52 tr[u].sum += (ll)(tr[u].r ‐ tr[u].l + 1) * d;
53 tr[u].add += d;
54 }
55 else {
56 pushdown(u);
57 int mid = tr[u].l + tr[u].r >> 1;
58 if (l <= mid)
59 modify(u << 1, l, r, d);
60 if (r > mid)
61 modify(u << 1 | 1, l, r, d);
62 pushup(u);
63 }
64 }
65
66 ll query(int u, int l, int r) {
67 if (l <= tr[u].l && tr[u].r <= r) {
68 return tr[u].sum;
69 }
70 else {
71 pushdown(u);
72 int mid = tr[u].l + tr[u].r >> 1;
73 ll sum = 0;
74 if (l <= mid)
75 sum += query(u << 1, l, r);
76 if (r > mid)
77 sum += query(u << 1 | 1, l, r);
78 return sum;
79 }
80 }
81
82 int main() {
83 int n, m;
84 scanf("%d %d", &n, &m);
85 for (int i = 1; i <= n; ++ i)
86 scanf("%d", &arr[i]);
87 build(1, 1, n);
88 while (m ‐‐ ) {
89 char op[2];
90 int l, r;
91 scanf("%s %d %d", op, &l, &r);
92 if (*op == 'C') {
93 int d; scanf("%d", &d);
94 modify(1, l, r, d);
95 }
96 else if (*op == 'Q') {
97 printf("%lld\n", query(1, l, r));
98 }
99 }
100 return 0;
Nanchang university ACM template 第 170 页
101 }
7.9.1.3 单点修改.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：最大数.cpp
4 * 创建日期：2021年09月24日 星期五 14时00分56秒 5 * 结束日期：2021年09月24日 星期五 23时00分19秒 6 * 题 目：AcWing 1257 最大数 7 * 算 法：线段树 8 * 描 述：给定一个正整数数列a1, a2, ..., an，每一个数都在 9 * 0 ~ p ‐ 1 之间，两种操作：
10 * 1. 添加操作：序列后添加一个数，序列长度变成n + 1
11 * 2. 询问操作：询问这个序列最后L个数中最大的数是多少
12 * 线段树，动态的修改一个数，动态的查询一个区间内的最大数
13 *
14 * 一共有 m 次操作
15 *
16 * ! 线段树的区间都是左闭右闭
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <algorithm>
22 using namespace std;
23 const int maxn = 2e5 + 5;
24
25 struct Node {
26 int l, r;
27 int maxi; // 本题存储的是区间[l, r]最大值
28 } tr[maxn * 4];
29
30 // 由子结点的信息计算父结点的信息
31 void pushup(int u) {
32 tr[u].maxi = max(tr[u << 1].maxi, tr[u << 1 | 1].maxi);
33 }
34
35 // 这里的u是l, r的一个表示，也就是每一个u一一映射一个区间
36 // 这棵树的所有叶子是原数组
37 // 左闭右闭
38 void build(int u, int l, int r) {
39 tr[u] = {l, r};
40 if (l == r) // 叶结点
41 return;
42 int mid = l + r >> 1;
43 build(u << 1, l, mid);
44 build(u << 1 | 1, mid + 1, r);
45 }
46
47 // 从u结点开始查询，一般从根结点开始查询，查询[l, r]之间的最大值
48 // 这个函数的作用是找到既在结点u管理的区域又在在[l, r]区域中的最大值
49 // 左闭右闭
50 int query(int u, int l, int r) {
51 // 要查询的区间把这个结点所管理的区间包含了，那就返回这个结点的最大值
52 if (l <= tr[u].l && tr[u].r <= r)
53 return tr[u].maxi;
54 // 否则这个结点管理的一部分区域不在[l, r]中
55 int mid = tr[u].l + tr[u].r >> 1;
56 int maxi = 0;
57 /*
58 * l (先判断左边，右边r无所谓)
59 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
60 * tr[u].l mid tr[u].r
61 *
62 */
63 if (l <= mid)
64 maxi = query(u << 1, l, r);
65 /*
Nanchang university ACM template 第 171 页
66 * r (这是判断右边，左边l无所谓)
67 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
68 * tr[u].l mid tr[u].r
69 *
70 */
71 if (r > mid)
72 maxi = max(maxi, query(u << 1 | 1, l, r));
73 return maxi;
74 }
75
76 // update，左闭右闭
77 void modify(int u, int idx, int val) {
78 // 这是叶子，所以是数组中的数
79 // 是数组还不行，需要tr[u].l == idx才表明找到了这个下标的数
80 if (tr[u].l == tr[u].r && tr[u].l == idx)
81 tr[u].maxi = val;
82 else { // 所以当前结点不是叶子结点，就需要判断往左还是往右递归
83 int mid = tr[u].l + tr[u].r >> 1;
84 if (idx <= mid)
85 modify(u << 1, idx, val);
86 else
87 modify(u << 1 | 1, idx, val);
88 pushup(u);
89 }
90 }
91
92 int main() {
93 int m, MOD;
94 scanf("%d %d", &m, &MOD);
95 build(1, 1, m);
96 // idx是数的个数，last是上一个区间的答案
97 int idx = 0, last = 0;
98 while (m ‐‐ ) {
99 char op[2]; int x;
100 scanf("%s %d", op, &x);
101 if (*op == 'Q') { // Query
102 last = query(1, idx ‐ x + 1, idx);
103 printf("%d\n", last);
104 }
105 else if (*op == 'A') { // Append
106 modify(1, ++ idx, ((long long)x + last) % MOD);
107 }
108 }
109 return 0;
110 }
7.9.2 进阶
7.9.2.1 区间乘-区间加.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间乘.cpp
4 * 创建日期：2021年11月10日 星期三 19时17分03秒 5 * 题 目：AcWing 1277 维护序列 6 * 算 法：线段树 7 * 描 述：有长为 n 的数列 a1, a2, a3, ... an
8 * 一共有 m 个操作 9 * 操作1：1 l r c，把 [l, r] 中的数 ai * c
10 * 操作2：2 l r c, 把 [l, r] 中的数 ai + c
11 * 操作3：3 l r, 询问所有 [l, r] 中的数的和模 MOD 的值
12 *
13 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
14
15 #include <cstdio>
16 const int maxn = 1e5 + 5;
17 int n, m, MOD;
18 typedef long long ll;
19 int arr[maxn];
20
Nanchang university ACM template 第 172 页
21 struct Node {
22 int l, r;
23 int sum , add, mul;
24 } tr[maxn * 4];
25
26 void pushup(int u) {
27 tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % MOD;
28 }
29
30 void eval(Node &u, int mul, int add) {
31 u.sum = ((ll)u.sum * mul + (ll)(u.r ‐ u.l + 1) * add) % MOD;
32 u.mul = (ll)u.mul * mul % MOD;
33 u.add = ((ll)u.add * mul + add) % MOD;
34 }
35
36 void pushdown(int u) {
37 eval(tr[u << 1], tr[u].mul, tr[u].add);
38 eval(tr[u << 1 | 1], tr[u].mul, tr[u].add);
39 tr[u].add = 0, tr[u].mul = 1;
40 }
41
42 void build(int u, int l, int r) {
43 if (l == r)
44 tr[u] = {l, r, arr[r], 0, 1};
45 else {
46 tr[u] = {l, r, 0, 0, 1};
47 int mid = l + r >> 1;
48 build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
49 pushup(u);
50 }
51 }
52
53 void modify(int u, int l, int r, int add, int mul) {
54 if (l <= tr[u].l && tr[u].r <= r)
55 eval(tr[u], mul, add);
56 else {
57 pushdown(u);
58 int mid = tr[u].l + tr[u].r >> 1;
59 if (l <= mid)
60 modify(u << 1, l, r, add, mul);
61 if (r > mid)
62 modify(u << 1 | 1, l, r, add, mul);
63 pushup(u);
64 }
65 }
66
67 int query(int u, int l, int r) {
68 if (l <= tr[u].l && tr[u].r <= r)
69 return tr[u].sum;
70 pushdown(u);
71 int mid = tr[u].l + tr[u].r >> 1;
72 int sum = 0;
73 if (l <= mid)
74 sum = query(u << 1, l, r);
75 if (r > mid)
76 sum = (sum + query(u << 1 | 1, l, r)) % MOD;
77 return sum;
78 }
79
80 int main() {
81 scanf("%d %d", &n, &MOD);
82 for (int i = 1; i <= n; ++ i)
83 scanf("%d", &arr[i]);
84 build(1, 1, n);
85 scanf("%d", &m);
86 while (m ‐‐ ) {
87 int op, l, r;
88 scanf("%d %d %d", &op, &l, &r);
89 if (op == 1) {
90 int x; scanf("%d", &x);
Nanchang university ACM template 第 173 页
91 modify(1, l, r, 0, x);
92 }
93 else if (op == 2) {
94 int x; scanf("%d", &x);
95 modify(1, l, r, x, 1);
96 }
97 else
98 printf("%d\n", query(1, l, r));
99 }
100 return 0;
101 }
7.9.2.2 区间最大公约数.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间最大公约数.cpp
4 * 创建日期：2021年10月02日 星期六 03时15分36秒 5 * 题 目：AcWing 0246 区间最大公约数 6 * 算 法：线段树 7 * 描 述：
8 * C l r d，表示把[l, r]都加上 d。 9 * Q l r，表示询问[l, r]的最大公约数(GCD)。
10 * gcd(a1, a2, a3, ..., an) = gcd(a1, a2‐a1, a3‐a2, ..., an‐a(n‐1))
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <algorithm>
16 using namespace std;
17 typedef long long ll;
18 const int maxn = 5e5 + 5;
19 int n, m; // 初始数组个数，操作数
20 ll arr[maxn];
21
22 struct Node {
23 int l, r;
24 ll diff, gcd;
25 } tr[maxn * 4];
26
27 // gcd(a, b) = gcd(b, a mod b)
28 ll gcd(ll a, ll b) {
29 return b ? gcd(b, a % b) : a;
30 }
31
32 void pushup(Node &u, Node &l, Node &r) {
33 // 如果现在 u.l == 1，那么这个 u.diff 就是 arr[r];
34 // 为了让我们后面求 a[l] 方便
35 u.diff = l.diff + r.diff;
36 // 这里的 gcd 是 gcd(a2 ‐ a1, a3 ‐ a2, a4 ‐ a3, ... an ‐ a(n‐1))
37 u.gcd = gcd(l.gcd, r.gcd);
38 }
39
40 void pushup(int u) {
41 pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
42 }
43
44 void build(int u, int l, int r) {
45 if (l == r) {
46 ll dif = arr[r] ‐ arr[r ‐ 1];
47 tr[u] = {l, r, dif, dif};
48 }
49 else {
50 tr[u].l = l, tr[u].r = r;
51 int mid = l + r >> 1;
52 build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
53 pushup(u);
54 }
55 }
Nanchang university ACM template 第 174 页
56
57 void modify(int u, int idx, ll val) {
58 if (tr[u].l == idx && tr[u].r == idx) {
59 ll b = tr[u].diff + val;
60 tr[u] = {idx, idx, b, b};
61 }
62 else {
63 int mid = tr[u].l + tr[u].r >> 1;
64 if (idx <= mid)
65 modify(u << 1, idx, val);
66 else
67 modify(u << 1 | 1, idx, val);
68 pushup(u);
69 }
70 }
71
72 Node query(int u, int l, int r) {
73 if (l <= tr[u].l && tr[u].r <= r) {
74 return tr[u];
75 }
76 else {
77 int mid = tr[u].l + tr[u].r >> 1;
78 if (mid < l) {
79 return query(u << 1 | 1, l, r);
80 }
81 else if (r <= mid) {
82 return query(u << 1, l, r);
83 }
84 else {
85 auto left = query(u << 1, l, r),
86 right = query(u << 1 | 1, l, r);
87 Node res;
88 pushup(res, left, right);
89 return res;
90 }
91 }
92 }
93
94 int main() {
95 scanf("%d %d", &n, &m);
96 for (int i = 1; i <= n; ++ i)
97 scanf("%lld", &arr[i]);
98 build(1, 1, n);
99 while (m ‐‐ ) {
100 char op[2];
101 int l, r;
102 scanf("%s %d %d", op, &l, &r);
103 if (*op == 'C') {
104 ll x; scanf("%lld", &x);
105 modify(1, l, x);
106 if (r + 1 <= n)
107 modify(1, r + 1, ‐x);
108 }
109 else if (*op == 'Q') {
110 auto left = query(1, 1, l),
111 right = query(1, l + 1, r);
112 printf("%lld\n", abs(gcd(left.diff, right.gcd)));
113 }
114 }
115 return 0;
116 }
7.9.2.3 区间最大连续子段和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：区间最大连续子段和.cpp
4 * 创建日期：2021年10月02日 星期六 02时10分51秒 5 * 题 目：AcWing 0245 你能回答这些问题吗
Nanchang university ACM template 第 175 页 6 * 算 法：线段树 7 * 描 述：
8 * 开始给出数组 arr
9 * 1 x y 查询区间[x, y]的最大连续子段和
10 * 2 x y 把A[x] 修改为 y
11 *
12 *
13 * 这里的pushup操作的是三个结点
14 *
15 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
16
17 #include <cstdio>
18 #include <algorithm>
19 using namespace std;
20 const int maxn = 5e5 + 5;
21 int n, m;
22 int arr[maxn];
23 struct Node {
24 int l, r;
25 int sum; // 区间和
26 int lmax; // 区间的最大前缀和
27 int rmax; // 区间的最大后缀和
28 int maxi; // 区间的最大连续子序列和
29 } tr[maxn * 4];
30
31 void pushup(Node &u, Node &l, Node &r) {
32 u.sum = l.sum + r.sum;
33 u.lmax = max(l.lmax, l.sum + r.lmax);
34 u.rmax = max(r.rmax, r.sum + l.rmax);
35 // |‐‐‐‐‐‐‐‐‐| |‐‐‐‐‐‐‐‐‐|
36 // 新序列最大连续子序列可能跨区间
37 u.maxi = max(max(l.maxi, r.maxi), l.rmax + r.lmax);
38 }
39
40 void pushup(int u) {
41 pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
42 }
43
44 void build(int u, int l, int r) {
45 if (l == r)
46 tr[u] = {l, r, arr[r], arr[r], arr[r], arr[r]};
47 else {
48 tr[u].l = l, tr[u].r = r;
49 int mid = l + r >> 1;
50 build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
51 pushup(u);
52 }
53 }
54
55 void modify(int u, int x, int v) {
56 if (tr[u].l == x && tr[u].r == x)
57 tr[u] = {x, x, v, v, v, v};
58 else {
59 int mid = tr[u].l + tr[u].r >> 1;
60 if (x <= mid)
61 modify(u << 1, x, v);
62 else
63 modify(u << 1 | 1, x, v);
64 pushup(u);
65 }
66 }
67
68 Node query(int u, int l, int r) {
69 // tr[u] |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐|
70 // ^ l r ^
71 if (l <= tr[u].l && tr[u].r <= r)
72 return tr[u];
73 else {
74 int mid = tr[u].l + tr[u].r >> 1;
75 // |‐‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐‐|
Nanchang university ACM template 第 176 页
76 // <‐ ^ r
77 if (r <= mid)
78 return query(u << 1, l, r);
79 // |‐‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐‐|
80 // l ^ ‐>
81 else if (l > mid)
82 return query(u << 1 | 1, l, r);
83 // |‐‐‐‐‐‐‐‐‐‐‐‐|‐‐‐‐‐‐‐‐‐‐‐‐|
84 // ^ l r ^
85 else {
86 auto left = query(u << 1, l, r);
87 auto right = query(u << 1 | 1, l, r);
88 Node res;
89 pushup(res, left, right);
90 return res;
91 }
92 }
93 }
94
95 int main() {
96 scanf("%d %d", &n, &m);
97 // 线段树从1开始
98 for (int i = 1; i <= n; ++ i)
99 scanf("%d", &arr[i]);
100 build(1, 1, n);
101 while (m ‐‐) {
102 int k, x, y;
103 scanf("%d %d %d", &k, &x, &y);
104 if (k == 1) {
105 if (x > y) swap(x, y);
106 printf("%d\n", query(1, x, y).maxi);
107 }
108 else
109 modify(1, x, y);
110 }
111 return 0;
112 }
7.9.3 扫描线
7.9.3.1 扫描线.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：扫描线.cpp
4 * 创建日期：2021年11月10日 星期三 17时41分18秒 5 * 题 目：AcWing 0247 亚特兰蒂斯 6 * 算 法：扫描线 7 * 描 述：n个矩形，每个输入为 x1, y1, x2, y2，矩形左上，右下 8 * 坐标，输出总面积 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <vector>
14 #include <algorithm>
15 using namespace std;
16 const int maxn = 1e5 + 5;
17
18 struct Segment {
19 double x, y1, y2;
20 int k; // 权值 +1, ‐1
21 bool operator< (const Segment &a) const {
22 return x < a.x;
23 }
24 } seg[maxn * 2];
25
26 struct Node {
27 int l, r;
28 int cnt;
Nanchang university ACM template 第 177 页
29 double len;
30 } tr[maxn * 2 * 4];
31
32 vector<double> ys; // 对纵坐标离散化
33
34 // 离散化后通过这个函数找到位置
35 int find(double y) {
36 return lower_bound(ys.begin(), ys.end(), y) ‐ ys.begin();
37 }
38
39 void pushup(int u) {
40 if (tr[u].cnt)
41 tr[u].len = ys[tr[u].r + 1] ‐ ys[tr[u].l];
42 else if (tr[u].l != tr[u].r) {
43 tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
44 }
45 else
46 tr[u].len = 0;
47 }
48
49 void build(int u, int l, int r) {
50 tr[u] = {l, r, 0, 0};
51 if (l != r) {
52 int mid = l + r >> 1;
53 build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
54 }
55 }
56
57 void modify(int u, int l, int r, int k) {
58 if (l <= tr[u].l && tr[u].r <= r) {
59 tr[u].cnt += k;
60 pushup(u);
61 }
62 else {
63 int mid = tr[u].l + tr[u].r >> 1;
64 if (l <= mid)
65 modify(u << 1, l, r, k);
66 if (r > mid)
67 modify(u << 1 | 1, l, r, k);
68 pushup(u);
69 }
70 }
71
72 int main() {
73 int n, t = 1;
74 while (scanf("%d", &n), n) {
75 ys.clear();
76 for (int i = 0, idx = 0; i < n; ++ i) {
77 double x1, y1, x2, y2;
78 scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
79 seg[idx ++ ] = {x1, y1, y2, 1};
80 seg[idx ++ ] = {x2, y1, y2, ‐1};
81 ys.push_back(y1), ys.push_back(y2);
82 }
83 // 去重模板
84 sort(ys.begin(), ys.end());
85 ys.erase(unique(ys.begin(), ys.end()), ys.end());
86
87 build(1, 0, ys.size() ‐ 2);
88
89 sort(seg, seg + n * 2);
90 double res = 0;
91 for (int i = 0; i < n * 2; ++ i) {
92 if (i > 0) // 从第二条线开始加
93 res += tr[1].len * (seg[i].x ‐ seg[i ‐ 1].x);
94 modify(1, find(seg[i].y1), find(seg[i].y2) ‐ 1, seg[i].k);
95 }
96 printf("Test case #%d\n", t ++ );
97 printf("Total explored area: %.2lf\n\n", res);
98 }
Nanchang university ACM template 第 178 页
99 return 0;
100 }
7.10 二叉搜索树-平衡树
7.10.1 二叉搜索树简介
7.10.2 Treap
7.10.2.1 普通平衡树.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：普通平衡树.cpp
4 * 创建日期：2021年11月18日 星期四 11时16分53秒 5 * 题 目：AcWing 0253 普通平衡树 6 * 算 法：Treap
7 * 描 述：
8 * 维护一些数：
9 * 1. 插入一个数x
10 * 2. 删除数值x（若有多个相同的x，只删除一个）
11 * 3. 查询数值x的排名（若有多个相同的数，只输出最小的排名）
12 * 4. 查询排名为x的数值
13 * 5. 求数值x的前驱（前驱定义为小于x的最大的数）
14 * 6. 求数值x的后继（后继定义为大于x的最小的数）
15 *
16 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
17
18 #include <cstdio>
19 #include <algorithm>
20 using namespace std;
21 const int maxn = 1e5 + 5;
22 const int INF = 0x3f3f3f3f;
23
24 struct Node {
25 int l, r;
26 int key;
27 int val; // priority
28 int cnt; // 结点重复，使用一个结点表示cnt个权值相同的结点
29 int size; // 下面子树中有多少个结点，用于计算排名
30 } tr[maxn];
31
32 int root, idx; // 根结点和链表
33
34 void pushup(int p) {
35 tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
36 }
37
38 /** 右旋
39 * x y
40 * / \ / \
41 * y + ‐> ‐ x
42 * / \ / \
43 * ‐ z z +
44 */
45 void zig(int &p) {
46 int q = tr[p].l; // 也就是y
47 tr[p].l = tr[q].r, tr[q].r = p, p = q;
48 pushup(tr[p].r), pushup(p);
49 }
50
51 // 左旋
52 void zag(int &p) {
53 int q = tr[p].r;
54 tr[p].r = tr[q].l, tr[q].l = p, p = q;
55 pushup(tr[p].l), pushup(p);
56 }
57
58 int get_node(int key) {
59 tr[ ++ idx].key = key;
Nanchang university ACM template 第 179 页
60 tr[idx].val = rand();
61 tr[idx].cnt = tr[idx].size = 1;
62 return idx;
63 }
64
65 void build() {
66 // 初始化时需要两个哨兵
67 get_node(‐INF), get_node(INF);
68 // 手动创建
69 root = 1, tr[1].r = 2;
70 pushup(root);
71 if (tr[1].val < tr[2].val)
72 zag(root);
73 }
74
75 void insert(int &p, int key) {
76 if (!p)
77 p = get_node(key);
78 else if (key == tr[p].key)
79 tr[p].cnt ++ ;
80 else if (key < tr[p].key) {
81 insert(tr[p].l, key);
82 if (tr[tr[p].l].val > tr[p].val)
83 zig(p);
84 }
85 else {
86 insert(tr[p].r, key);
87 if (tr[tr[p].r].val > tr[p].val)
88 zag(p);
89 }
90 pushup(p);
91 }
92
93 void remove(int &p, int key) {
94 if (!p)
95 return;
96 if (key == tr[p].key) {
97 if (tr[p].cnt > 1)
98 tr[p].cnt ‐‐ ;
99 else if (tr[p].l || tr[p].r) {
100 if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val) {
101 zig(p);
102 remove(tr[p].r, key);
103 }
104 else {
105 zag(p);
106 remove(tr[p].l, key);
107 }
108 }
109 else
110 p = 0;
111 }
112 else if (key < tr[p].key)
113 remove(tr[p].l, key);
114 else
115 remove(tr[p].r, key);
116 pushup(p);
117 }
118
119 // 通过数值找排名
120 int get_rank_by_key(int p, int key) {
121 if (!p)
122 return 0;
123 if (tr[p].key == key)
124 return tr[tr[p].l].size + 1;
125 else if (key < tr[p].key) {
126 return get_rank_by_key(tr[p].l, key);
127 }
128 else {
129 return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
Nanchang university ACM template 第 180 页
130 }
131 }
132
133 // 通过排名找数值
134 int get_key_by_rank(int p, int rank) {
135 if (!p)
136 return INF;
137 if (tr[tr[p].l].size >= rank)
138 return get_key_by_rank(tr[p].l, rank);
139 else if (tr[tr[p].l].size + tr[p].cnt >= rank)
140 return tr[p].key;
141 else
142 return get_key_by_rank(tr[p].r, rank ‐ tr[tr[p].l].size ‐ tr[p].cnt);
143 }
144
145 // 前驱
146 int get_prev(int p, int key) {
147 if (!p)
148 return ‐INF;
149 if (key <= tr[p].key)
150 return get_prev(tr[p].l, key);
151 else
152 return max(tr[p].key, get_prev(tr[p].r, key));
153 }
154
155 // 后继
156 int get_next(int &p, int key) {
157 if (!p)
158 return INF;
159 if (key >= tr[p].key)
160 return get_next(tr[p].r, key);
161 else
162 return min(tr[p].key, get_next(tr[p].l, key));
163 }
164
165 int main() {
166 build();
167 int n; scanf("%d", &n);
168 while (n ‐‐ ) {
169 int opt, x;
170 scanf("%d %d", &opt, &x);
171 if (opt == 1) insert(root, x);
172 else if (opt == 2) remove(root, x);
173 else if (opt == 3) printf("%d\n", get_rank_by_key(root, x) ‐ 1);
174 else if (opt == 4) printf("%d\n", get_key_by_rank(root, x + 1));
175 else if (opt == 5) printf("%d\n", get_prev(root, x));
176 else if (opt == 6) printf("%d\n", get_next(root, x));
177 }
178 return 0;
179 }
7.11 可持久化数据结构
7.12 K-D-Tree
7.12.1 K-D-Tree.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐K‐D‐Tree.cpp
4 * 创建日期：2021年04月23日 ‐‐‐‐ 23时03分 5 * 题 目：luogu p1429 平面最近点对(加强版) 6 * 算 法：K‐D Tree
7 * 描 述：最近邻问题 8 * 给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所 9 * 有点对中，该距离为所有点对中最小的
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
Nanchang university ACM template 第 181 页
13 #include <cstdio>
14 #include <algorithm>
15 #include <cmath>
16 #include <queue>
17 using namespace std;
18 typedef long long ll;
19 const int maxn = 200010;
20 // const int inf = 0x3f3f3f3f;
21 #define bug printf("<‐‐>\n");
22 #define _max(a, b) (a > b ? a : b)
23 #define _min(a, b) (a < b ? a : b)
24 /*
25 * n个点；d数组表示将当前超长方体按什么维度分割的
26 * lc[i]表示这一小段以i为中位数分隔之后左侧的中位数(是坐标的中位数)
27 * rc[i]表示这一小段以i为中位数分隔之后右侧的中位数(是坐标的中位数)
28 * lc[i]表示结点i的左孩子
29 * rc[i]表示结点i的右孩子
30 */
31 int n, lc[maxn], rc[maxn];
32 bool opt;
33 double res = 2e18;
34 struct Point {double x, y;} p[maxn];
35 double L[maxn], R[maxn], D[maxn], U[maxn];
36
37 // double dist(int a, int b) {return hypot((p[a].x ‐ p[b].x), (p[a].y ‐ p[b].y));} //wrong
38 inline double dist(int a, int b) {return (p[a].x ‐ p[b].x)*(p[a].x ‐ p[b].x) + (p[a].y ‐ p[b].y)*(p[a].y ‐ p[
b].y);}
39 inline bool cmp(Point a, Point b) {return opt ? a.x < b.x : a.y < b.y;}
40
41 void maintain(int idx) { //维持，重构
42 L[idx] = R[idx] = p[idx].x;
43 D[idx] = U[idx] = p[idx].y;
44 if (lc[idx])
45 //L[idx]：当前结点与左孩子较小的横坐标，R[idx]：当前结点与左孩子较大的横坐标
46 L[idx] = min(L[idx], L[lc[idx]]), R[idx] = max(R[idx], R[lc[idx]]),
47 //D[idx]：当前结点与左孩子较小的纵坐标，U[idx]：当前结点与左孩子较大的纵坐标
48 D[idx] = min(D[idx], D[lc[idx]]), U[idx] = max(U[idx], U[lc[idx]]);
49 if (rc[idx])
50 //L[idx]：当前结点与右孩子较小的横坐标，R[idx]：当前结点与右孩子较大的横坐标
51 L[idx] = min(L[idx], L[rc[idx]]), R[idx] = max(R[idx], R[rc[idx]]),
52 //D[idx]：当前结点与右孩子较小的纵坐标，U[idx]：当前结点与右孩子较大的纵坐标
53 D[idx] = min(D[idx], D[rc[idx]]), U[idx] = max(U[idx], U[rc[idx]]);
54 }
55
56
57 void note() {
58 /*
59 * ^
60 * 10 | |
61 * 9 | |
62 * 8 | B |
63 * 7 | * | E
64 * 6 | |‐‐‐*‐‐‐‐‐
65 * 5 | C |
66 * 4 |‐‐‐‐‐‐‐‐‐*‐‐‐|
67 * 3 | * |
68 * 2 | A D *
69 * 1 | | * F
70 * |‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐>
71 * 0 1 2 3 4 5 6 7 8 9 10
72 *
73 *
74 * (7, 2) x
75 * / \
76 * / \
77 * y (5, 4) (9, 6) y
78 * / \ /
79 * / \ /
80 * (2, 3) (4, 7) (8, 1)
81 */
Nanchang university ACM template 第 182 页
82 }
83
84 /*如果在l到r这个区间里x维度的方差大，就返回true*/
85 bool va(int l, int r) {
86 double avx = 0, avy = 0, vax = 0, vay = 0; // average variance
87 for (int i = l; i < r; ++i)
88 avx += p[i].x, avy += p[i].y;
89 avx /= (double)(r ‐ l); //横坐标平均值
90 avy /= (double)(r ‐ l); //纵坐标平均值
91 for (int i = l; i < r; ++i)
92 vax += (p[i].x ‐ avx) * (p[i].x ‐ avx), // 方差(x) = vax / (r ‐ l + 1);
93 vay += (p[i].y ‐ avy) * (p[i].y ‐ avy); // 方差(y) = vay / (r ‐ l + 1);
94 return vax >= vay;
95 }
96
97 /*选择p[l]到p[r]的点建树，左闭右开*/
98 int build(int l, int r) {
99 if (l >= r) return 0;
100 int mid = (l + r) >> 1;
101 opt = va(l, r);
102 nth_element(p+l, p+mid, p+r, cmp); //d数组表示当前维度选择的分割的方向
103 lc[mid] = build(l, mid), rc[mid] = build(mid + 1, r); //左孩子，右孩子
104 maintain(mid);
105 return mid;
106 }
107
108 double f(int a, int b) {
109 double ret = 0;
110 //结点b与其左孩子中较小的横坐标大于结点a的横坐标，则加上横坐标二次方
111 if (L[b] > p[a].x) ret += (L[b] ‐ p[a].x) * (L[b] ‐ p[a].x);
112 //结点b与其左孩子中较大的横坐标小于结点a的横坐标，则加上横坐标二次方
113 if (R[b] < p[a].x) ret += (p[a].x ‐ R[b]) * (p[a].x ‐ R[b]);
114 //结点b与其右孩子中较小的纵坐标大于结点a的横坐标，则加上纵坐标二次方
115 if (D[b] > p[a].y) ret += (D[b] ‐ p[a].y) * (D[b] ‐ p[a].y);
116 //结点b与其右孩子中较大的纵坐标小于结点a的横坐标，则加上纵坐标二次方
117 if (U[b] < p[a].y) ret += (p[a].y ‐ U[b]) * (p[a].y ‐ U[b]);
118 return ret;
119 }
120
121 /*
122 * 函数名是query但不是查询，没有return，左闭右开
123 * 可以求离p[idx]最近的点离p[idx]的距离，是在函数中更新res的值
124 */
125 void query(int l, int r, int idx) {
126 if (l > r) return;
127 int mid = (l + r) >> 1;
128 if (mid != idx)
129 res = min(res, dist(idx, mid));
130 if (l == r) return;
131 //虽然函数f的理论依据不知，但猜测知是一种高维下的相对距离的表示方法
132 //到达点mid的region的距离
133 double distl = f(idx, lc[mid]), distr = f(idx, rc[mid]);
134 //当然是离点p[idx]越近的区域存在离点p[idx]最近的点的概率大
135 if (distl < res && distr < res) {
136 if (distl < distr) { query(l, mid, idx);
137 if (distr < res) query(mid+1, r, idx);
138 }
139 else { query(mid + 1, r, idx);
140 if (distl < res) query(l, mid, idx);
141 }
142 }
143 else {
144 if (distl < res) query(l, mid, idx);
145 if (distr < res) query(mid+1, r, idx);
146 }
147 }
148
149 int main() {
150 #ifndef ONLINE_JUDGE
151 freopen("in.txt", "r", stdin);
Nanchang university ACM template 第 183 页
152 // freopen("out.txt", "w", stdout);
153 #endif
154 scanf("%d", &n);
155 for (int i = 0; i < n; ++i)
156 scanf("%lf %lf", &p[i].x, &p[i].y);
157 build(0, n);
158 for (int i = 0; i < n; ++i)
159 query(0, n, i);
160 printf("%.4lf\n", sqrt(res));
161 return 0;
162 }
7.12.2 K-D-Tree.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐K‐D‐Tree.cpp
4 * 创建日期：2021年04月24日 ‐‐‐‐ 12时05分 5 * 题 目：luogu p4357 k远点对 6 * 算 法：K‐D tree 对顶堆 7 * 描 述：k远点对问题 8 * 堆中有k个元素，最小的就是第k远的 9 * 缺点，起始下标是1
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <queue>
15 #include <algorithm>
16 #include <ctime>
17 #include <vector>
18 using namespace std;
19 typedef long long ll;
20 const int maxn = 1e6 + 5;
21 const int inf = 0x3f3f3f3f;
22 #define _max(a, b) (a > b ? a : b)
23 #define _min(a, b) (a < b ? a : b)
24 bool opt;
25 int n, k;
26 int lc[maxn<<1], rc[maxn<<1], cnt;
27 int L[maxn], R[maxn], D[maxn], U[maxn];
28 priority_queue<ll> pqu; //默认数字大的优先级高
29
30 inline ll squ(int x) {return 1ll * x * x;}
31 struct Point{int x, y;} p[maxn], d[maxn << 1];
32 inline bool cmp(Point a, Point b) {return opt ? a.x < b.x : a.y < b.y;}
33 inline ll dist(Point a, Point b) {return squ(a.x‐b.x) + squ(a.y‐b.y);}
34 inline ll f(Point a, int b) {
35 return _max(squ(a.x‐L[b]), squ(a.x‐R[b])) + _max(squ(a.y‐D[b]), squ(a.y‐U[b]));
36 }
37
38 void maintain(int idx) {
39 L[idx] = R[idx] = d[idx].x;
40 D[idx] = U[idx] = d[idx].y;
41 if (lc[idx])
42 L[idx] = min(L[idx], L[lc[idx]]), R[idx] = max(R[idx], R[lc[idx]]),
43 D[idx] = min(D[idx], D[lc[idx]]), U[idx] = max(U[idx], U[lc[idx]]);
44 if (rc[idx])
45 L[idx] = min(L[idx], L[rc[idx]]), R[idx] = max(R[idx], R[rc[idx]]),
46 D[idx] = min(D[idx], D[rc[idx]]), U[idx] = max(U[idx], U[rc[idx]]);
47 }
48
49 /*方差*/
50 bool va(int l, int r) {
51 double avx = 0, avy = 0, vax = 0, vay = 0; // average variance
52 for (int i = l; i < r; ++i)
53 avx += p[i].x, avy += p[i].y;
54 avx /= (double)(r ‐ l); //横坐标平均值
55 avy /= (double)(r ‐ l); //纵坐标平均值
Nanchang university ACM template 第 184 页
56 for (int i = l; i < r; ++i)
57 vax += (p[i].x ‐ avx) * (p[i].x ‐ avx), // 方差(x) = vax / (r ‐ l + 1);
58 vay += (p[i].y ‐ avy) * (p[i].y ‐ avy); // 方差(y) = vay / (r ‐ l + 1);
59 return vax >= vay;
60 }
61
62 /*d数组是输入的点的dfs序*/
63 void build(int L, int R, int &x) {
64 if (L > R) return;
65 x = ++cnt;
66 int mid = (L+R) >> 1;
67 opt = va(L, R);//或者opt=rand()%2,或者轮换维度切割也好
68 nth_element(p+L, p+mid, p+R+1, cmp);
69 d[x] = p[mid];
70 build(L, mid‐1, lc[x]);
71 build(mid+1, R, rc[x]);
72 maintain(x);
73 }
74
75 /*查找离下标idx最近的点*/
76 void query(int i, int idx) {
77 ll distl = ‐inf, distr = ‐inf;
78 if (lc[i]) distl = f(p[idx], lc[i]);
79 if (rc[i]) distr = f(p[idx], rc[i]);
80 ll di = dist(p[idx], d[i]);
81 if (‐pqu.top() < di) {
82 pqu.pop();
83 pqu.push(‐di);
84 }
85 if (distl > distr) {
86 if (‐pqu.top() < distl) query(lc[i], idx);
87 if (‐pqu.top() < distr) query(rc[i], idx);
88 }
89 else {
90 if (‐pqu.top() < distr) query(rc[i], idx);
91 if (‐pqu.top() < distl) query(lc[i], idx);
92 }
93 }
94
95 int main() {
96 #ifndef ONLINE_JUDGE
97 freopen("in.txt", "r", stdin);
98 // freopen("out.txt", "w", stdout);
99 #endif
100 srand(time(NULL));
101 scanf("%d %d", &n, &k);
102 for (int i = 1; i <= n; ++i)
103 scanf("%d %d", &p[i].x, &p[i].y);
104 //距离是相对的，对于两个点会有两个同样的距离
105 //所有距离都比较一遍，则会出现第k大的距离
106 for (int i = 0; i < 2*k; ++i)
107 pqu.push(0);
108 build(1, n, lc[0]);
109 for (int i = 1; i <= n; ++i)
110 query(1, i);
111 printf("%lld\n", ‐pqu.top());
112 return 0;
113 }8 图论
8.1 图的存储
8.1.1 图论技巧.md
1 + 稠密图用邻接矩阵来存
2 + 稀疏图用邻接表存
3 + 最小生成树稠密图用prim
4 + 最小生成树稀疏图用Kruskal
Nanchang university ACM template 第 185 页
8.2 DFS(图论)
8.2.1 树的重心.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：树的重心.cpp
4 * 创建日期：2021年10月07日 星期四 15时58分34秒 5 * 题 目：AcWing 0846 树的重心 6 * 算 法：图论 DFS
7 * 描 述：
8 * 重心定义：重心是指树中的一个结点，
9 * 重心是指树中的一个结点如果将这个点删除后，
10 * 剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <cstring>
16 #include <algorithm>
17 using namespace std;
18 const int maxn = 2e5 + 5; // 无向图，所以乘2
19 int h[maxn], e[maxn], ne[maxn], idx;
20 int n;
21 bool used[maxn];
22
23 int res = maxn;
24
25 void add(int a, int b) {
26 e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
27 }
28
29 // 以u为根的子树中点的数量
30 int DFS(int u) {
31 used[u] = true;
32 int self = 1, max_part = 0;
33 for (int i = h[u]; i != ‐1; i = ne[i]) {
34 int j = e[i];
35 if (!used[j]) {
36 int s = DFS(j);
37 max_part = max(max_part, s);
38 self += s;
39 }
40 }
41 max_part = max(max_part, n ‐ self);
42 res = min(res, max_part);
43 return self;
44 }
45
46 int main() {
47 memset(h, ‐1, sizeof h);
48 scanf("%d", &n);
49 for (int i = 0; i < n ‐ 1; ++ i) {
50 int a, b;
51 scanf("%d %d", &a, &b);
52 add(a, b), add(b, a);
53 }
54 DFS(1);
55 printf("%d\n", res);
56 return 0;
57 }
8.2.2 邻接矩阵.cpp
1 #include <cstdio>
2 #include <cstring>
Nanchang university ACM template 第 186 页 3 const int maxn = 1000; /*顶点数再多就不再建议使用邻接矩阵了*/
4 int n, m; /*分别是顶点个数，边的个数*/
5 int g[maxn][maxn];
6 bool used[maxn]; /*DFS搜索需要标记已访问过的顶点*/
78 void DFS(int vert, int depth) {
9 printf("%d ", vert);
10 used[vert] = true; /*将已访问过的顶点标记为已被访问*/
11 for (int i = 0; i < n; ++i)
12 /*邻接矩阵初始化时就需要初始化为无穷大*/
13 /*所以也就是在这里判断是否是未输入的边*/
14 if (used[i] == false && g[vert][i])
15 DFS(i, depth + 1);
16 }
17
18 int main() {
19 freopen("in.txt", "r", stdin);
20 scanf("%d %d", &n, &m);
21 memset(g, 0, sizeof(g));
22 for (int i = 0; i < m; ++i) {
23 int ver1;
24 int ver2;
25 scanf("%d %d", &ver1, &ver2);
26 g[ver1][ver2] = 1;
27 g[ver2][ver1] = 1;
28 }
29 /*遍历图需要搜索每个顶点，首先需要判断是否已经访问*/
30 for (int i = 0; i < n; ++i)
31 if (used[i] == false)
32 DFS(i, 1); /*1表示第一层*/
33 return 0;
34 }
8.2.3 邻接表.cpp
1 #include <cstdio>
2 #include <vector>
3 using namespace std;
4 const int maxn = 1e4; //顶点数比1e3少的话，就可以使用邻接矩阵 5 int n, m; //顶点的个数，边的个数 6 vector<int> g[maxn]; //邻接矩阵与邻接表都使用一个变量名，好记 7 bool used[maxn]; //DFS搜索需要标记已访问过的顶点 89 void DFS(int vertex) {
10 used[vertex] = true;
11 for (int i = 0; i < (int)g[vertex].size(); ++i) {
12 int vert = g[vertex][i];
13 if (used[vert] == false)
14 DFS(vert);
15 }
16 }
17
18 int main() {
19 freopen("in.txt", "r", stdin);
20 scanf("%d %d", &n, &m);
21 for (int i = 0; i < m; ++i) {
22 int ver1, ver2;
23 scanf("%d %d", &ver1, &ver2);
24 g[ver1].push_back(ver2);
25 }
26 for (int i = 0; i < n; ++i)
27 if (used[i] == false)
28 DFS(i);
29 return 0;
30 }
8.2.4 链式前向星.cpp
Nanchang university ACM template 第 187 页 1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐图的深度优先搜索.cpp
4 * 创建日期：2021年04月14日 ‐‐‐‐ 19时30分 5 * 题 目：算法竞赛 6 * 算 法：图论，链式前向星 7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 const int maxn = 1e5 + 5;
13 int n, m;
14 int used[maxn];
15 int head[maxn], edge[maxn], nxet[maxn], vert[maxn];
16 int cnt, tot;
17
18 //加入有向边(x, y)，权值为z
19 void add(int x, int y, int z) {
20 vert[++tot] = y;
21 edge[tot] = z;
22 nxet[tot] = head[x];
23 head[x] = tot;
24 }
25
26 void DFS(int x) {
27 used[x] = true;
28 for (int i = head[x]; i; i = nxet[i]) {
29 int y = vert[i];
30 if (used[y]) continue;
31 printf("%d\n", y);
32 DFS(y);
33 }
34 }
35
36 int main() {
37 scanf("%d %d", &n, &m);
38 for (int i = 0; i < m; ++i) {
39 int x, y, z;
40 scanf("%d %d %d", &x, &y, &z);
41 add(x, y, z);
42 add(y, x, z);
43 }
44 for (int i = 0; i < n; ++i)
45 if (!used[i]) {
46 ++cnt;
47 DFS(i);
48 }
49 return 0;
50 }
8.3 BFS(图论)
8.3.1 BFS-邻接矩阵.cpp
1 #include <cstdio>
2 #include <cstring>
3 #include <queue>
4 using namespace std;
5 const int maxn = 1000; /*如果顶点数大于1000，就不再建议使用邻接矩阵*/
6 int n, m; /*分别是顶点个数，边的个数*/
7 bool g[maxn][maxn];
8 bool inq[maxn]; /*当前在队列中的顶点*/
9
10 void BFS(int vert) {
11 queue<int> quu;
12 quu.push(vert);
13 inq[vert] = true;
Nanchang university ACM template 第 188 页
14 while (!quu.empty()) {
15 int vert = quu.front();
16 printf("%d ", vert);
17 quu.pop();
18 for (int i = 0; i < n; ++i)
19 if (inq[i] == false && g[vert][i]) {
20 quu.push(i);
21 inq[i] = true;
22 }
23 }
24 }
25
26 int main() {
27 freopen("in.txt", "r", stdin);
28 scanf("%d %d", &n, &m);
29 memset(g, 0, sizeof(g));
30 for (int i = 0; i < m; ++i) {
31 int ver1;
32 int ver2;
33 scanf("%d %d", &ver1, &ver2);
34 g[ver1][ver2] = 1;
35 g[ver2][ver1] = 1;
36 }
37 /*一般图为连通图，那么只需要一次广搜遍历就行了*/
38 /*如果为非连通图，需要检查每一个顶点*/
39 for (int i = 0; i < n; ++i)
40 if (inq[i] == false)
41 BFS(i);
42 return 0;
43 }
8.3.2 BFS-邻接表.cpp
1 #include <cstdio>
2 #include <queue>
3 #include <vector>
4 using namespace std;
5 const int maxn = 1e4; //顶点比1e3少的话，就可以使用邻接矩阵 6 int n; //顶点的个数 7 //没有边权 8 vector<int> g[maxn];
9 bool inq[maxn]; //当前在队列中的顶点
10
11 void BFS(int vertex) {
12 queue<int> quu;
13 quu.push(vertex);
14 inq[vertex] = true;
15 while (!quu.empty()) {
16 int vert = quu.front();
17 quu.pop();
18 for (int i = 0; i < (int)g[vert].size(); ++i) {
19 int v = g[vert][i];
20 if (inq[v] == false) {
21 quu.push(v);
22 inq[v] = true;
23 }
24 }
25 }
26 }
27
28 int main() {
29 //一般图为连通图，那么只需要一次广搜遍历就行了
30 //如果为非连通图，需要检查每一个顶点
31 for (int i = 0; i < n; ++i)
32 if (inq[i] == false)
33 BFS(i);
34 return 0;
35 }
Nanchang university ACM template 第 189 页
8.3.3 BFS-链式前向星.cpp
1 #include <cstdio>
2 #include <cstring>
3 #include <queue>
4 #include <vector>
5 using namespace std;
6 const int maxn = 1e4; //顶点比1e3少的话，就可以使用邻接矩阵 7 int n, m; //顶点的个数 8 int vert[maxn], edge[maxn], nxet[maxn], head[maxn], tot;
9 bool used[maxn];
10
11 //加入有向边(x, y)，权值为z
12 void add(int x, int y, int z) {
13 vert[++tot] = y;
14 edge[tot] = z;
15 nxet[tot] = head[x];
16 head[x] = tot;
17 }
18
19 void BFS() {
20 queue<int> quu;
21 quu.push(0);
22 used[0] = true;
23 while (!quu.empty()) {
24 int x = quu.front();
25 printf("%d\n", x);
26 quu.pop();
27 for (int i = head[x]; i; i = nxet[i]) {
28 int y = vert[i];
29 if (used[y]) continue;
30 quu.push(y);
31 used[y] = true;
32 }
33 }
34 }
35
36 int main() {
37 freopen("in.txt", "r", stdin);
38 scanf("%d %d", &n, &m);
39 for (int i = 0; i < m; ++i) {
40 int x, y, z;
41 scanf("%d %d %d", &x, &y, &z);
42 add(x, y, z);
43 add(y, x, z);
44 }
45 BFS();
46 return 0;
47 }
8.4 拓扑排序
8.4.1 拓扑排序.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01.cpp
4 * 创建日期：2021年07月29日 星期四 00时43分56秒 5 * 题 目：AcWing 0848 有向图的拓扑序列 6 * 算 法：拓扑 7 * 描 述：拓扑序在队列中，
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 const int maxn = 1e5 + 5;
14
15 int n, m;
Nanchang university ACM template 第 190 页
16 int h[maxn], ve[maxn], ne[maxn], tot;
17 int quu[maxn], degree[maxn]; // 一个点的入度数
18
19 // ve[]存储结点，ne[]存储下一个结点，是一个指针，h[]是头结点
20 void add(int a, int b) {
21 ve[tot] = b, ne[tot] = h[a], h[a] = tot++;
22 }
23 /*
24 * 把当前入度为0的点加入到队列，并把这个点指向的点入度减一
25 * 因为我们把这个点放入队列了，自然要把这个点的所有连线删除，故指向的点入度减一
26 * 这时又会生成入度为0的点，继续上述操作
27 */
28 bool topsort() {
29 int hh = 0, tt = 0;
30 // 遍历每个点的入度，因为题目规定了点是[1, n]，所以for循环遍历[1, n]
31 // 把入度为0的点添加到队列中
32 for (int i = 1; i <= n; ++i)
33 if (!degree[i])
34 quu[tt++] = i;
35
36 while (hh < tt) {
37 int x = quu[hh++]; // 将已找到的入度为0的点指向的点入度减一
38
39 for (int i = h[x]; i != ‐1; i = ne[i]) {
40 int j = ve[i];
41 degree[j]‐‐;
42 if (degree[j] == 0)
43 quu[tt++] = j;
44 }
45 }
46 return tt == n; // 如果队列中添加过n个点，说明是拓扑图
47 }
48
49 int main() {
50 scanf("%d %d", &n, &m);
51 memset(h, ‐1, sizeof h); // 这条链表的最后一个是‐1
52 for (int i = 0; i < m; ++i) {
53 int ve1, ve2;
54 scanf("%d %d", &ve1, &ve2);
55 add(ve1, ve2);
56 degree[ve2]++;
57 }
58 if (topsort()) { // 队列中的点还在数组中
59 for (int i = 0; i < n; ++i)
60 printf("%d ", quu[i]);
61 puts("");
62 }
63 else
64 puts("‐1\n");
65 return 0;
66 }
8.5 最小生成树
8.5.1 Prim
8.5.1.1 Prim 算法求最小生成树.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Prim算法求最小生成树.cpp
4 * 创建日期：2021年08月12日 星期四 19时52分32秒 5 * 题 目：AcWing 0858 Prim算法求最小生成树 6 * 算 法：prim(稠密图, 边多) 7 * 描 述：注意：本题下标从1开始，本题可以解决自环、重环、边权为负数问题 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
Nanchang university ACM template 第 191 页
13 #include <cstring>
14 using namespace std;
15 const int maxn = 500 + 5;
16 const int INF = 0x3f3f3f3f;
17 int n, m;
18 int g[maxn][maxn];
19 int dist[maxn];
20 bool used[maxn];
21
22 /**
23 * 这里res存储的是最小生成树上所有边权之和
24 * 如果确定有最小生成树，可以返回空void
25 * 然后把所有的res删除，dist[]中是这棵树的所有边权
26 */
27 int prim() {
28 memset(dist, 0x3f, sizeof dist);
29 memset(used, 0, sizeof used);
30 int source = 1; dist[source] = 0; // 设置源点，不然下面的判断语句要额外判断是否是源点
31 int res = 0;
32 for (int i = 0; i < n; ++i) { // 这个循环只是为了将n个点都加入集合中，下标无所谓
33 int vert = ‐1; // 用vert找到集合外最近的点
34 for (int j = 1; j <= n; ++j) // 根据题目要求设置下标开始的位置
35 if (!used[j] && (vert == ‐1 || dist[j] < dist[vert]))
36 vert = j;
37 used[vert] = true; // 找到后标记true
38 if (dist[vert] == INF) // 如果不能形成最小生成树，一般不会，除非这个点不连通
39 return INF;
40 // 用新加入集合中的点vert更新未进入集合的点到集合的距离
41 for (int j = 1; j <= n; ++j)
42 if (!used[j])
43 dist[j] = min(dist[j], g[vert][j]);
44 res += dist[vert];
45 }
46 return res;
47 }
48
49 int main() {
50 scanf("%d %d", &n, &m);
51 memset(g, 0x3f, sizeof g);
52 while (m‐‐) {
53 int a, b, c;
54 scanf("%d %d %d", &a, &b, &c);
55 g[a][b] = g[b][a] = min(g[a][b], c);
56 }
57 int res = prim();
58 if (res >= INF)
59 printf("impossible\n");
60 else
61 printf("%d\n", res);
62 return 0;
63 }
8.5.2 Kruskal
8.5.2.1 Kruskal 算法求最小生成树.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Kruskal算法求最小生成树.cpp
4 * 创建日期：2021年08月12日 星期四 23时59分12秒 5 * 题 目：AcWing 0859 Kruskal算法求最小生成树 6 * 算 法：Kruskal(稀疏图，点多边少) 7 * 描 述：由于我们只需要知道边就可以进行Kruskal，所以用一个 8 * 结构体存储就可以 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <algorithm>
14 using std::sort;
Nanchang university ACM template 第 192 页
15 const int maxn = 2e5 + 5;
16 int n, m;
17 int fa[maxn];
18
19 struct Edge {
20 int a, b, c;
21 bool operator < (const Edge &E) const {
22 return c < E.c;
23 }
24 } edge[maxn];
25
26 int find(int x) {
27 if (fa[x] == x)
28 return x;
29 return fa[x] = find(fa[x]);
30 }
31
32 int main() {
33 scanf("%d %d", &n, &m);
34 for (int i = 0; i < m; ++i) {
35 int a, b, c;
36 scanf("%d %d %d", &a, &b, &c);
37 edge[i] = {a, b, c};
38 }
39 sort(edge, edge + m);
40 for (int i = 1; i <= n; ++i)
41 fa[i] = i;
42 int res = 0, cnt = 0; // 所有边权之和，加入到集合中边的个数
43 for (int i = 0; i < m; ++i) {
44 int a = edge[i].a,
45 b = edge[i].b,
46 c = edge[i].c;
47 int root_a = find(a),
48 root_b = find(b);
49 if (root_a != root_b) {
50 fa[root_a] = root_b;
51 res += c;
52 cnt ++;
53 }
54 }
55 if (cnt < n ‐ 1)
56 printf("impossible\n");
57 else
58 printf("%d\n", res);
59 return 0;
60 }
8.6 最短路
8.6.1 Dijstra
8.6.1.1 Dijkstra 求最短路 I.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Dijkstra求最短路I.cpp
4 * 创建日期：2021年08月13日 星期五 11时07分24秒 5 * 题 目：AcWing 0849 Dijkstra求最短路I 6 * 算 法：Dijkstra
7 * 描 述：朴素版Dijkstra，可以解决重边，自环问题，但是不能解决负环问题 8 * 因为没有负数，所以重边也就没有意义了，因为重边是正的，就不会更新这 9 * 条边。
10 * 本题是有向图，转化为无向图很容易，时间复杂度O(n^2)
11 *
12 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
13
14 #include <cstdio>
15 #include <cstring>
16 #include <algorithm>
17 using namespace std;
Nanchang university ACM template 第 193 页
18 const int maxn = 500 + 5;
19 const int INF = 0x3f3f3f3f;
20 int n, m;
21 int g[maxn][maxn], dist[maxn];
22 bool used[maxn];
23
24 // dist[n]表示从源点到第n个点的最短路
25 void dijkstra() {
26 memset(dist, 0x3f, sizeof dist);
27 memset(used, 0, sizeof used);
28 int source = 1; dist[source] = 0; // 设置源点
29 for (int i = 0; i < n; ++i) {
30 int vert = ‐1;
31 for (int j = 1; j <= n; ++j)
32 if (!used[j] && (vert == ‐1 || dist[j] < dist[vert]))
33 vert = j;
34 used[vert] = true;
35 for (int j = 1; j <= n; ++j)
36 if (!used[j])
37 dist[j] = min(dist[j], dist[vert] + g[vert][j]);
38 }
39 }
40
41 int main() {
42 scanf("%d %d", &n, &m);
43 memset(g, 0x3f, sizeof g);
44 while (m‐‐) {
45 int a, b, c;
46 scanf("%d %d %d", &a, &b, &c);
47 g[a][b] = min(g[a][b], c);
48 }
49 dijkstra();
50 if (dist[n] == INF)
51 printf("‐1\n");
52 else
53 printf("%d\n", dist[n]);
54 return 0;
55 }
8.6.1.2 Dijkstra 求最短路 II.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Dijkstra求最短路II.cpp
4 * 创建日期：2021年08月13日 星期五 11时41分15秒 5 * 题 目：AcWing 0850 Dijkstra求最短路II
6 * 算 法：Dijkstra
7 * 描 述：Dijkstra不可以有负边，堆优化的时间复杂度为O(mlogm) 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 #include <algorithm>
14 #include <queue>
15 using namespace std;
16 typedef pair<int, int> PII;
17 const int maxn = 2e5 + 5;
18 const int INF = 0x3f3f3f3f;
19 int n, m;
20 int h[maxn], e[maxn], ne[maxn], w[maxn], idx; // 邻接表，还要存权重
21 int dist[maxn];
22 bool used[maxn];
23
24 void add(int a, int b, int c) {
25 e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
26 }
27
28 void dijkstra() {
Nanchang university ACM template 第 194 页
29 memset(dist, 0x3f, sizeof dist);
30 memset(used, 0, sizeof used);
31 int source = 1; dist[source] = 0;
32 // 小根堆，优先队列会按结构体的第一位排序，所以将距离放在第一位，它就会把距离最小的放在最前面，得到最近的点
33 priority_queue<PII, vector<PII>, greater<PII>> he;
34 he.push({0, source}); // 距离：0, 源点：source
35 while (he.size()) {
36 auto t = he.top(); // t = top，小根堆的堆顶，距离集合最近的点
37 he.pop();
38 int d = t.first, vert = t.second; // d = dist, 堆顶元素vert距离源点的距离
39 if (used[vert]) // 冗余
40 continue;
41 used[vert] = true;
42 // 用vert更新所有它邻接的点
43 // 因为一个点可能同时被上一个vert和当前vert更新，就会压入堆中两次，所以就有了上面的消除冗余
44 for (int i = h[vert]; i != ‐1; i = ne[i]) {
45 int j = e[i];
46 if (dist[j] > d + w[i]) {
47 dist[j] = d + w[i];
48 he.push({dist[j], j});
49 }
50 }
51 }
52 }
53
54 int main() {
55 scanf("%d %d", &n, &m);
56 memset(h, ‐1, sizeof h); // 邻接表
57 while (m ‐‐) {
58 int a, b, c;
59 scanf("%d %d %d", &a, &b, &c);
60 add(a, b, c);
61 }
62 dijkstra();
63 if (dist[n] == INF)
64 printf("‐1\n");
65 else
66 printf("%d\n", dist[n]);
67 return 0;
68 }
8.6.2 Bellman-Ford
8.6.2.1 有边数限制的最短路.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：有边数限制的最短路.cpp
4 * 创建日期：2021年08月13日 星期五 13时46分17秒 5 * 题 目：<++>
6 * 算 法：<++>
7 * 描 述：Bellman‐Ford算法只要能够遍历到所有边就可以，所以 8 * 存储时使用结构体就可以，Bellman‐Ford可以存在负权边，也可以存在 9 * 负权回路
10 * 2 4 2
11 * 1 ‐‐‐‐‐‐‐‐‐‐ 2 ‐‐‐‐‐‐‐‐‐‐ 3 ‐‐‐‐‐‐‐‐‐‐ 5
12 * \ /
13 * \ /
14 * ‐2 \ / ‐3
15 * \ /
16 * 4
17 *
18 * ‐ 如果出现负权回路，就不存在从1到5的最短路，负权回路不是只有负边，
19 * 还要这个回路是的权是负的
20 * ‐ 但是如果存在负环，但是负环又不在我要求的最短路上，那就不影响最后结果
21 * 本题只能使用Bellman‐Ford算法来做，因为我们限制了这条最短路需要经过k条
22 * 边
23 * 时间复杂度O(nm)
24 *
25 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
Nanchang university ACM template 第 195 页
26
27 #include <cstdio>
28 #include <algorithm>
29 #include <cstring>
30 using namespace std;
31 const int N = 500 + 5, M = 1e4 + 5;
32 const int INF = 0x3f3f3f3f;
33 int n, m, k;
34 int dist[N], backup[N];
35
36 struct Edge {
37 int a, b, c;
38 } edge[M];
39
40 void bellman_ford() {
41 memset(dist, 0x3f, sizeof dist);
42 int source = 1; dist[source] = 0;
43 for (int i = 0; i < k; ++i) {
44 /**
45 * 迭代k次，为什么要备份dist数组呢？
46 * 假如输入:
47 * 1 2 1
48 * 2 3 1
49 * 1 3 3
50 * 又k = 1, 那么就有1到3的距离是3, 虽然可以先从1到2距离为1, 然后从2到3距离为1, 得出更短的距离 1 ‐> 3 = 2
51 * 但是有限制k = 1, 即只能经过一条边从1到3, 如果我们不备份的话，更新了1 ‐> 2 = 1，然后循环继续更新2的出边
52 * 就会发生串联，我们只希望第k次迭代dist[x]时使用的是第k‐1次的dist
53 */
54 memcpy(backup, dist, sizeof dist);
55 for (int j = 0; j < m; ++ j) {
56 int a = edge[j].a, b = edge[j].b, c = edge[j].c;
57 dist[b] = min(dist[b], backup[a] + c);
58 }
59 }
60 }
61
62 int main() {
63 scanf("%d %d %d", &n, &m, &k);
64 for (int i = 0; i < m; ++i) {
65 int a, b, c;
66 scanf("%d %d %d", &a, &b, &c);
67 edge[i] = {a, b, c};
68 }
69 bellman_ford();
70 // 为什么除以2, 是因为可能有 t ‐> n 这条边是负权的，虽然源点到不了n，但是n会被别的点更新小一点
71 if (dist[n] > INF / 2)
72 printf("impossible\n");
73 else
74 printf("%d\n", dist[n]);
75 return 0;
76 }
8.6.3 SPFA
8.6.3.1 spfa 判断负环.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：spfa判断负环.cpp
4 * 创建日期：2021年08月13日 星期五 16时09分25秒 5 * 题 目：AcWing 0852 spfa判断负环 6 * 算 法：spfa
7 * 描 述：给定一个n个点m条边的有向图，图中可能存在重边和自环，
8 * 边权可能为负数，判断图中是否存在负权回路 9 * 当有一个cnt[x] >= n时，就说明出现了负环
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <cstring>
Nanchang university ACM template 第 196 页
15 #include <algorithm>
16 #include <queue>
17 using namespace std;
18 const int maxn = 2e5 + 5;
19 const int INF = 0x3f3f3f3f;
20 int n, m;
21 int h[maxn], e[maxn], ne[maxn], w[maxn], idx; // 邻接表，还要存权重
22 int dist[maxn], cnt[maxn]; // 这个cnt数组是多加的，cnt[x]记录从源点到节点x的最短路经过了多少条边
23 bool used[maxn];
24
25 void add(int a, int b, int c) {
26 e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
27 }
28
29 bool spfa() {
30 // 有没有发现这里没有初始化了，因为我们不是求距离了
31 // 也没有源点source了，这是因为我们需要找到负环，而不只是从源点到达的负环
32 queue<int> quu;
33 for (int i = 1; i <= n; ++i) {
34 used[i] = true;
35 quu.push(i);
36 }
37 while (quu.size()) {
38 int vert = quu.front();
39 quu.pop();
40 used[vert] = false;
41 for (int i = h[vert]; i != ‐1; i = ne[i]) {
42 int j = e[i];
43 if (dist[j] > dist[vert] + w[i]) {
44 dist[j] = dist[vert] + w[i];
45 cnt[j] = cnt[vert] + 1;
46 if (cnt[j] >= n)
47 return true;
48 if (!used[j]) {
49 quu.push(j);
50 used[j] = true;
51 }
52 }
53 }
54 }
55 return false;
56 }
57
58 int main() {
59 scanf("%d %d", &n, &m);
60 memset(h, ‐1, sizeof h); // 邻接表
61 while (m ‐‐) {
62 int a, b, c;
63 scanf("%d %d %d", &a, &b, &c);
64 add(a, b, c);
65 }
66 spfa() ? printf("Yes\n") : printf("No\n");
67 return 0;
68 }
8.6.3.2 spfa 求最短路.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：spfa求最短路.cpp
4 * 创建日期：2021年08月13日 星期五 15时13分46秒 5 * 题 目：AcWing 0851 spfa求最短路 6 * 算 法：spfa
7 * 描 述：Bellman‐Ford算法是对每个点每条边都更新，而spfa只更新 8 * 那些在第一次更新时变小的点，不可以操作有负权回路的图 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
Nanchang university ACM template 第 197 页
13 #include <cstring>
14 #include <algorithm>
15 #include <queue>
16 using namespace std;
17 const int maxn = 2e5 + 5;
18 const int INF = 0x3f3f3f3f;
19 int n, m;
20 int h[maxn], e[maxn], ne[maxn], w[maxn], idx; // 邻接表，还要存权重
21 int dist[maxn];
22 bool used[maxn];
23
24 void add(int a, int b, int c) {
25 e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
26 }
27
28 void spfa() {
29 memset(dist, 0x3f, sizeof dist);
30 int source = 1; dist[source] = 0;
31 queue<int> quu;
32 quu.push(source); used[source] = true; // used表示当前元素是否在队列中，防止出现重复的点
33 while (quu.size()) {
34 int vert = quu.front();
35 quu.pop();
36 used[vert] = false;
37 for (int i = h[vert]; i != ‐1; i = ne[i]) {
38 int j = e[i];
39 if (dist[j] > dist[vert] + w[i]) {
40 dist[j] = dist[vert] + w[i];
41 if (!used[j]) {
42 quu.push(j);
43 used[j] = true;
44 }
45 }
46 }
47 }
48 }
49
50 int main() {
51 scanf("%d %d", &n, &m);
52 memset(h, ‐1, sizeof h); // 邻接表
53 while (m ‐‐) {
54 int a, b, c;
55 scanf("%d %d %d", &a, &b, &c);
56 add(a, b, c);
57 }
58 spfa();
59 if (dist[n] == INF)
60 printf("impossible\n");
61 else
62 printf("%d\n", dist[n]);
63 return 0;
64 }
8.6.4 Floyd
8.6.4.1 Floyd 求最短路.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：Floyd求最短路.cpp
4 * 创建日期：2021年08月13日 星期五 16时23分01秒 5 * 题 目：AcWing 0854 Floyd求最短路 6 * 算 法：Floyd
7 * 描 述：给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环 8 * 边权可能为负数。再给定 k 个询问，每个询问包含两个整数 x 和 y， 9 * 表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible
10 *
11 * 可以有负权边，不可有负权回路
12 *
13 * 算法过程：检查是否存在一个点k使得i与j之间的最短路能够更新
Nanchang university ACM template 第 198 页
14 * 基于动态规划理解：d[k, i, j]表示从i点只经过[i, k]这些点到达j的最短路径
15 * d[k‐1, i, j] = d[k‐1, i, k] + d[k‐1, k, j];
16 * 发现第一维可以去掉 d[i, j] = d[i, k] + d[k, j];
17 *
18 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
19
20 #include <cstdio>
21 #include <algorithm>
22 using namespace std;
23 const int maxn = 200 + 5;
24 const int INF = 0x3f3f3f3f;
25 int n, m, Q;
26 int d[maxn][maxn]; // 使用d数组而不是g数组，因为后面会更改里面的值，最后存的是距离
27
28 void floyd() {
29 for (int k = 1; k <= n; k++)
30 for (int i = 1; i <= n; ++i)
31 for (int j = 1; j <= n; ++j) {
32 d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
33 // d[j][i] = d[i][j];
34 }
35 }
36
37 int main() {
38 scanf("%d %d %d", &n, &m, &Q);
39 for (int i = 1; i <= n; ++i)
40 for (int j = 1; j <= n; ++j)
41 if (i == j)
42 d[i][j] = 0; // 防止出现自环
43 else
44 d[i][j] = INF;
45 while (m ‐‐) {
46 int a, b, c;
47 scanf("%d %d %d", &a, &b, &c);
48 d[a][b] = min(d[a][b], c); // 取消重边
49 }
50 floyd();
51 while (Q ‐‐) {
52 int a, b;
53 scanf("%d %d", &a, &b);
54 if (d[a][b] > INF / 2)
55 printf("impossible\n");
56 else
57 printf("%d\n", d[a][b]);
58 }
59 return 0;
60 }
8.7 连通性相关
8.7.1 强连通分量
8.7.1.1 Kosaraju.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Kosaraju.cpp
4 * 创建日期：2021年03月26日 ‐‐‐‐ 19时39分 5 * 题 目：hdu1269 迷宫城堡 6 * 算 法：Kosaraju
7 * 描 述：一个有向图，有n个点(n <= 10000)和m条边(m <= 100000)
8 * 判断整个图是否强连通，如果是，输出Yes，否则输出No
9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include <cstdio>
13 #include <vector>
14 #include <cstring>
15 using namespace std;
16 const int maxn = 10005;
Nanchang university ACM template 第 199 页
17 vector<int> g[maxn], rg[maxn];
18 vector<int> S; //存第一次dfs1的结果：标记点的先后顺序
19 int vis[maxn]; //在dfs1()中，用vis[i]记录点i是否被访问
20 int sccno[maxn]; //sccno[i]是第i个点所属的SCC，在dfs2()中，sccno[i]也被用于记录点i是否被访问
21 int cnt; // cnt：强连通分量的个数
22
23 void dfs1(int u) {
24 if (vis[u])
25 return;
26 vis[u] = 1;
27 for (int i = 0; i < g[u].size(); ++i)
28 dfs1(g[u][i]);
29 S.push_back(u); //记录点的先后顺序，标记大的放在S的后面
30 }
31
32 void dfs2(int u) {
33 if (sccno[u])
34 return;
35 sccno[u] = cnt;
36 for (int i=0; i < rg[u].size(); ++i)
37 dfs2(rg[u][i]);
38 }
39
40 void Kosaraju(int n) {
41 cnt = 0;
42 S.clear();
43 memset(sccno, 0, sizeof(sccno));
44 memset(vis, 0, sizeof(vis));
45 for (int i = 1; i <= n; ++i)
46 dfs1(i); //点的编号：1~n。递归所有点
47 for (int i = n‐1; i >= 0; ‐‐i)
48 if (!sccno[S[i]]) {
49 cnt++;
50 dfs2(S[i]);
51 }
52 }
53
54 int main() {
55 int n, m, u, v;
56 while (scanf("%d %d", &n, &m), n != 0 || m != 0) {
57 for(int i = 0; i < n; ++i) {
58 g[i].clear();
59 rg[i].clear();
60 }
61 for(int i = 0; i < m; ++i){
62 scanf("%d %d", &u, &v);
63 g[u].push_back(v); //原图
64 rg[v].push_back(u); //反图
65 }
66 Kosaraju(n);
67 printf("%s\n", cnt == 1 ? "Yes" : "No");
68 }
69 return 0;
70 }
8.7.1.2 Tarjan.cpp
1 #include <cstdio>
2 #include <cstring>
3 #include <vector>
4 using namespace std;
5 const int maxn = 10005;
6 int cnt; // 强连通分量的个数 7 int low[maxn];
8 int num[maxn];
9 int dfn;
10 int sccno[maxn];
11 int stack[maxn];
12 int top; // 用stack[]处理栈，top是栈顶
Nanchang university ACM template 第 200 页
13 vector<int> g[maxn];
14
15 void dfs(int u) {
16 stack[top++] = u; //u进栈
17 low[u] = num[u] = ++dfn;
18 for (int i = 0; i < g[u].size(); ++i) {
19 int v = g[u][i];
20 if (!num[v]) { //未访问过的点，继续dfs
21 dfs(v); //dfs的最底层，是最后一个SCC
22 low[u] = min(low[v], low[u]);
23 }
24 else if (!sccno[v]) //处理回退边
25 low[u]= min(low[u], num[v]);
26 }
27 if (low[u] == num[u]) { //栈底的点是SCC的祖先，它的low = num
28 cnt++;
29 while (1) {
30 int v = stack[‐‐top]; //v弹出栈
31 sccno[v] = cnt;
32 if (u == v) //栈底的点是SCC的祖先
33 break;
34 }
35 }
36 }
37
38 void Tarjan(int n) {
39 cnt = top = dfn = 0;
40 memset(sccno, 0, sizeof(sccno));
41 memset(num, 0, sizeof(num));
42 memset(low, 0, sizeof(low));
43 for (int i = 1; i <= n; ++i)
44 if (!num[i])
45 dfs(i);
46 }
47
48 int main() {
49 int n, m, u, v;
50 while(scanf("%d %d", &n, &m), n != 0 || m != 0) {
51 for (int i = 1; i <= n; ++i)
52 g[i].clear();
53 for (int i = 0; i < m; ++i) {
54 scanf("%d %d", &u, &v);
55 g[u].push_back(v);
56 }
57 Tarjan(n);
58 printf("%s\n", cnt == 1 ? "Yes" : "No" );
59 }
60 return 0;
61 }
8.7.2 双连通分量
8.7.2.1 边双连通分量.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐边双连通分量.cpp
4 * 创建日期：2021年03月26日 ‐‐‐‐ 15时13分 5 * 题 目：poj3352 Road Construction
6 * 算 法：边双连通分量 7 * 描 述：给定一个无向图，图中没有重边，问添加几条边才能使无 8 * 向图变成边双连通分量 9 *
10 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
11
12 #include<cstring>
13 #include<vector>
14 #include<stdio.h>
15 using namespace std;
16 const int maxn = 1005;
Nanchang university ACM template 第 201 页
17 int n, m, low[maxn], dfn;
18 vector<int> g[maxn];
19
20 void dfs(int u, int fa) { //计算每个点的low值
21 low[u] = ++dfn;
22 for (int i = 0; i < g[u].size(); ++i) {
23 int v = g[u][i];
24 if (v == fa)
25 continue;
26 if (!low[v])
27 dfs(v, u);
28 low[u] = min(low[u], low[v]);
29 }
30 }
31
32 int tarjan() {
33 int degree[maxn]; //计算每个缩点的度数
34 memset(degree, 0, sizeof(degree));
35 for (int i = 1; i <= n; ++i) //把有相同low值的点看成一个缩点
36 for (int j = 0; j < g[i].size(); ++j)
37 if (low[i] != low[g[i][j]])
38 degree[low[i]]++;
39 int res = 0;
40 for(int i = 1; i <= n; ++i) //统计度数为1的缩点个数
41 if (degree[i] == 1)
42 ++res;
43 return res;
44 }
45
46 int main() {
47 while(~scanf("%d%d", &n, &m)) {
48 memset(low, 0, sizeof(low));
49 for (int i = 0; i <= n; ++i)
50 g[i].clear();
51 for (int i = 1; i <= m; ++i) {
52 int ver1, ver2;
53 scanf("%d%d", &ver1, &ver2);
54 g[ver1].push_back(ver2);
55 g[ver2].push_back(ver1);
56 }
57 dfn = 0;
58 dfs(1, ‐1);
59 int ans = tarjan();
60 printf("%d\n", (ans+1)/2);
61 }
62 return 0;
63 }
8.7.3 割点和桥
8.7.3.1 判断是否是割点.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐判断是否是割点.cpp
4 * 创建日期：2021年03月24日 ‐‐‐‐ 20时51分 5 * 题 目：poj1144 network
6 * 算 法：割点 7 * 描 述：输入一个无向图，求割点的数量 8 * 使用深搜优先生成树求割点 9 * 定义num[u]记录DFS对每个点的访问顺序，num值随着递推深度增加
10 * 而变大
11 * 定义low[v]记录v和u的后代能连回到的祖先的num
12 * 只要low[v] >= num[u]，就说明在v这个支路上没有回退边连回u的
13 * 祖先，最多退到u本身
14 * 把程序中的if (low[v] >= num[u] && u != 1) 改为 if (low[v] > num[u] && u != 1)
15 * 其他程序不变，就是求割边的数量
16 *
17 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
18
Nanchang university ACM template 第 202 页
19 #include <cstdio>
20 #include <algorithm>
21 #include <cstring>
22 #include <vector>
23 using namespace std;
24 const int maxn = 109;
25 int low[maxn];
26 int num[maxn];
27 int dfn; //时间戳，记录进入递归的顺序
28 bool iscut[maxn]; //标记是否为割点
29 vector <int> g[maxn];
30
31 void dfs(int u, int fa) { //u的父结点是fa
32 low[u] = num[u] = ++dfn; //初始值
33 int child = 0; //孩子数目
34 for (int i = 0; i < g[u].size(); ++i) { //处理u的所有子结点
35 int v = g[u][i];
36 if (!num[v]) { //v没访问过
37 child++;
38 dfs(v, u);
39 low[u] = min(low[v], low[u]); //用后代的返回值更新low值
40 if (low[v] >= num[u] && u !=1)
41 iscut[u] = true; //标记割点
42 }
43 else if (num[v] < num[u] && v != fa)
44 //处理回退边，注意这里v != fa，fa是u的父结点，
45 //fa也是u的邻居，但是前面已经访问过，不需要处理它
46 low[u] = min(low[u], num[v]);
47 }
48 if (u == 1 && child >= 2) //根结点，有两个以上不相连的子树
49 iscut[1] = true;
50 }
51
52 /*根结点从1开始*/
53 int main() {
54 int res;
55 int n;
56 while (scanf("%d", &n) != ‐1) {
57 if (n == 0)
58 break;
59 memset(low, 0, sizeof(low));
60 memset(num, 0, sizeof(num));
61 dfn = 0;
62 for (int i = 0; i <= n; ++i)
63 g[i].clear();
64 int ver1, ver2;
65 while (scanf("%d", &ver1) && ver1)
66 while (getchar() != '\n') {
67 scanf("%d", &ver2);
68 g[ver1].push_back(ver2);
69 g[ver2].push_back(ver1);
70 }
71 memset(iscut, false, sizeof(iscut));
72 res = 0;
73 dfs(1, 1);
74 for (int i = 1; i <= n; ++i)
75 res += iscut[i];
76 printf("%d\n", res);
77 }
78 return 0;
79 }
8.8 二分图
8.8.1 二分图的最大匹配-匈牙利算法.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：二分图的最大匹配(匈牙利算法).cpp
Nanchang university ACM template 第 203 页 4 * 创建日期：2021年10月08日 星期五 21时35分08秒 5 * 题 目：AcWing 0861 二分图的最大匹配 6 * 算 法：匈牙利算法 7 * 描 述：左半部包含n1个点，右半部包含n1个点，二分图共有m个边 8 * 输出最大匹配 9 * 虽然是无向边，但是因为只会为男生找女生，所以只需要存一条有向边就可以
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <cstring>
15 const int maxn = 1e5 + 5;
16 int n1, n2, m;
17 int h[maxn], e[maxn], ne[maxn], idx;
18 int match[maxn]; // 每个女孩找到的哪个男孩
19 bool used[maxn]; // 不重复搜一个点，就是有可能两个点之间有多条边
20
21 void add(int a, int b) {
22 e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
23 }
24
25 bool find(int u) {
26 for (int i = h[u]; i != ‐1; i = ne[i]) {
27 int j = e[i];
28 if (!used[j]) { // 如果这个点未搜过
29 used[j] = true;
30 // 如果这个女孩还没找到男朋友，或者她的男朋友可以换人
31 if (match[j] == 0 || find(match[j])) {
32 match[j] = u;
33 return true;
34 }
35 }
36 }
37 return false;
38 }
39
40 int main() {
41 scanf("%d %d %d", &n1, &n2, &m);
42 memset(h, ‐1, sizeof h);
43 while (m ‐‐ ) {
44 int a, b;
45 scanf("%d %d", &a, &b);
46 add(a, b);
47 }
48
49 int res = 0; // 匹配数量
50 // 给男生找女朋友
51 for (int i = 1; i <= n1; ++ i) {
52 memset(used, false, sizeof used);
53 if (find(i))
54 res ++ ;
55 }
56 printf("%d\n", res);
57 return 0;
58 }
8.8.2 染色法判定二分图.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：染色法判定二分图.cpp
4 * 创建日期：2021年10月08日 星期五 16时32分49秒 5 * 题 目：AcWing 0860 染色法判定二分图 6 * 算 法：染色法 7 * 描 述：
8 * 给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。
9 * 请你判断这个图是否是二分图。
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
Nanchang university ACM template 第 204 页
12
13 #include <cstdio>
14 #include <cstring>
15 const int maxn = 1e5 + 5, maxe = 2e5 + 5;
16 int h[maxn], e[maxe], ne[maxe], idx;
17 int n, m;
18 int color[maxn];
19
20 void add(int a, int b) {
21 e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
22 }
23
24 // 返回false表示有矛盾
25 bool DFS(int u, int c) {
26 color[u] = c;
27 for (int i = h[u]; i != ‐1; i = ne[i]) {
28 int j = e[i];
29 if (!color[j]) {
30 if (!DFS(j, 3 ‐ c))
31 return false;
32 }
33 else if (color[j] == c) {
34 return false;
35 }
36 }
37 return true;
38 }
39
40 int main() {
41 scanf("%d %d", &n, &m);
42 memset(h, ‐1, sizeof h);
43 while (m ‐‐ ) {
44 int a, b;
45 scanf("%d %d", &a, &b);
46 add(a, b), add(b, a);
47 }
48 bool flag = true;
49 for (int i = 1; i <= n; ++ i)
50 if (!color[i])
51 // 有两种颜色，1, 2
52 if (!DFS(i, 1)) {
53 flag = false;
54 break;
55 }
56
57 if (flag) puts("Yes");
58 else puts("No");
59 return 0;
60 }
8.9 网络流
8.9.1 最大流
8.9.1.1 Edmonds-Karp.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：01‐Edmonds‐Karp.cpp
4 * 创建日期：2021年03月26日 ‐‐‐‐ 21时44分 5 * 题 目：hdu1532 Drainage Ditches
6 * 算 法：最大流Edmonds‐Karp
7 * 描 述：源点到终点的最大流速 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <cstring>
13 #include <algorithm>
14 #include <queue>
Nanchang university ACM template 第 205 页
15 using namespace std;
16 const int inf = 1e9;
17 const int maxn = 300;
18 int n, m;
19 int g[maxn][maxn];
20 int pre[maxn];
21 // g[][]不仅记录图，还是残留网络
22
23 int bfs(int s, int t) {
24 int flow[maxn];
25 memset(pre, ‐1, sizeof pre);
26 flow[s] = inf;
27 pre[s] = 0; //初始化起点
28 queue<int> Q;
29 Q.push(s); //起点入栈，开始bfs
30 while(!Q.empty()) {
31 int u = Q.front();
32 Q.pop();
33 if (u == t)
34 break; //搜到一个路径，这次bfs结束
35 for (int i = 1; i <= m; ++i) { //bfs所有的点
36 if (i != s && g[u][i] > 0 && pre[i] == ‐1) {
37 pre[i] = u; //记录路径
38 Q.push(i);
39 flow[i] = min(flow[u], g[u][i]); //更新结点流量
40 }
41 }
42 }
43 if (pre[t] == ‐1) //没有找到新的增广路
44 return ‐1;
45 return flow[t]; //返回这个增广路的流量
46 }
47
48 int maxflow(int s, int t) {
49 int Maxflow = 0;
50 while (1) {
51 int flow = bfs(s, t);
52 //执行一次bfs，找到一条路径，返回路径的流量
53 if (flow == ‐1) //没有找到新的增广路，结束
54 break;
55 int cur = t; //更新路径上的残留网络
56 while (cur!=s) { //一直沿路径回溯到起点
57 int father = pre[cur]; //pre[]记录路径上的前一个点
58 g[father][cur] ‐= flow; //更新残留网络：正向减
59 g[cur][father] += flow; //更新残留网络：反向加
60 cur = father;
61 }
62 Maxflow += flow;
63 }
64 return Maxflow;
65 }
66
67 int main() {
68 while(~scanf("%d %d", &n, &m)) {
69 memset(g, 0, sizeof g);
70 for (int i = 0; i < n; ++i) {
71 int u, v, w;
72 scanf("%d %d %d", &u, &v, &w);
73 g[u][v] += w; //可能有重边
74 }
75 printf("%d\n", maxflow(1, m));
76 }
77 return 0;
78 }
8.9.2 费用流
8.9.2.1 最小费用最大流.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
Nanchang university ACM template 第 206 页 2 * 3 * 文件名称：01‐最小费用最大流.cpp
4 * 创建日期：2021年03月29日 ‐‐‐‐ 11时56分 5 * 题 目：poj 2135 Farm Tour
6 * 算 法：Ford‐Fulkerson SPFA
7 * 描 述：<++>
8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <stdio.h>
12 #include <algorithm>
13 #include <cstring>
14 #include <queue>
15 using namespace std;
16 const int inf = 0x3f3f3f3f;
17 const int maxn = 1010;
18 int n, m;
19 int dis[maxn];
20 int pre[maxn];
21 int preve[maxn];
22 //dis[i]记录起点到i的最短距离。pre和 preve见下面注释
23
24 struct edge {
25 int to, cost, capacity, rev; //rev用于记录前驱点
26 edge (int to_,int cost_,int c,int rev_) {
27 to = to_;
28 cost = cost_;
29 capacity = c;
30 rev = rev_;}
31 };
32
33 vector<edge> e[maxn]; //e[i]：存第i个结点连接的所有的边
34 void addedge(int from,int to,int cost,int capacity){//把1个有向边再分为2个
35 e[from].push_back(edge(to, cost, capacity, e[to].size()));
36 e[to].push_back(edge(from, ‐cost, 0, e[from].size()‐1));
37 }
38
39 bool spfa(int s, int t, int cnt) { //套SPFA模板
40 bool inq[maxn];
41 memset(pre, ‐1, sizeof(pre));
42 for (int i = 1; i <= cnt; ++i) {
43 dis[i]=inf;
44 inq[i]=false;
45 }
46 dis[s] = 0;
47 queue <int> Q;
48 Q.push(s);
49 inq[s] = true;
50 while(!Q.empty()) {
51 int u = Q.front();
52 Q.pop();
53 inq[u] = false;
54 for (int i=0; i < e[u].size(); ++i)
55 if (e[u][i].capacity > 0){
56 int v = e[u][i].to, cost = e[u][i].cost;
57 if (dis[u]+cost < dis[v]) {
58 dis[v] = dis[u]+cost;
59 pre[v] = u; //v的前驱点是u
60 preve[v] = i; // u的第i个边连接v点
61 if (!inq[v]) {
62 inq[v] = true;
63 Q.push(v);
64 }
65 }
66 }
67 }
68 return dis[t] != inf; //s到t的最短距离（或者最小费用）是dis[t]
69 }
70
71 int mincost(int s, int t, int cnt) { //基本上是套最大流模板
Nanchang university ACM template 第 207 页
72 int cost = 0;
73 while (spfa(s, t, cnt)) {
74 int v = t, flow = inf; //每次增加的流量
75 while(pre[v] != ‐1) { //回溯整个路径，计算路径的流
76 int u = pre[v], i = preve[v];
77 //u是v的前驱点，u的第i个边连接v
78 flow = min(flow, e[u][i].capacity);
79 //所有边的最小容量就是这条路的流
80 v = u; //回溯，直到源点
81 }
82 v = t;
83 while (pre[v] != ‐1) { //更新残留网络
84 int u = pre[v], i = preve[v];
85 e[u][i].capacity ‐= flow; //正向减
86 e[v][e[u][i].rev].capacity += flow;//反向加，注意rev的作用
87 v = u; //回退，直到源点
88 }
89 cost += dis[t]*flow;
90 //费用累加。如果程序需要输出最大流，在这里累加flow
91 }
92 return cost; //返回总费用
93 }
94 int main() {
95 while (~scanf("%d%d", &n, &m)) {
96 for (int i = 0; i < maxn; ++i)
97 e[i].clear(); //清空待用
98 for (int i = 1; i <= m; ++i) {
99 int u, v, w;
100 scanf("%d%d%d", &u, &v, &w);
101 addedge(u, v, w, 1); //把1个无向边分为2个有向边
102 addedge(v, u, w, 1);
103 }
104 int s = n+1, t = n+2;
105 addedge(s, 1, 0, 2); //添加源点
106 addedge(n, t, 0, 2); //添加汇点
107 printf("%d\n", mincost(s, t, n+2));
108 }
109 return 0;
110 }9 杂项
9.1 离散化
9.1.1 离散化-区间和.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02.cpp
4 * 创建日期：2021年06月01日 星期二 13时25分21秒 5 * 题 目：AcWing 0802 区间和 6 * 算 法：离散化 7 * 描 述：这个代码质量更高一点 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <vector>
13 #include <algorithm>
14 #include <utility>
15 using namespace std;
16 // typedef pair<int, int> PII;
17 using PII = pair<int, int>;
18 #define pb push_back
19 #define fi first
20 #define se second
21 #define bug printf("<‐‐>\n");
22 #define NEXTLINE puts("");
23 const int maxn = 3e5 + 5;
Nanchang university ACM template 第 208 页
24 int n, m;
25 vector<PII> op, query;
26 vector<int> alls; //存储所有待离散化的值
27 int I[maxn], preS[maxn];
28
29 int find(int x) { //二分求出x对应的离散化的值
30 int l = 0, r = alls.size() ‐ 1;
31 while (l < r) {
32 int mid = (l + r) >> 1;
33 if (alls[mid] >= x)
34 r = mid;
35 else
36 l = mid + 1;
37 }
38 return r + 1; //映射到1, 2, 3, ..., n
39 }
40
41 int main() {
42 scanf("%d %d", &n, &m);
43 for (int i = 0; i < n; ++i) {
44 int x, c;
45 scanf("%d %d", &x, &c);
46 op.pb({x, c});
47 alls.pb(x);
48 }
49 for (int i = 0; i < m; ++i) {
50 int l, r;
51 scanf("%d %d", &l, &r);
52 query.pb({l, r});
53 alls.pb(l);
54 alls.pb(r);
55 }
56
57 sort(alls.begin(), alls.end());
58 alls.erase(unique(alls.begin(), alls.end()), alls.end());
59
60 for (auto item : op) { //离散化成功
61 int idx = find(item.fi);
62 I[idx] += item.se;
63 }
64
65 for (int i = 1; i <= (int)alls.size(); ++i) //前缀和
66 preS[i] = preS[i‐1] + I[i];
67
68 /*
69 * for (int i = 0; i <= alls.size(); ++i)
70 * printf("%d ", preS[i]);
71 * NEXTLINE;
72 */
73
74 for (auto item : query) {
75 int l = find(item.fi),
76 r = find(item.se);
77 int res = preS[r] ‐ preS[l‐1];
78 printf("%d\n", res);
79 }
80 return 0;
81 }
9.2 数字和为 sum
9.2.1 01.cpp
1 #include <cstdio>
2 #include <cstring>
3 int n, sum;
4 int arr[n];
5 long long dp[sum+1]; //dp[i]表示和为i时的方案数 6
Nanchang university ACM template 第 209 页 7 int main() {
8 scanf("%d %d", &n, &sum);
9 for (int i = 0; i < n; ++i)
10 scanf("%d", &arr[i]);
11
12 memset(dp, 0, sizeof dp);
13
14 for (int i = 0; i < n; ++i) {
15 for (int j = sum; j >= 0; ‐‐j)
16 if (arr[i] + j <= sum)
17 dp[arr[i]+j] += dp[j];
18
19 if (arr[i] >= 0 && arr[i] <= sum)
20 dp[arr[i]]++;
21 }
22 printf("%lld\n", dp[sum]);
23 return 0;
24 }
9.3 随机化
9.3.1 模拟退火
9.3.1.1 模拟退火求函数值.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：模拟退火求函数值.cpp
4 * 创建日期：2021年03月07日 ‐‐‐‐ 16时06分 5 * 题 目：hdu1899
6 * 算 法：模拟退火 7 * 描 述：函数F(x) = 6x^7 + 8x^6 + 7x^3 + 5x^2 ‐ yx; 8 * x 的范围是0 <= x <= 100
9 * 输入y值，输出F(x)最小值
10 *
11 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
12
13 #include <cstdio>
14 #include <cmath>
15 #include <algorithm>
16 using namespace std;
17 const double eps = 1e‐8; //终止温度
18 double y;
19 double func(double x) {
20 return 6*pow(x, 7.0) + 8*pow(x, 3.0) + 5*pow(x, 2.0) ‐ y*x;
21 }
22
23 double solve() {
24 double T = 100; //初始温度
25 double delta = 0.98; //降温系数
26 double x = 10.0; //x初始值
27 double now = func(x); //计算初始函数值
28 double ans = now; //返回值
29 while (T > eps) { //eps是终止温度
30 int f[2] = {1, ‐1};
31 double newx = x + f[rand()%2] * T; //按概率改变x，随T的降温而减少
32 if (newx >= 0 && newx <= 100) {
33 double nxt = func(newx);
34 ans = min(ans, nxt);
35 if (now ‐ nxt > eps) //更新x
36 x = newx, now = nxt;
37 }
38 T *= delta;
39 }
40 return ans;
41 }
42
43 int main() {
44 int cas;
45 scanf("%d", &cas);
Nanchang university ACM template 第 210 页
46 while (cas‐‐) {
47 scanf("%lf", &y);
48 printf("%.4f\n", solve());
49 }
50 return 0;
51 }
9.3.2 mt19937.cpp
1 #include <cstdio>
2 #include <ctime>
3 #include <random>
4 using namespace std;
5 int main() {
6 //std::mt19937 myrand(seed) ，seed可不填，不填seed则会使用默认随机种子 7 mt19937 myrand(time(0));
8 printf("%ld\n", myrand());
9 return 0;
10 }
9.3.3 shuffle.cpp
1 #include <cstdio>
2 #include <random>
3 #include <algorithm>
4 using namespace std;
5 int arr[100];
67 int main() {
8 mt19937 myrand(time(0)); //默认随机种子是rand()，这里使用了time(0)
9 int n = myrand() % 10 + 10; //n是(10‐19)之间的随机数
10
11 for (int i = 0; i < n; ++i)
12 arr[i] = i;
13 printf("n = %d\n", n);
14
15 shuffle(arr+3, arr+9, myrand); //将数组(arr[3] ‐ arr[9])之间的数随机打乱
16 for (int i = 0; i < n; ++i) {
17 if (i == 3 || i == 9)
18 printf("| ");
19 printf("%d ", arr[i]);
20 }
21 printf("\n");
22 }
9.3.4 随机字符串.cpp
1 #include <cstdio>
2 #include <time.h>
3 #include <stdlib.h>
4 using namespace std;
5 int main() {
6 srand(time(0)); //产生随机化种子 7 int n=rand()%15+1; //在1‐15的范围内随机产生字符串个数 8 printf("%d",n);
9 while(n‐‐) { //依次产生n个字符串
10 printf("\n");
11 int k=rand()%50+1; //随机生成一个字符串的长度
12 for(int i=1;i<=k;i++) {
13 int x,s; //x表示这个字符的ascii码 ，s表示这个字符的大小写
14 s=rand()%2; //随机使s为1或0，为1就是大写，为0就是小写
15 if(s==1) //如果s=1
16 x=rand()%('Z'‐'A'+1)+'A'; //将x赋为大写字母的ascii码 //注意加一
17 else
18 x=rand()%('z'‐'a'+1)+'a'; //如果s=0，x赋为小写字母的ascii码
19 printf("%c",x); //将x转换为字符输出
Nanchang university ACM template 第 211 页
20 }
21 }
22 return 0;
23 }
9.3.5 随机数.cpp
1 #include <cstdio>
2 #include <cstdlib> //srand() rand()
3 #include <ctime> //time() time是C语言获取当前系统时间的函数，以秒作单位，代表当前时间自Unix标准时间戳(1970年1月1 日0点0分0秒，GMT)经过了多少秒。
4 #define MAXNUM 20000 //MAXNUM/MINNUM是随机数范围 5 #define MINNUM 10000.0 //MINNUM是随机数保留到小数点后多少位 6 using namespace std;
7 int main() {
8 srand(time(0)) ; //可以srand(10000*time(0)) 否则直接输出的随机数接近，
9 for(int i=0;i<10;i++)
10 printf("%f\n", (rand()%MAXNUM)/MINNUM);
11 return 0;
12 }
13
14 /*
15 * 编译运行后产生十个随机数，然后再次编辑运行产生的数还是这十个，如要改变，需使用srand()函数
16 * 产生的随机数范围是0~RAND_MAX，即0~2147483647 ，RAND_MAX定义在<cstdlib>中
17 * # define NUMMOD 20000
18 * # define NUMDEV 10000.0
19 * cout<<(rand()%NUMMOD)/NUMDEV<<endl;
20 * NUMMOD 决定生成随机数的值的范围，NUMDEV 决定取余后生成的小数的范围
21 */
9.3.6 随机选择算法.cpp
1 #include <cstdio>
2 #include <cstdlib>
3 #include <ctime>
4 #include <algorithm>
5 #include <cmath>
6 using namespace std;
7 const int N = 100010;
8 int num[N];
9
10 //随机核心
11 int randPartition(int num[], int left, int right) {
12 int random = (int)(round(1.0 * rand() / RAND_MAX * (right ‐ left) + left));
13 swap(num[random], num[left]);
14 int temp = num[left];
15
16 while (left < right) {
17 while (left < right && num[right] > temp)
18 right‐‐;
19
20 num[left] = num[right];
21
22 while (left < right && num[left] <= temp)
23 left++;
24
25 num[right] = num[left];
26 }
27 num[left] = temp;
28 return left;
29 }
30
31 //找寻第k大的数
32 int randSelect(int num[], int left, int right, int k) {
33 if (left == right)
34 return num[left];
35
Nanchang university ACM template 第 212 页
36 int p = randPartition(num, left, right);
37 int m = p ‐ left + 1;
38
39 if (k == m)
40 return num[p];
41 else
42 return randSelect(num, p + 1, right, k ‐ m);
43 }
44
45 int main() {
46 int num[] = {5, 8, 2, 7, 3, 6, 0, 1, 9, 4};
47 printf("%d\n", randSelect(num, 0, 9, 6));
48 return 0;
49 }
9.4 悬线法
9.4.1 直方图中最大矩形.cpp
1 /*‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
2 * 3 * 文件名称：02‐悬线法.cpp
4 * 创建日期：2021年08月02日 星期一 15时29分53秒 5 * 题 目：AcWing 0131 直方图中最大矩形 6 * 算 法：悬线法 7 * 描 述：使用单调栈也可以做，但是悬线法更简单 8 * 9 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐*/
10
11 #include <cstdio>
12 #include <algorithm>
13 using std::max;
14 const int maxn = 1e5 + 5;
15 int h[maxn];
16 // l[i]: 表示i位置的悬线能达到的最左边的位置
17 // r[i]: 表示i位置的悬线能达到的最右边的位置
18 int l[maxn], r[maxn];
19 long long res;
20
21 int main() {
22 int n;
23 while (scanf("%d", &n) && n) {
24 res = 0;
25 for (int i = 0; i < n; i++) {
26 scanf("%d", &h[i]);
27 l[i] = r[i] = i;
28 }
29
30 // 得到这根线向左能达到的位置
31 for (int i = 0; i < n; i++)
32 // 首先不能越界，而且要比我高这根线才能继续向左前进
33 while (l[i] > 0 && h[i] <= h[l[i] ‐ 1])
34 // 比我高的线都能通过，我也能
35 l[i] = l[l[i] ‐ 1];
36
37 // 得到这根线向右能达到的位置
38 for (int i = n‐1; i >= 0; i‐‐)
39 while (r[i] < n‐1 && h[i] <= h[r[i] + 1])
40 r[i] = r[r[i] + 1];
41
42 // 计算所有矩形面积
43 for (int i = 0; i < n; i++)
44 res = max(res, (long long)(r[i] ‐ l[i] + 1) * h[i]);
45 printf("%lld\n", res);
46 }
47 return 0;
48 }
Nanchang university ACM template 第 213 页
9.5 约瑟夫环
9.5.1 约瑟夫环.cpp
1 #include <cstdio>
23 int Joseph(int n,int m) {
4 int J = 0;
5 for(int i = 2; i <= n; i++)
6 J = (J + m) % i;
7 /*树组中的下标*/
8 return J;
9 }
10
11 int main() {
12 char car[12] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'};
13 printf("%c\n", car[Joseph(11, 3)]);
14 return 0;
15 }
10 计算几何
10.1 模板
10.1.1 template.cpp
1 #include <cstdio>
2 #include <cmath>
3 #include <algorithm>
4 #include <iostream>
5 using namespace std;
6 const double pi = acos(‐1.0); //高精度圆周率 7 const double eps = 1e‐8; //偏差值 8 const int maxp = 1010; //点的数量 9 int sgn(double x) { //判断x是否等于0
10 if (fabs(x) < eps) return 0;
11 else return x < 0 ? ‐1 : 1;
12 }
13
14 //比较两个浮点数：0 相等；‐1 小于；1 大于
15 int dcmp(double x, double y) {
16 if (fabs(x ‐ y) < eps) return 0;
17 else return x < y ? ‐1 : 1;
18 }
19
20 //‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐平面几何：点和线‐‐‐‐‐‐‐‐
21 /*定义点和基本运算*/
22 struct Point {
23 double x, y;
24 Point() {}
25 Point(double x, double y) : x(x), y(y) {}
26 Point operator + (Point B) {return Point(x+B.x, y+B.y);}
27 Point operator ‐ (Point B) {return Point(x‐B.x, y‐B.y);}
28 Point operator * (double k) {return Point(x*k, y*k);} //长度增大k倍
29 Point operator / (double k) {return Point(x/k, y/k);} //长度缩小k倍
30 bool operator == (Point B) {return sgn(x ‐ B.x) == 0 && sgn(y ‐ B.y) == 0;}
31 bool operator < (Point B) {return sgn(x ‐ B.x) < 0 || (sgn(x ‐ B.x) == 0 && sgn(y ‐ B.y) < 0);} //用于 凸包
32 };
33 typedef Point Vector; //定义向量
34 double Dot(Vector A, Vector B) {return A.x*B.x + A.y*B.y;} //点积
35 double Len(Vector A) {return sqrt(Dot(A, A));} //向量的长度
36 double Len2(Vector A) {return Dot(A, A);} //向量长度的平方
37 double Angle(Vector A, Vector B) {return acos(Dot(A,B)/Len(A)/Len(B));} //A与B的夹角
38 double Cross(Vector A, Vector B) {return A.x*B.y ‐ A.y*B.x;} //叉积
39 double Area2(Point A, Point B, Point C) {return Cross(B‐A, C‐A);} //三角形ABC面积的2倍
40 double Distance(Point A, Point B) {return hypot(A.x‐B.x, A.y‐B.y);} //两点的距离
41 double Dist(Point A, Point B) {return sqrt((A.x‐B.x)*(A.x‐B.x) + (A.y‐B.y)*(A.y‐B.y));}
42 Vector Normal(Vector A) {return Vector(‐A.y/Len(A), A.x/Len(A));} //向量A的单位法向量
Nanchang university ACM template 第 214 页
43
44 /*向量平行或重合*/
45 bool Parallel(Vector A, Vector B) {return sgn(Cross(A, B)) == 0;}
46
47 /*向量A逆时针旋转rad度*/
48 Vector Rotate(Vector A, double rad) {
49 return Vector(A.x*cos(rad)‐A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));
50 }
51
52 struct Line {
53 Point p1, p2;//线上的两个点
54 Line() {}
55 Line(Point p1, Point p2) : p1(p1), p2(p2) {}
56 // Line(Point x,Point y) {p1 = x;p2 = y;}
57 // Point(double x,double y):x(x),y(y) {}
58 // 根据一个点和倾斜角 angle 确定直线,0<=angle<pi
59 Line(Point p, double angle) {
60 p1 = p;
61 if (sgn(angle ‐ pi/2) == 0) {p2 = (p1 + Point(0,1));}
62 else {p2 = (p1 + Point(1, tan(angle)));}
63 }
64 // ax+by+c=0
65 Line(double a, double b, double c) {
66 if (sgn(a) == 0) {
67 p1 = Point(0, ‐c/b);
68 p2 = Point(1, ‐c/b);
69 }
70 else if (sgn(b) == 0) {
71 p1 = Point(‐c/a, 0);
72 p2 = Point(‐c/a, 1);
73 }
74 else{
75 p1 = Point(0, ‐c/b);
76 p2 = Point(1, (‐c‐a)/b);
77 }
78 }
79 };
80
81 typedef Line Segment; //定义线段，两端点是Point p1,p2
82
83 /*返回直线倾斜角 0 <= angle < pi*/
84 double Line_angle(Line v) {
85 double k = atan2(v.p2.y‐v.p1.y, v.p2.x‐v.p1.x);
86 if (sgn(k) < 0) k += pi;
87 if (sgn(k‐pi) == 0) k ‐= pi;
88 return k;
89 }
90
91 /*点和直线关系:1 在左侧;2 在右侧;0 在直线上*/
92 int Point_line_relation(Point p, Line v) {
93 int c = sgn(Cross(p‐v.p1, v.p2‐v.p1));
94 if (c < 0) return 1; //1：p在v的左边
95 if (c > 0) return 2; //2：p在v的右边
96 return 0; //0：p在v上
97 }
98 /*点和线段的关系：0 点p不在线段v上；1 点p在线段v上*/
99 bool Point_on_seg(Point p, Line v) {
100 return sgn(Cross(p‐v.p1, v.p2‐v.p1)) == 0 && sgn(Dot(p ‐ v.p1, p‐ v.p2)) <= 0;
101 }
102
103 /*两直线关系:0 平行,1 重合,2 相交*/
104 int Line_relation(Line v1, Line v2) {
105 if (sgn(Cross(v1.p2‐v1.p1, v2.p2‐v2.p1)) == 0) {
106 if (Point_line_relation(v1.p1, v2) == 0) return 1; //1 重合
107 else return 0; //0 平行
108 }
109 return 2; //2 相交
110 }
111
112 /*点到直线的距离*/
Nanchang university ACM template 第 215 页
113 double Dis_point_line(Point p, Line v) {
114 return fabs(Cross(p‐v.p1, v.p2‐v.p1))/Distance(v.p1, v.p2);
115 }
116
117 /*点在直线上的投影*/
118 Point Point_line_proj(Point p, Line v) {
119 double k = Dot(v.p2‐v.p1, p‐v.p1)/Len2(v.p2‐v.p1);
120 return v.p1+(v.p2‐v.p1)*k;
121 }
122
123 /*点p对直线v的对称点*/
124 Point Point_line_symmetry(Point p, Line v) {
125 Point q = Point_line_proj(p, v);
126 return Point(2*q.x‐p.x, 2*q.y‐p.y);
127 }
128
129 /*点到线段的距离*/
130 double Dis_point_seg(Point p, Segment v) {
131 if (sgn(Dot(p‐ v.p1, v.p2‐v.p1)) < 0 || sgn(Dot(p‐ v.p2,v.p1‐v.p2)) < 0) //点的投影不在线段上
132 return min(Distance(p, v.p1), Distance(p, v.p2));
133 return Dis_point_line(p, v); //点的投影在线段上
134 }
135
136 /*求两直线ab和cd的交点*/
137 /*调用前要保证两直线不平行或重合*/
138 Point Cross_point(Point a, Point b, Point c, Point d) { //Line1:ab, Line2:cd
139 double s1 = Cross(b‐a, c‐a);
140 double s2 = Cross(b‐a, d‐a); //叉积有正负
141 return Point(c.x*s2‐d.x*s1, c.y*s2‐d.y*s1)/(s2‐s1);
142 }
143 /*两线段是否相交：1 相交，0不相交*/
144 bool Cross_segment(Point a, Point b, Point c, Point d) { //Line1:ab, Line2:cd
145 double c1 = Cross(b‐a, c‐a), c2 = Cross(b‐a, d‐a);
146 double d1 = Cross(d‐c, a‐c), d2 = Cross(d‐c, b‐c);
147 return sgn(c1)*sgn(c2) < 0 && sgn(d1)*sgn(d2) < 0; //注意交点是端点的情况不算在内
148 }
149
150 //‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐平面几何：多边形‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
151 struct Polygon {
152 int n; //多边形的顶点数
153 Point p[maxp]; //多边形的点
154 Line v[maxp]; //多边形的边
155 };
156
157 /*判断点和任意多边形的关系: 3 点上; 2 边上; 1 内部; 0 外部*/
158 int Point_in_polygon(Point pt, Point *p, int n) { //点pt，多边形Point *p
159 for (int i = 0; i < n; ++i) //点在多边形的顶点上
160 if (p[i] == pt)
161 return 3;
162
163 for (int i = 0; i < n; ++i) {//点在多边形的边上
164 Line v = Line(p[i], p[(i+1)%n]);
165 if (Point_on_seg(pt, v))
166 return 2;
167 }
168 int num = 0;
169 for (int i = 0; i < n; ++i) {
170 int j = (i+1) % n;
171 int c = sgn(Cross(pt‐p[j], p[i]‐p[j]));
172 int u = sgn(p[i].y ‐ pt.y);
173 int v = sgn(p[j].y ‐ pt.y);
174 if (c > 0 && u < 0 && v >= 0) ++num;
175 if (c < 0 && u >= 0 && v < 0) ‐‐num;
176 }
177 return num != 0; //1 内部; 0 外部
178 }
179
180 /*Point *p表示多边形。从原点开始划分三角形*/
181 double Polygon_area(Point *p, int n) {
182 double area = 0;
Nanchang university ACM template 第 216 页
183 for (int i = 0; i < n; ++i)
184 area += Cross(p[i], p[(i+1)%n]);
185 return area/2; //面积有正负，不能简单地取绝对值
186 }
187
188 /*求多边形重心。Point *p表示多边形*/
189 Point Polygon_center(Point *p, int n) {
190 Point ans(0, 0);
191 if (Polygon_area(p, n) == 0)
192 return ans;
193 for (int i = 0; i < n; ++i)
194 ans = ans + (p[i]+p[(i+1)%n]) * Cross(p[i], p[(i+1)%n]); //面积有正负
195 return ans/Polygon_area(p, n)/6.;
196 }
197
198 /*Convex_hull()求凸包。凸包顶点放在ch中，返回值是凸包的顶点数*/
199 int Convex_hull(Point *p, int n, Point *ch) {
200 sort(p, p+n); //对点排序：按x从小到大排序，如果x相同，按y排序
201 n = unique(p, p+n)‐p; //去除重复点
202 int v = 0;
203 //求下凸包。如果p[i]是右拐弯的，这个点不在凸包上，往回退
204 for (int i = 0; i < n; ++i) {
205 while (v > 1 && sgn(Cross(ch[v‐1]‐ch[v‐2], p[i]‐ch[v‐2])) <= 0)
206 ‐‐v;
207 ch[v++] = p[i];
208 }
209 int j = v;
210 //求上凸包
211 for (int i = n‐2;i >= 0;i‐‐) {
212 while (v > j && sgn(Cross(ch[v‐1]‐ch[v‐2], p[i]‐ch[v‐2])) <= 0)
213 ‐‐v;
214 ch[v++] = p[i];
215 }
216 if (n > 1) ‐‐v;
217 return v; //返回值v是凸包的顶点数
218 }
219
220 //‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐平面几何：圆‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
221 struct Circle {
222 Point c;//圆心
223 double r;//半径
224 Circle() {}
225 Circle(Point c, double r) : c(c), r(r) {}
226 Circle(double x, double y, double _r) {c = Point(x, y) ; r = _r;}
227 };
228
229 /*点和圆的关系: 0 点在圆内, 1 圆上, 2 圆外*/
230 int Point_circle_relation(Point p, Circle C) {
231 double dst = Distance(p, C.c);
232 if (sgn(dst ‐ C.r) < 0) return 0; //点在圆内
233 if (sgn(dst ‐ C.r) ==0) return 1; //圆上
234 return 2; //圆外
235 }
236
237 /*直线和圆的关系：0 直线在圆内, 1 直线和圆相切, 2 直线在圆外*/
238 int Line_circle_relation(Line v, Circle C) {
239 double dst = Dis_point_line(C.c, v);
240 if (sgn(dst‐C.r) < 0) return 0; //直线在圆内
241 if (sgn(dst‐C.r) ==0) return 1; //直线和圆相切
242 return 2; //直线在圆外
243 }
244
245 /*线段和圆的关系：0 线段在圆内, 1 线段和圆相切, 2 线段在圆外*/
246 int Seg_circle_relation(Segment v, Circle C) {
247 double dst = Dis_point_seg(C.c, v);
248 if (sgn(dst‐C.r) < 0) return 0; //线段在圆内
249 if (sgn(dst‐C.r) ==0) return 1; //线段和圆相切
250 return 2; //线段在圆外
251 }
252
Nanchang university ACM template 第 217 页
253 /*直线和圆的交点 hdu 5572*/
254 int Line_cross_circle(Line v, Circle C, Point &pa, Point &pb) {//pa, pb是交点。返回值是交点个数
255 if (Line_circle_relation(v, C) == 2) return 0;//无交点
256 Point q = Point_line_proj(C.c, v); //圆心在直线上的投影点
257 double d = Dis_point_line(C.c, v); //圆心到直线的距离
258 double k = sqrt(C.r*C.r‐d*d); //
259 if (sgn(k) == 0) { //1个交点，直线和圆相切
260 pa = q;
261 pb = q;
262 return 1;
263 }
264 Point n=(v.p2‐v.p1)/ Len(v.p2‐v.p1); //单位向量
265 pa = q + n*k;
266 pb = q ‐ n*k;
267 return 2;//2个交点
268 }
269
270 //‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐三维几何‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
271 /*三维：点*/
272 struct Point3 {
273 double x, y, z;
274 Point3() {}
275 Point3(double x, double y, double z) : x(x), y(y), z(z) {}
276 Point3 operator + (Point3 B) {return Point3(x+B.x, y+B.y, z+B.z);}
277 Point3 operator ‐ (Point3 B) {return Point3(x‐B.x, y‐B.y, z‐B.z);}
278 Point3 operator * (double k) {return Point3(x*k, y*k, z*k);}
279 Point3 operator / (double k) {return Point3(x/k, y/k, z/k);}
280 bool operator == (Point3 B) {return sgn(x‐B.x)==0 && sgn(y‐B.y)==0 && sgn(z‐B.z)==0;}
281 };
282 typedef Point3 Vector3;
283 /*点积。和二维点积函数同名。C++允许函数同名*/
284 double Dot(Vector3 A, Vector3 B) {return A.x*B.x+A.y*B.y+A.z*B.z;}
285 /*叉积*/
286 Vector3 Cross(Vector3 A, Vector3 B) {return Point3(A.y*B.z‐A.z*B.y, A.z*B.x‐A.x*B.z, A.x*B.y‐A.y*B.x);}
287 double Len(Vector3 A) {return sqrt(Dot(A, A));} //向量的长度
288 double Len2(Vector3 A) {return Dot(A, A);} //向量长度的平方
289 double Distance(Point3 A, Point3 B) {
290 return sqrt((A.x‐B.x)*(A.x‐B.x)+(A.y‐B.y)*(A.y‐B.y)+(A.z‐B.z)*(A.z‐B.z));
291 }
292 double Angle(Vector3 A, Vector3 B) {return acos(Dot(A, B)/Len(A)/Len(B));} //A与B的夹角
293 /*三维：线*/
294 struct Line3 {
295 Point3 p1, p2;
296 Line3() {}
297 Line3(Point3 p1, Point3 p2) : p1(p1), p2(p2) {}
298 };
299 typedef Line3 Segment3; //定义线段，两端点是Point p1,p2
300
301 /*三角形面积的2倍*/
302 double Area2(Point3 A, Point3 B, Point3 C) {return Len(Cross(B‐A, C‐A));}
303
304 /*三维：点到直线距离*/
305 double Dis_point_line(Point3 p, Line3 v) {
306 return Len(Cross(v.p2‐v.p1, p‐v.p1))/Distance(v.p1, v.p2);
307 }
308
309 /*三维：点在直线上*/
310 bool Point_line_relation(Point3 p, Line3 v) {
311 return sgn( Len(Cross(v.p1‐p, v.p2‐p))) == 0 && sgn(Dot(v.p1‐p, v.p2‐p)) == 0;
312 }
313 /*三维：点到线段距离*/
314 double Dis_point_seg(Point3 p, Segment3 v) {
315 if (sgn(Dot(p‐ v.p1, v.p2‐v.p1)) < 0 || sgn(Dot(p‐ v.p2, v.p1‐v.p2)) < 0)
316 return min(Distance(p, v.p1), Distance(p, v.p2));
317 return Dis_point_line(p, v);
318 }
319 /*三维：点 p 在直线上的投影*/
320 Point3 Point_line_proj(Point3 p, Line3 v) {
321 double k = Dot(v.p2‐v.p1, p‐v.p1)/Len2(v.p2‐v.p1);
322 return v.p1+(v.p2‐v.p1)*k;
Nanchang university ACM template 第 218 页
323 }
324 /*三维：平面*/
325 struct Plane {
326 Point3 p1, p2, p3;//平面上的三个点
327 Plane() {}
328 Plane(Point3 p1, Point3 p2, Point3 p3) : p1(p1), p2(p2), p3(p3) {}
329 };
330 /*平面法向量*/
331 Point3 Pvec(Point3 A, Point3 B, Point3 C) {return Cross(B‐A,C‐A);}
332 Point3 Pvec(Plane f) {return Cross(f.p2‐f.p1, f.p3‐f.p1);}
333 /*四点共平面*/
334 bool Point_on_plane(Point3 A, Point3 B, Point3 C, Point3 D) {
335 return sgn(Dot(Pvec(A, B, C), D‐A)) == 0;
336 }
337 /*两平面平行*/
338 int Parallel(Plane f1, Plane f2) {
339 return Len(Cross(Pvec(f1), Pvec(f2))) < eps;
340 }
341 /*两平面垂直*/
342 int Vertical (Plane f1, Plane f2) {
343 return sgn(Dot(Pvec(f1), Pvec(f2)))==0;
344 }
345 /*直线与平面的交点p，返回值是交点个数*/
346 int Line_cross_plane(Line3 u, Plane f, Point3 &p) {
347 Point3 v = Pvec(f);
348 double x = Dot(v, u.p2‐f.p1);
349 double y = Dot(v, u.p1‐f.p1);
350 double d = x‐y;
351 if (sgn(x) == 0 && sgn(y) == 0) return ‐1;//‐1：v在f上
352 if (sgn(d) == 0) return 0; //0：v与f平行
353 p = ((u.p1*x) ‐ (u.p2*y))/d; //v与f相交
354 return 1;
355 }
356
357 /*四面体有向体积*6*/
358 double volume4(Point3 A, Point3 B, Point3 C, Point3 D) {return Dot(Cross(B‐A, C‐A), D‐A);}
359
360
361 int main() {
362 Point a(0, 1), b(0, 0), c(1, 1), d(1, 2), p(1.5, 1);
363 Line k(a, b), k2(c, d);
364 Point pr(1, 1), cr(1, 1); double r = 1;
365 Circle C(cr, r);
366
367 cout << endl << "Line_circle_relation=" << Line_circle_relation(k, C);
368 cout << endl << "Seg_circle_relation=" << Seg_circle_relation(k, C);
369 cout << endl << "Point_circle_relation=" << Point_circle_relation(pr, C);
370 cout << endl << "parallel=" << Parallel(a, b) << endl;
371 cout << "dot=" << Dot(a, b) << endl << " angle=" << Angle(a, b) << endl;
372 cout << "90:" << sgn(Rotate(a, ‐pi/2).x) << endl << Rotate(a, ‐pi/2).y;
373 cout << endl << "line angle=" << Line_angle(k)*4;
374 cout << endl << "line place=" << Point_line_relation(p, k);
375 cout << endl << "point_on_seg=" << Point_on_seg(p, k);
376 cout << endl << "dis_point_line=" << Dis_point_line(p, k);
377 cout << endl << "dis_point_line=" << Dis_point_seg(p, k);
378 Point pp = Cross_point(a, b, c, d);
379 cout << endl << "crosspoint=" << pp.x << " " << pp.y;
380 cout << endl << "cross seg=" << Cross_segment(a, b, c, d);
381 cout << endl << "distance=" << Distance(a, b);
382 cout << endl << "line_relation=" << Line_relation(k, k2);
383 Point g[4];
384 g[0] = a; g[1] = b; g[2] = c; g[3] = d;
385 cout << endl << "Point_in_polygon=" << Point_in_polygon(p, g, 4);
386 cout << endl << "Polygon_area=" << Polygon_area(g, 4);
387 cout << endl << endl;
388 return 0;
389 }
