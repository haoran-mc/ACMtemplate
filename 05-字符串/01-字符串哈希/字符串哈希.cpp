/*----------------------------------------------------------------
 *
 *   文件名称：01.cpp
 *   创建日期：2021年08月11日 星期三 00时17分16秒
 *   题    目：AcWing 0841 字符串哈希
 *   算    法：哈希
 *   描    述：预处理所有前缀的哈希
 *                               hash?
 *   [高位]                     <--------->          [低位]
 *   |-------------------------|-----------|--------------|
 *   1                         L           R
 *   ^
 *   |----  从1开始，
 *
 *
 *   我们现在已知ha[L-1]，ha[R]
 *
 *   ha[L-1]: 表示下面这个子串的哈希值
 *   |------------------------|
 *   1                      L - 1
 *
 *   ha[R]: 表示下面这个长的子串的哈希值
 *   |-------------------------|-----------|
 *   1                         L           R
 *
 *   让上面的两个串的高位对齐、相减得到我们想要表示出[L, R]区间的哈希值
 *   $hash = ha[R] - ha[L] * p^{R - L + 1};$
 *
 ----------------------------------------------------------------*/

#include <cstdio>
typedef unsigned long long ull;
const int maxn = 1e5 + 5;
int P = 131;   // P进制数，虽然没写Q = 2^64，但是ull溢出隐藏了这一步
int n, m;
char str[maxn];
ull ha[maxn], p[maxn];   // 发现公式中需要乘一个p的一个指数，所以用一个数组预处理

ull get(int l, int r) {
    return ha[r] - ha[l - 1] * p[r - l + 1];
}

int main() {
    scanf("%d %d", &n, &m);
    scanf("%s", str + 1);
    p[0] = 1;   // p^0 = 1;
    for (int i = 1; i <= n; ++i) {   // 预处理p数组，与前缀子串哈希
        p[i] = p[i-1] * P;
        // P是131，这是一个131进制的数，一个131进制的数的一个位上出现'z' = 122有问题吗？
        // 我告诉你，显然没问题
        ha[i] = ha[i-1] * P + str[i];   // woc，不用str[i] - 'a' + 1，神了
    }
    while (m --) {
        int l1, r1, l2, r2;
        scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
        if (get(l1, r1) == get(l2, r2))
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
